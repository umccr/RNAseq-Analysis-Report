---
title: 'UMCCR Transcriptome Patient Summary'
author: 'Jacek Marzec, Sehrish Kanwal, Lavinia Gordon'
date: '`r Sys.Date()`'
output:
  html_document:
    theme: readable
    toc: true
    toc_float: true
    code_folding: hide
  rmdformats::material:
    highlight: kate
params:
  report_dir: 
  sample_name: 
  count_file: 
  tissue: 'pancreas'
  datasets: '../data/Datasets_list_PDAC.txt'
  normal_group: 'Normal (pancreas)'
  cancer_group: 'PDAC'
  genes_fusions: '../data/Genes_fusions.txt'
  genes_pmcc: '../data/Genes_PMCC.txt'
  genes_immune: '../data/Genes_immune.txt'
  pizzly_folder: '../data/pizzly-validation'
  oncokb_genes: '../data/OncoKB/CancerGenesList.txt'
  oncokb_clin_vars: '../data/OncoKB/allActionableVariants.txt'
  oncokb_all_vars: '../data/OncoKB/allAnnotatedVariants.txt'
---

RNA-seq report for patient sample **`r params$sample_name`**.

```{r define_functions, comment=NA, message=FALSE, warning=FALSE}
##### Define functions
##### Create 'not in' operator
"%!in%" <- function(x,table) match(x,table, nomatch = 0) == 0

##### Prepare object to write into a file
prepare2write <- function (x) {
  
  x2write <- cbind(rownames(x), x)
  colnames(x2write) <- c("Gene",colnames(x))
  return(x2write)
}

##### Combine sample expression profile with reference datasets. This function outputs a vector with first element containing the merged data and second element containing merged targets info
combineDatasets <- function(sample_name, sample_counts, ref_dataset) {
  
  ##### Read file with reference datasets information
  DatasetInput=read.table(ref_dataset, sep="\t", as.is=TRUE, header=TRUE, row.names=1)
  
  ##### Extract info about target file for the first dataset
  fileInfo = strsplit(DatasetInput[,"Target_file"], split='/', fixed=TRUE)
  targetFile <- read.table(DatasetInput[1,"Target_file"], sep="\t", as.is=TRUE, header=TRUE)[,c(1:4)]
  rownames(targetFile) <- targetFile[,"Sample_name"]
  targetFile <- cbind(targetFile[,2:4],rownames(DatasetInput[1,]))
  colnames(targetFile)[ncol(targetFile)] <- "Dataset"
  
  if ( nrow(DatasetInput) > 1 ) {
    for ( i in 2:nrow(DatasetInput) ) {
        
      ##### Create a temporary object to store info from the remaining target files
      targetFileTmp <- read.table(DatasetInput[i,"Target_file"], sep="\t", as.is=TRUE, header=TRUE)[,c(1:4)]
      rownames(targetFileTmp) <- targetFileTmp[,"Sample_name"]
      targetFileTmp <- cbind(targetFileTmp[,2:4],rownames(DatasetInput[i,]))
      colnames(targetFileTmp)[ncol(targetFileTmp)] <- "Dataset"
        
      targetFile <- rbind(targetFile, targetFileTmp)
    }
  }  
  
  ##### Add sample info
  sampleTargetFile <- data.frame(sample_counts, sample_name, NA, sample_name)
  names(sampleTargetFile) <- names(targetFile)
  rownames(sampleTargetFile) <- sample_name
  targetFile <- rbind( targetFile, sampleTargetFile )
  
  ##### Make syntactically valid names
  rownames(targetFile) <- make.names(rownames(targetFile))
  
  ##### Read sample read count file and combine it with reference datasets
  datasets.comb=read.table(sample_counts, sep="\t", as.is=TRUE, header=FALSE, row.names=NULL)
  names(datasets.comb) <- c("", sample_name)
      
  ##### list genes present in the read count file
  gene_list <- as.vector(datasets.comb[,1])
      
  ##### Loop through the expression data from different datasets and merge them into one matrix
  for ( data_matrix in DatasetInput[ , "Expression_matrix" ] ) {
    
    ##### Add data from the reference datasets
    dataset <- as.data.frame( read.table(data_matrix, header=TRUE, sep="\t", row.names=NULL) )
      
    ##### list genes present in individal files
    gene_list <- c( gene_list, as.vector(dataset[,1]) )
    
    ##### Merge the expression datasets and make sure that the genes order is the same
    datasets.comb <- merge( datasets.comb, dataset, by=1, all = FALSE, sort= TRUE)
      
    ##### Remove per-sample data for merged samples to free some memory
    rm(dataset)
  }
  
  ##### Use gene IDs as rownames
  rownames(datasets.comb) <- datasets.comb[,1]
  datasets.comb <- datasets.comb[, -1]
  
  ##### Make syntactically valid names
  colnames(datasets.comb) <- make.names(colnames(datasets.comb))
  
  ##### Make sure that the target file contains info only about samples present in the data matrix
  targetFile <- targetFile[ rownames(targetFile) %in% colnames(datasets.comb),  ]
  
  ##### Make sure that the samples order in the data matrix is the same as in the target file 
  datasets.comb <- datasets.comb[ , rownames(targetFile) ]
  
  ##### Identify genes that were not present across all per-sampel files and were ommited in the merged matrix
  gene_list <- unique(gene_list)
  gene_list.missing <- gene_list[ gene_list %!in% rownames(datasets.comb) ]
  
  ##### Write list of missing genes into a file
  if ( length(gene_list.missing) > 0 ) {
    write.table(prepare2write(gene_list.missing), file = paste0(params$report_dir, "/", sample_name,".missing_genes.txt"), sep="\t", quote=FALSE, row.names=TRUE, append = FALSE )
  }
  
    return( list(datasets.comb, targetFile) )
}


##### Assign colours to different groups
getTargetsColours <- function(targets) {
  
##### Predefined selection of colours for groups
targets.colours <- c("red","blue","green","darkgoldenrod","darkred","deepskyblue", "coral", "cornflowerblue", "chartreuse4", "bisque4", "chocolate3", "cadetblue3", "darkslategrey", "lightgoldenrod4", "mediumpurple4", "orangered3","indianred1","blueviolet","darkolivegreen4","darkgoldenrod4","firebrick3","deepskyblue4", "coral3", "dodgerblue1", "chartreuse3", "bisque3", "chocolate4", "cadetblue", "darkslategray4", "lightgoldenrod3", "mediumpurple3", "orangered1")
  
  f.targets <- factor(targets)
  vec.targets <- targets.colours[1:length(levels(f.targets))]
  targets.colour <- rep(0,length(f.targets))
  for(i in 1:length(f.targets))
    targets.colour[i] <- vec.targets[ f.targets[i]==levels(f.targets)]
  
  return( list(vec.targets, targets.colour) )
}

##### Assign colours to different datasets
getDatasetsColours <- function(datasets) {
  
  ##### Predefined selection of colours for datasets
  datasets.colours <- c("dodgerblue","firebrick","lightslategrey","darkseagreen","orange","darkcyan","bisque", "coral2", "cadetblue3","red","blue","green")
  
  f.datasets <- factor(datasets)
  vec.datasets <- datasets.colours[1:length(levels(f.datasets))]
  datasets.colour <- rep(0,length(f.datasets))
  for(i in 1:length(f.datasets))
    datasets.colour[i] <- vec.datasets[ f.datasets[i]==levels(f.datasets)]
  
  return( list(vec.datasets, datasets.colour) )
}

##### Perform PCA. This function outputs a list with dataframe and samples colouring info ready for plotting
pca <- function(data, targets) {

  ##### Keep only genes with variance > 0 across all samples
  rsd <- apply(data,1,sd)
  data.subset <- data[rsd>0,]
  
  ##### Perform PCA
  data.subset_pca <- prcomp(t(data.subset), scale=FALSE)
  
  ##### Get variance importance for all principal components
  importance_pca <- summary(data.subset_pca)$importance[2,]
  importance_pca <- paste(round(100*importance_pca, 2), "%", sep="")
  names(importance_pca) <- names(summary(data.subset_pca)$importance[2,])
    
  ##### Prepare data frame
  data.subset_pca.df <- data.frame(targets$Target, targets$Dataset, data.subset_pca$x[,"PC1"], data.subset_pca$x[,"PC2"], data.subset_pca$x[,"PC3"])
  colnames(data.subset_pca.df) <- c("Target", "Dataset", "PC1", "PC2", "PC3")
  
  ##### Assigne colours to targets and datasets
  targets.colour <- getTargetsColours(target$Target)
  datasets.colour <- getDatasetsColours(target$Dataset)
  
  ##### Create a list with dataframe and samples colouring info
  pca.list <- list(data.subset_pca.df, importance_pca, targets.colour, datasets.colour)
  names(pca.list) <- c("pca.df", "importance_pca", "targets", "datasets")
  
  return( pca.list )
}

##### Convert a vector of numbers into corresponding vector of their percentiles
perc.rank <- function(x) trunc(rank(x))*100/length(x)

##### Perform range standardization between 0 and 1 (for the cumulative sums)
standardization <- function(x) sort(x-min(x))/(max(x)-min(x))

##### Calculate mean, sd, quantiles and cumulative franctions for expression data from specific sample group
exprGroupStats <- function(data, targets, target) {
  
  ##### Subset data for defined biological group
  data.group <- data[, targets$Target %in% target ]
  
  ##### For groups with > 1 sample get the mean and standard deviation for each gene
  if ( !is.null(ncol(data.group)) )  {
    
    data.group.median <- rowMedians(data.group)
    names(data.group.median) <- rownames(data)
    data.group.median <- sort(data.group.median)
    data.group.sd <- rowSds(data.group)
    
  } else {
    data.group.median <- sort(data.group)
    data.group.sd <- rep( NA, length(data.group))
  }
  
  ##### Make sure the median and sd vectors have the same gene order
  names(data.group.sd) <- rownames(data)
  data.group.sd <- data.group.sd[names(data.group.median)]

  ##### Convert a expression values into corresponding percentiles
  data.group.q <- perc.rank(data.group.median)
  
  ##### Perform range standardization between 0 and 1 (for the cumulative sums), otherwise the negative values are summed up
  data.group.s <- standardization(data.group.median)
  
  ##### Calculate cumulative sums and perform range standardization between 0 and 1 
  data.group.cum <- standardization(cumsum(data.group.s))
  
  ##### Perform Z-score transformation of the median expression values
  data.group.z <- scale(data.group.median)
  
  ##### Organise the data into data frame
  data.group.df <- as.data.frame(cbind( data.group.median, data.group.sd, data.group.z, data.group.q, data.group.cum))
  names(data.group.df) <- c("median", "sd", "z", "quantile", "cumulative_fraction")
  
  return( data.group.df )
}
  
  
##### Generate cumulative distribution function (CDF) plot for selected gene. If option "addBoxPlot" = TRUE, then generate additional boxplot below to show the data variance for selected gene in individual groups
cdfPlot <- function(gene, data, targets, sampleName, normal, cancer, addBoxPlot = FALSE) {
  
  ##### Get expression-related stats for each group
  sample.expr.cum <- exprGroupStats(data, targets, sampleName)
  cancer.expr.cum <- exprGroupStats(data, targets, cancer)
  normal.expr.cum <- exprGroupStats(data, targets, normal)
  
  ##### Extract expression for selected genes
  sample.expr.cum.selected <- sample.expr.cum[ rownames(sample.expr.cum) %in% gene, ]
  cancer.expr.cum.selected <- cancer.expr.cum[ rownames(cancer.expr.cum) %in% gene, ]
  normal.expr.cum.selected <- normal.expr.cum[ rownames(normal.expr.cum) %in% gene, ]
  
  ##### Generate box-plot for selected gene
  if ( addBoxPlot ) {
    
    data.z <- scale(data)
    targets$Target[ targets$Target==sampleName ] <- "Patient"
    
    gene.expr.df <- data.frame(targets$Target, data.z[gene, ])
    colnames(gene.expr.df) <- c("Group", "Expression")
    
    ##### Reorder groups
    gene.expr.df$Group <- factor(gene.expr.df$Group, levels=c(normal, cancer, "Patient"))
      
    p2 <- plot_ly(gene.expr.df, x= ~Expression, color = ~Group, type = 'box', jitter = 0.3, pointpos = 0, boxpoints = 'all', colors = c("darkgreen", "red", "black"), opacity = 0.5, orientation = 'h', width = 800, height = 600, showlegend=FALSE)
  }
  
  ##### Generate interactive CFD plot with plotly
  p1 <- plot_ly(sample.expr.cum, x = ~z, color = I("black")) %>%
  
    ##### Add sample data
    add_markers(y = sample.expr.cum.selected$cumulative_fraction, x = sample.expr.cum.selected$z,
                text = rownames(sample.expr.cum.selected ),
                name = "Patient",
                marker = list(size = 12, color = "black"),
                showlegend = TRUE) %>%
  
    add_lines(y = sample.expr.cum$cumulative_fraction, x = sample.expr.cum$z, 
              line = list(color = "grey"),
              text = rownames( sample.expr.cum ),
              name = "Patient", showlegend = FALSE) %>%
    
    ##### Add cancer data
    add_markers(y = cancer.expr.cum.selected$cumulative_fraction, x =  cancer.expr.cum.selected$z,
                text = rownames( cancer.expr.cum.selected),
                name = cancer,
                marker = list(size = 12, opacity = 0.5, color = "red"),
                showlegend = TRUE) %>%
  
    add_lines(y = cancer.expr.cum$cumulative_fraction, x = cancer.expr.cum$z, opacity = 0.5,
              line = list(color = "red", dash = "dash"),
              text = rownames( cancer.expr.cum ),
              name = cancer, showlegend = FALSE) %>%
    
    ##### Add normal data
    add_markers(y = normal.expr.cum.selected$cumulative_fraction, x =  normal.expr.cum.selected$z,
                text = rownames( normal.expr.cum.selected ),
                name = normal,
                marker = list(size = 12, opacity = 0.5, color = "green"),
                showlegend = TRUE) %>%
  
    add_lines(y = normal.expr.cum$cumulative_fraction, x = normal.expr.cum$z, opacity = 0.5,
              line = list(color = "green", dash = "dash"),
              text = rownames( normal.expr.cum ),
              name = normal, showlegend = FALSE) %>%
    
    ##### Add quantile lines
    add_lines(y = seq(0,1,0.1), x = rep(quantile(sample.expr.cum$z, probs=0:4/4)[2], 11), opacity = 0.5,
              line = list(color = "gray", opacity = 0.2, dash = "dash"),
              name = "Q1", showlegend = FALSE) %>%
    
    add_lines(y = seq(0,1,0.1), x = rep(quantile(sample.expr.cum$z, probs=0:4/4)[3], 11), opacity = 0.5,
              line = list(color = "gray", opacity = 0.2, dash = "dash"),
              name = "Q2", showlegend = FALSE) %>%
    
    add_lines(y = seq(0,1,0.1), x = rep(quantile(sample.expr.cum$z, probs=0:4/4)[4], 11), opacity = 0.5,
              line = list(color = "gray", opacity = 0.2, dash = "dash"),
              name = "Q3", showlegend = FALSE) %>% 
    
        layout(title = gene, xaxis = list(title = "mRNA expression (Z-score)", zeroline = FALSE, range = c(min(sample.expr.cum$z)-1.5, max(sample.expr.cum$z)+1.5)),
           yaxis = list(title = "Cumulative fraction"),
           legend = list(orientation = 'v', x = 0.02, y = 1, bgcolor = "white")
           
           ##### Annotate the gene of interest
           #annotations = list(x = sample.expr.cum.selected$z, y = sample.expr.cum.selected$cumulative_fraction,
           #text = rownames(sample.expr.cum.selected), xref = "x", yref = "y", showarrow = TRUE, arrowhead = 0, opacity = 0.5, ax = 30, ay = 30)
    )
  
  ##### Combine CDF plot with boxplot if this option is selected
  if ( addBoxPlot ) {
    
    p1_2 <- subplot(p1, p2, nrows = 2, shareX = TRUE, shareY = FALSE, titleY = TRUE) %>%
  layout(xaxis = list(title = "mRNA expression (Z-score)", zeroline = FALSE, range = c(min(sample.expr.cum$z)-1.5, max(sample.expr.cum$z)+1.5)),
          yaxis = list(title = "Cumulative fraction"),
          legend = list(orientation = 'v', x = 0.02, y = 1, bgcolor = "white"),
          yaxis2 = list( title =""), xaxis2 = list(title = paste0(gene, " mRNA expression (Z-score)")), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE,
         showlegend=TRUE, showlegend2=FALSE)
    
    return( p1_2 )
    
  } else {
   
    return( p1 )
  }
}

##### Fusion visualization
fusion_png <- function(geneA, geneB, pizzly_folder ) {

  ##### Get path to fusion visualization pdf file
  fusion_pdf <- paste(pizzly_folder, paste0(geneA, "_", geneB, ".pdf"), sep = "/")
  
  ##### Export pdf to png
  fusion_png <- paste(pizzly_folder, paste0(geneA, "_", geneB, ".png"), sep = "/")
  fusion <- image_read_pdf(fusion_pdf, pages = NULL, density = 300)
  image_write(fusion, path = fusion_png, format = "png")
  
  ##### Present the converted file in the report
  include_graphics(fusion_png)
}


##### Generate table with coloured cells indicating expression values for selected genes
exprTable <- function(genes, data, targets, sampleName, normal, cancer, genes_annot = NULL, cancer_genes_resources = NULL) {
  
  ##### Check how many of the selected genes are present in the expression data
  genes <- genes[ genes %in% rownames(data) ]
    
  targets.list <- unique(target$Target)
  
  ##### Initiate dataframe for expression median values in each group
  group.z <- as.data.frame(matrix(NA, ncol = length(targets.list), nrow = nrow(data)))
  colnames(group.z) <- targets.list
  rownames(group.z) <- sort(rownames(data))
  
  for ( group in targets.list ) {
  
    group.stats <- exprGroupStats(data[rownames(group.z), ], target, group)
    group.stats <- group.stats[order(rownames(group.stats)), ]
    group.z[, group] <- round(group.stats$z, digits=2)
  }
  
  ##### Compute Z-scores sd for each gene
  group.z <- cbind(group.z, round(rowSds(as.matrix(group.z)), digits = 2))
  names(group.z)[ncol(group.z)] <- "SD"
  
  ##### Calculate Z-score differneces between investigated sample and normal group median values
  group.z <- cbind(group.z, round((group.z[, sampleName] - group.z[, normal]), digits = 2))
  names(group.z)[ncol(group.z)] <- "Patient vs Normal"
  
  ##### Change sample ID to "Patient" and normal sample to "Normal" for better visualisation
  names(group.z)[names(group.z)==sampleName] <- "Patient"
  targets.list[targets.list==sampleName] <- "Patient"
  names(group.z)[names(group.z)==normal] <- "Normal"
  targets.list[targets.list==normal] <- "Normal"
  
  ##### Reorder groups
  group.z <- cbind(group.z[ , c("Normal", cancer, "Patient")], group.z[, c(4,5)])
    
  ##### Add genes annotation
  if ( !is.null(genes_annot) ) {
    
    ##### Merge the dataframe with groups median expression values and gene annotations
    group.z <- merge(genes_annot, group.z, by="row.names", all = FALSE, sort = FALSE)
    rownames(group.z) <- group.z$Row.names
    group.z <- group.z[, -1]
    
  } else {
    group.z <- cbind(rownames(group.z), group.z)
    names(group.z)[1] <- "Gene"
  }
  
  ##### Add cancer gene resources info
  if ( !is.null(cancer_genes_resources) ) {
    
    group.z <- merge(group.z, cancer_genes_resources, by="row.names", all = TRUE, sort = FALSE)
    rownames(group.z) <- group.z$Row.names
    group.z <- group.z[, -1]
    
    ##### Provide link to OncoKB for reported cancer genes
    for ( gene in genes) {
      
      if ( gene %in% rownames(cancer_genes_resources) ) {
        
        group.z$SYMBOL[ group.z$SYMBOL==gene] <- paste0("<a href='http://oncokb.org/#/gene/", gene, "' target='_blank'>", gene, "</a>")
      }
    }
  }
  
  ##### Order table by the highest absolute values for Patient vs Normal difference
  group.z <- group.z[ order(abs(group.z[, "Patient vs Normal"]),  decreasing = TRUE), ]
  
  ##### Define colours for cells background for each group and the patient vs normal difference
  ##### Initiate dataframe for expression median values in each group
  brks.q <- as.data.frame( matrix(NA, ncol = length(targets.list), nrow = length(seq(.05, .95, .0005)) ))
  colnames(brks.q) <- targets.list
  clrs.q <- as.data.frame( matrix(NA, ncol = length(targets.list), nrow = length(seq(.05, .95, .0005))+1 ))
  colnames(clrs.q) <- targets.list
  
  for ( group in c(targets.list, "Patient vs Normal") ) {

    brks.q[[group]] <- quantile(group.z[, group], probs = seq(.05, .95, .0005), na.rm = TRUE)
    #brks.q[[group]] <- sort(group.z[, group])
    
    clrs_pos.q <- round(seq(255, 150, length.out = length(brks.q[[group]])/2 + 1.5), 0) %>%
    {paste0("rgb(255,", ., ",", ., ")")}
    clrs_neg.q <- rev(round(seq(255, 150, length.out = length(brks.q[[group]])/2 - 0.5), 0)) %>%
    {paste0("rgb(", .,",", .,",", "255)")}
    
    clrs.q[[group]] <- c(clrs_neg.q, clrs_pos.q)
  }
  
  ##### Subset the expression data to include only the cancer genes
  group.z <- group.z[ rownames(group.z) %in% genes, ]
  
  ##### Generate a table with genes annotationa and coloured exprssion values in each group
  dt.table <- DT::datatable( data = group.z, filter="none", rownames = FALSE, options = list(pageLength = 10, scrollX = TRUE), width = 800, caption = htmltools::tags$caption(
          style = 'caption-side: top; text-align: left; color:grey; 
          font-size:100% ;', htmltools::strong("Standardised (Z-score) mRNA expression levels in individual groups.")),
  escape = FALSE) %>%
    DT::formatStyle( columns = names(group.z), `font-size` = '12px' ) %>%
    
    ##### Colour cells according to the expression values quantiles in each group
    DT::formatStyle(columns = targets.list[1], 
                    backgroundColor = DT::styleInterval(brks.q[[targets.list[1]]], clrs.q[[targets.list[1]]])) %>%
    DT::formatStyle(columns = targets.list[2], 
                    backgroundColor = DT::styleInterval(brks.q[[targets.list[2]]], clrs.q[[targets.list[2]]])) %>%
    DT::formatStyle(columns = targets.list[3], 
                    backgroundColor = DT::styleInterval(brks.q[[targets.list[3]]], clrs.q[[targets.list[3]]])) %>%
    DT::formatStyle(columns = "Patient vs Normal", 
                    backgroundColor = DT::styleInterval(brks.q[["Patient vs Normal"]], clrs.q[["Patient vs Normal"]]))
    
    group.z$SYMBOL <- rownames(group.z)
    
    return( list(dt.table,  group.z) )
}
```

```{r load_libraries, warning=FALSE}
##### Load libraries
suppressMessages(library(edgeR))
suppressMessages(library(preprocessCore))
suppressMessages(library(rapportools))
suppressMessages(library(plotly))
suppressMessages(library(edgeR))
suppressMessages(library(org.Hs.eg.db))
suppressMessages(library(kableExtra))
suppressMessages(library(tidyverse))
suppressMessages(library(knitr))
suppressMessages(library(magick))
suppressMessages(library(matrixStats))
```

```{r load_ref_data, message=FALSE, warning=FALSE}
##### Load reference datasets
##### Create a list with reference datasets
ref_datasets <- c(params$tissue)
ref_datasets.list <- vector("list", length(ref_datasets))
names(ref_datasets.list) <- ref_datasets

##### Create a list with various sets of genes
ref_genes <- c("genes_fusions","genes_pmcc", "oncokb_genes", "genes_immune")
ref_genes.list <- vector("list", length(ref_genes))
names(ref_genes.list) <- ref_genes

##### Create a list with cancer genes annotations
caner_genes_annot <- c("oncokb_clin_vars", "oncokb_all_vars")
caner_genes_annot.list <- vector("list", length(caner_genes_annot))
names(caner_genes_annot.list) <- caner_genes_annot
  
##### Read in reference datasets and merge them with sample data. This part outputs a vector with first element containing the merged data and second element containing merged targets info
ref_datasets.list[[params$tissue]] <- combineDatasets(params$sample_name, params$count_file, params$datasets)

##### Read in selected genes list
ref_genes.list[["genes_fusions"]] <- read.table(params$genes_fusions, sep="\t", as.is=TRUE, header=FALSE, row.names=NULL)
ref_genes.list[["genes_pmcc"]] <- read.table(params$genes_pmcc, sep="\t", as.is=TRUE, header=FALSE, row.names=NULL)
ref_genes.list[["oncokb_genes"]] <- read.table(params$oncokb_genes, sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, comment.char = "")
ref_genes.list[["genes_immune"]] <- read.table(params$genes_immune, sep="\t", as.is=TRUE, header=FALSE, row.names=NULL)

##### Read in OncoKB (http://oncokb.org) annotations
caner_genes_annot.list[["oncokb_clin_vars"]] <- read.table(params$oncokb_clin_vars, sep="\t", as.is=TRUE, header=TRUE, row.names=NULL)
caner_genes_annot.list[["oncokb_all_vars"]] <- read.table(params$oncokb_all_vars, sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, fill = TRUE)
```

```{r data_transformation, comment = NA, message=FALSE, warning=FALSE}
##### Data transformation and filtering
##### For differential expression and related analyses, gene expression is rarely considered at the level of raw counts since libraries sequenced at a greater depth will result in higher counts. Rather, it is common practice to transform raw counts onto a scale that accounts for such library size differences. Here we convert the read count data into log2-counts per million (***log-CPM***) using function from *[edgeR](https://bioconductor.org/packages/release/bioc/html/edgeR.html)* package. Genes with very low counts across all libraries provide little evidence for differential expression. In the biological point of view, a gene must be expressed at some minimal level before it is likely to be translated into a protein or to be biologically important. In addition, the pronounced discretenes of these counts interferes with some of the statistical approximations that are used later in the pipeline. These genes should be filtered out prior to further analysis.

##### Loop through combined datasets
for ( ref in names(ref_datasets.list) ) {
  
  counts <- ref_datasets.list[[ref]][[1]]
  target <- ref_datasets.list[[ref]][[2]]
  
  ##### Create EdgeR DGEList object
  y <- DGEList(counts=counts,  group=target$Target)
  
  ##### Add datasets name for each sample
  y$samples$dataset <- target$Dataset
  
  ##### Filtering to remove low expressed genes. Users should filter with CPM rather than filtering on the counts directly, as the latter does not account for differences in library sizes between samples. Here we keep only genes that have CPM of 1
  keep <- rowSums(cpm(y)>1) >= ncol(counts)/10
  y.filtered <- y[keep, , keep.lib.sizes=FALSE]
  
  ref_datasets.list[[ref]][[3]] <- y.filtered
}

# cat("The CPM of 1 (cut-off for removing low expressed genes) corresponds to", round(min(as.numeric(colSums(counts)*1e-6)), digits=0), "reads in sample with the lowest sequencing depth, and", round(max(as.numeric(colSums(counts)*1e-6)), digits=0), "reads in sample with the greatest sequencing depth\n")
```

```{r data_normalisation, comment = NA, message=FALSE, warning=FALSE}
##### Data normalisation
##### During the sample preparation or sequencing process, external factors that are not of biological interest can affect the expression of individual samples. For example, samples processed in the first batch of an experiment can have higher expression overall when compared to samples processed in a second batch. It is assumed that all samples should have a similar range and distribution of expression values. Normalisation for sample-specific effectss is required to ensure that the expression distributions of each sample are similar across the entire experiment. Normalisation by the method of *[trimmed mean of M-values](https://www.ncbi.nlm.nih.gov/pubmed/20196867) (TMM)* is performed using the *calcNormFactors* function in *[edgeR](https://bioconductor.org/packages/release/bioc/html/edgeR.html)*. The normalisation factors calculated here are used as a scaling factor for the library sizes. TMM is the recommended for most RNA-Seq data where the majority (more than half) of the genes are believed not differentially expressed between any pair of the samples.

##### Adjust for RNA composition effect. Calculate scaling factors for the library sizes with calcNormFactors function using trimmed mean of M-values (TMM) between each pair of samples. Note, that the raw read counts are used to calculate the normalisation factors

##### Loop through combined datasets
for ( ref in names(ref_datasets.list) ) {
  
  y.filtered <- ref_datasets.list[[ref]][[3]]
  
  y.filtered.norm <- calcNormFactors(y.filtered, method = "TMM")
  
  ##### Transformations from the raw-scale to CPM
  y.filtered.norm.cpm <- cpm(y.filtered.norm, normalized.lib.sizes=TRUE, log=TRUE, prior.count=0.25)
  
  ref_datasets.list[[ref]][[3]] <- y.filtered.norm.cpm
}
```

```{r pca, comment = NA, message=FALSE, warning=FALSE}
##### Principal component analysis (PCA)
##### Loop through combined datasets and perform PCA
for ( ref in names(ref_datasets.list) ) {
  
  target <- ref_datasets.list[[ref]][[2]]
  data <- ref_datasets.list[[ref]][[3]]
  
  ref_datasets.list[[ref]][[4]] <- pca(data, target)
}
```

```{r gene_annot, comment = NA, message=FALSE, warning=FALSE}
##### Loop through combined datasets and annotate genes
for ( ref in names(ref_datasets.list) ) {
  
  ##### Convert data into a data frame to make the Ensembl ID and gene symbol matches (with merge function)
  data <- ref_datasets.list[[ref]][[3]]
  data.df <- as.data.frame(cbind(rownames(data), data))
  colnames(data.df)[1] <- "ENSEMBL"
  
  ##### Extract the gene annotation information
  gene_info <-  AnnotationDbi::select(org.Hs.eg.db, rownames(data), c("SYMBOL", "GENENAME", "ENSEMBL", "ENTREZID"), "ENSEMBL")
  
  ##### Merge the gene annotation with expression data
  data.annot <- merge(gene_info, data.df, by = "ENSEMBL", all.x = TRUE)
  
  ##### Keep only genes fo which gene symbol is available
  data.annot <- data.annot[!(is.na(data.annot$SYMBOL) | data.annot$SYMBOL==""), ]
  
  ##### Remove rows with duplicated gene symbols
  data.annot = data.annot[!duplicated(data.annot$SYMBOL),]
  rownames(data.annot) <- data.annot$SYMBOL
  
  ##### Get data matrix with gene symbols
  #data <- data.annot[, colnames(data)]
  #data <- apply(data.annot[, colnames(data)], 2, as.numeric)
  #rownames(data) <- data.annot$SYMBOL
  ref_datasets.list[[ref]][[3]] <- apply(data.annot[, colnames(data)], 2, as.numeric)
  rownames(ref_datasets.list[[ref]][[3]]) <- data.annot$SYMBOL
  ref_datasets.list[[ref]][[5]] <- data.annot[, c("SYMBOL", "GENENAME", "ENSEMBL", "ENTREZID")]
}
```

```{r cancer_genes_prep, comment = NA, message=FALSE, warning=FALSE}
##### Combine PMCC gene panel and OncoKB cancer genes
cancer_genes <- ref_genes.list[["oncokb_genes"]]
cancer_genes$PMCC <- rep("No", nrow(cancer_genes))

for ( gene in unlist(ref_genes.list[["genes_pmcc"]]) ) {

  ##### Check if the PMCC genes is aleady reported in OncoKB
  if ( gene %in% cancer_genes$Hugo.Symbol ) {
   
    cancer_genes[ cancer_genes$Hugo.Symbol==gene, ]$PMCC <- "Yes"
    
  ##### Add if not present
  } else {
    
    cancer_genes <- rbind(cancer_genes, c(gene, 1, "No", rep("", 8), "Yes"))
  }
}

rownames(cancer_genes) <- cancer_genes$Hugo.Symbol
names(cancer_genes) <- c("Gene", "No. of resources", "OncoKB", "Oncogene", "TSG", "MSK-IMPACT", "MSK-HEME", "Foundation One", "Foundation One Heme", "Vogelstein", "Sanger CGC", "PMCC")
cancer_genes <- cancer_genes[,c("Oncogene", "TSG", "No. of resources", "OncoKB", "MSK-IMPACT", "MSK-HEME", "Foundation One", "Foundation One Heme", "Vogelstein", "Sanger CGC", "PMCC")]
cancer_genes[ cancer_genes=="No" ] <- "-"
cancer_genes[ cancer_genes=="" ] <- "-"

ref_genes.list[["cancer_genes"]] <- cancer_genes
```

```{r ref_cohorts_summary, comment = NA, message=FALSE, warning=FALSE}
##### Summarise the reference cohorts samples
ref <- params$tissue
target <- ref_datasets.list[[ref]][[2]]

ref_normal <- table(target$Target)[names(table(target$Target))==params$normal_group]
ref_cancer <- table(target$Target)[names(table(target$Target))==params$cancer_group]
```

***

### Input data summary

The following reference patient cohorts were used for the analysis:

* **`r paste (ref_normal, params$normal_group, sep=" ")`** samples
* **`r paste (ref_cancer, params$cancer_group, sep=" ")`** samples

From the `r nrow(counts)` input genes:

* `r nrow(counts) - nrow(y.filtered$counts)` genes were filtered out due to low expression
* `r nrow(y.filtered$counts) - nrow(data.annot)` genes were ignored due to lack of [HGNC](https://www.genenames.org/)-apporved gene symbol
* **`r nrow(data.annot)` genes** remained for the analysis

***

## Key findings

Section summarising the key findings (clincially relevant deregulated genes and pathways, gene fusion events etc.)

TO BE ADDED...

***

## Cancer genes

mRNA expression levels of cancer genes in patient's sample and their average mRNA expression in samples from cancer patients and healthy individuals. These include *[Peter Mac](https://www.petermac.org/) comprehensive cancer (PMCC)* panel genes and genes considered to be cancer genes (listed [here](http://oncokb.org/#/cancerGenes)) by *[OncoKB](http://oncokb.org/#/about)* based on their inclusion in the following sequencing panels: *[MSK-IMPACT](https://www.mskcc.org/msk-impact)*, *[MSK-HEME](http://www.islh.org/Presentation_Upload/presentation_uploads/12_52_0900-Zehir.pdf)*, *[Foundation One](https://www.foundationmedicine.com/genomic-testing/foundation-one-cdx)*, *[Foundation One Heme](https://www.foundationmedicine.com/genomic-testing/foundation-one-heme)*, *[Vogelstein](http://science.sciencemag.org/content/339/6127/1546.full)* and *[Sanger Cancer Gene Census](https://www.sanger.ac.uk/science/data/cancer-gene-census)* (CGC).

### Cancer genes expression summary

From the `r nrow(ref_genes.list[["cancer_genes"]])` cancer genes the expression of **`r length(which(rownames(ref_genes.list[["cancer_genes"]]) %in% rownames(ref_datasets.list[[ref]][[3]])))`** was reliably measured in the patient's sample.

```{r cancer_genes_table, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for cancer genes from OncoKB and PMCC
ref <- params$tissue
target <- ref_datasets.list[[ref]][[2]]
data <- ref_datasets.list[[ref]][[3]]

cancer_genes.expr <- exprTable(rownames(ref_genes.list[["cancer_genes"]]), data, target, params$sample_name, params$normal_group , params$cancer_group, ref_datasets.list[[ref]][[5]][, c(1,3)], ref_genes.list[["cancer_genes"]])

##### Present the expression summary table
cancer_genes.expr[[1]]
```

***

### Cancer genes expression profiles {.tabset}

NOTE: currently, displaying the top 6 cancer genes with the greatest difference in standarised (Z-score) mRNA expression values between patient's sample and the average mRNA expression in samples from normal individuals.

#### `r cancer_genes.expr[[2]]$SYMBOL[1]`

```{r cdf_plot_cancer_genes_1, comment = NA, message=FALSE, warning=FALSE, fig.width = 7, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
ref <- params$tissue
target <- ref_datasets.list[[ref]][[2]]
data <- ref_datasets.list[[ref]][[3]]
targets.colour <- ref_datasets.list[[ref]][[4]]$targets
datasets.colour <- ref_datasets.list[[ref]][[4]]$datasets
gene <- cancer_genes.expr[[2]]$SYMBOL[1]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
cdfPlot(gene, data, target, params$sample_name, params$normal_group, params$cancer_group, addBoxPlot = TRUE)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

#### `r cancer_genes.expr[[2]]$SYMBOL[2]`

```{r cdf_plot_cancer_genes_2, comment = NA, message=FALSE, warning=FALSE, fig.width = 7, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
ref <- params$tissue
target <- ref_datasets.list[[ref]][[2]]
data <- ref_datasets.list[[ref]][[3]]
targets.colour <- ref_datasets.list[[ref]][[4]]$targets
datasets.colour <- ref_datasets.list[[ref]][[4]]$datasets
gene <- cancer_genes.expr[[2]]$SYMBOL[2]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
cdfPlot(gene, data, target, params$sample_name, params$normal_group, params$cancer_group, addBoxPlot = TRUE)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

#### `r cancer_genes.expr[[2]]$SYMBOL[3]`

```{r cdf_plot_cancer_genes_3, comment = NA, message=FALSE, warning=FALSE, fig.width = 7, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
ref <- params$tissue
target <- ref_datasets.list[[ref]][[2]]
data <- ref_datasets.list[[ref]][[3]]
targets.colour <- ref_datasets.list[[ref]][[4]]$targets
datasets.colour <- ref_datasets.list[[ref]][[4]]$datasets
gene <- cancer_genes.expr[[2]]$SYMBOL[3]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
cdfPlot(gene, data, target, params$sample_name, params$normal_group, params$cancer_group, addBoxPlot = TRUE)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

#### `r cancer_genes.expr[[2]]$SYMBOL[4]`

```{r cdf_plot_cancer_genes_4, comment = NA, message=FALSE, warning=FALSE, fig.width = 7, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
ref <- params$tissue
target <- ref_datasets.list[[ref]][[2]]
data <- ref_datasets.list[[ref]][[3]]
targets.colour <- ref_datasets.list[[ref]][[4]]$targets
datasets.colour <- ref_datasets.list[[ref]][[4]]$datasets
gene <- cancer_genes.expr[[2]]$SYMBOL[4]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
cdfPlot(gene, data, target, params$sample_name, params$normal_group, params$cancer_group, addBoxPlot = TRUE)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

#### `r cancer_genes.expr[[2]]$SYMBOL[5]`

```{r cdf_plot_cancer_genes_5, comment = NA, message=FALSE, warning=FALSE, fig.width = 7, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
ref <- params$tissue
target <- ref_datasets.list[[ref]][[2]]
data <- ref_datasets.list[[ref]][[3]]
targets.colour <- ref_datasets.list[[ref]][[4]]$targets
datasets.colour <- ref_datasets.list[[ref]][[4]]$datasets
gene <- cancer_genes.expr[[2]]$SYMBOL[5]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
cdfPlot(gene, data, target, params$sample_name, params$normal_group, params$cancer_group, addBoxPlot = TRUE)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

#### `r cancer_genes.expr[[2]]$SYMBOL[6]`

```{r cdf_plot_cancer_genes_6, comment = NA, message=FALSE, warning=FALSE, fig.width = 7, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
ref <- params$tissue
target <- ref_datasets.list[[ref]][[2]]
data <- ref_datasets.list[[ref]][[3]]
targets.colour <- ref_datasets.list[[ref]][[4]]$targets
datasets.colour <- ref_datasets.list[[ref]][[4]]$datasets
gene <- cancer_genes.expr[[2]]$SYMBOL[6]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
cdfPlot(gene, data, target, params$sample_name, params$normal_group, params$cancer_group, addBoxPlot = TRUE)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

## Gene fusion events

### Fusion events prioritisation

The prioritization of pizzly results is performed in two steps.

1. In the first step, basic idea is to run kallisto to quantify the fusion transcripts (reported by pizzly) and 
select those which have a decent TPM support.
  * Create a new index based on the transcriptome and the fusion transcripts identified by pizzly.
  * Run kallisto in normal quantification mode on the expanded index to quantify both normal transcripts 
  and fusions.
  * Select only the fusions with a high TPM value as reported by previous step.

2. In the second step, fusion genes reported by pizzly are compared with cancer gene list (from Peter Mac comprehensive cancer (PMCC) panel and [OncoKB](http://oncokb.org/#/cancerGenes)) and report 
the ones that are present in this list.

```{r pizzly_filtering, comment = NA, message=FALSE, warning=FALSE}
#read in the pizzly fusion calls
pizzly.fusions <- read.table(file = paste(params$pizzly_folder, "pizzly-flat-filtered.tsv", sep = "/"), header = TRUE)
quant <- read.table(file = paste(params$pizzly_folder, "abundance.tsv", sep = "/"), header = TRUE)
#sort and filter quantification file on tpm values. First, grep only the transcript ids for fusion genes from quantification #file. Currently filtering on quantiles. Selected 0.997 because that reduces the #final fusion calls to the value we are #interested in (~15)
quant.fusions.only.transcripts <- quant[grep(":", quant$target_id), ]
quant.sorted.filtered <- filter(arrange(quant.fusions.only.transcripts, desc(quant.fusions.only.transcripts$tpm)), tpm >= (quantile(quant.fusions.only.transcripts$tpm, 0.999)))

#initialize an empty dataframe
result <- data.frame()

#let's try using for loop for iterating over pizzly.fusions dataframe and get transcriptID and fusion gene pair information.
#can also filter quant.sorted.filtered$target_id to have only fusion gene target ids (that is two tracscripts instead of one-
#this will increase speed

for (row in 1:nrow(pizzly.fusions)){
  y <- strsplit(as.character(pizzly.fusions[row, 7]), "\\;")
  y <- unname(y)
  for (i in 1:length(y[[1]])){
    if (y[[1]][i] %in% quant.sorted.filtered$target_id){
      #creating a new dataframe for the filtered pizzly results
      result <- rbind(result, data.frame(pizzly.fusions[row,]))
    }
  }
}

#remove duplicated values from result filtered using expression count(as multiple transcripts might support fusion between same gene)
deduped.result <- unique(result)

#Extract only those fusion genes that are in PMCC list
result.cancer_genes <- data.frame()
for (row in 1:nrow(pizzly.fusions)){
  if(pizzly.fusions[row,1] %in% rownames(ref_genes.list[["cancer_genes"]]) | pizzly.fusions[row,3] %in% rownames(ref_genes.list[["cancer_genes"]])) {
    #creating a new dataframe for extracting pizzly rows with pmcc gene hits
    result.cancer_genes <- rbind(result.cancer_genes, data.frame(pizzly.fusions[row,]))
  }
}

#sorting pizzly.fusions according to two new target dataframes identified i.e. 1- pizzly result filtering using expressions counts and 2- cancer genes list

pizzly.fusions$order <- rownames(pizzly.fusions) %in% rownames(deduped.result) 
pizzly.fusions$order2 <- rownames(pizzly.fusions) %in% rownames(result.cancer_genes)

pizzly.fusions2 <- arrange(pizzly.fusions, -order, -order2) %>%
  select(-order,-order2)

kable(pizzly.fusions2) %>%
  kable_styling(font_size = 12, "striped", "bordered") %>%
  #row_spec(c(as.numeric(rownames(deduped.result)),as.numeric(rownames(result.cancer_genes))), bold = T, color = "white", background = "#D7261E") %>%
  #row_spec(1:nrow(deduped.result), bold = T, color = "white", background = "red") %>%
  #row_spec((nrow(deduped.result)+1):(nrow(deduped.result) + nrow(result.cancer_genes)), color = "white", background = "blue") %>%
  group_rows("Filtered results using expression count matrix", 1, nrow(deduped.result), label_row_css = "background-color: #E74C3C; color: #fff;") %>%
  group_rows("Filtered results using cancer genes list", (nrow(deduped.result)+1), (nrow(deduped.result) + nrow(result.cancer_genes)), label_row_css = "background-color: #2980B9; color: #fff;") %>%
  group_rows("Other pizzly results", (nrow(deduped.result) + nrow(result.cancer_genes) +1), nrow(pizzly.fusions2), label_row_css = "background-color: #27AE60; color: #fff;") %>%
  scroll_box(width = "100%", height = "400px")
```

```{r fusions_reads, comment = NA, message=TRUE, warning=FALSE}
##### Get the number of reads supporting fusions of interest
result_reads <- data.frame()
for (row in 1:nrow(deduped.result)){
  y <- strsplit(as.character(deduped.result[row, 7]), "\\;")
  y <- unname(y)
  for (i in 1:length(y[[1]])){
    if (y[[1]][i] %in% quant.sorted.filtered$target_id){
      #creating a new dataframe for the reads supporting individual transcript ID for each filtered fusion gene pair 
      result_reads_inter <- data.frame(deduped.result[row,1:6])
      result_reads_inter$transcriptID = y[[1]][i]
      tpm = quant.sorted.filtered[grep(y[[1]][i], quant.sorted.filtered$target_id), ]$tpm 
      result_reads_inter$tpm = tpm
      result_reads <- rbind(result_reads, result_reads_inter)
    }
  }
}
```

***

### Fusion genes expression profiles {.tabset}

NOTE: currently, displaying the top 3 hits from pizzly filtering output (red section in above table).

#### `r paste(pizzly.fusions2$geneA.name[2], pizzly.fusions2$geneB.name[2], sep="-")`

##### Fusion events visualization

```{r fusions_figs1, comment = NA, message=TRUE, warning=FALSE}
##### Convert the fusion image from pdf to png and present it in the report
geneA <- pizzly.fusions2$geneA.name[2]
geneB <- pizzly.fusions2$geneB.name[2]

fusion_png(geneA, geneB, params$pizzly_folder )
```

```{r fusions_tables1, comment = NA, message=TRUE, warning=FALSE}
##### Present a table with number of reads supporting this fusion
fusion_result_reads <- result_reads[ result_reads$geneA.name == geneA & result_reads$geneB.name == geneB, ]
kable(fusion_result_reads, row.names = FALSE, caption = paste0("Number of reads supporting ", paste(geneA, geneB, sep="-"), " fusion")) %>%
  kable_styling(font_size = 12, "striped", "bordered") %>%
  scroll_box(width = "100%")
```

***

##### Fusion genes expression

mRNA expression levels of fusion genes detected in patient's sample and their average mRNA expression in samples from cancer patients and healthy individuals.

```{r cdf_plot_fusions_1, comment = NA, message=FALSE, warning=FALSE, fig.width = 7, fig.height = 2.5}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
ref <- params$tissue
target <- ref_datasets.list[[ref]][[2]]
data <- ref_datasets.list[[ref]][[3]]
targets.colour <- ref_datasets.list[[ref]][[4]]$targets
datasets.colour <- ref_datasets.list[[ref]][[4]]$datasets
geneA <- pizzly.fusions2$geneA.name[2]
geneB <- pizzly.fusions2$geneB.name[2]

cdfPlot(geneA, data, target, params$sample_name, params$normal_group, params$cancer_group)
cdfPlot(geneB, data, target, params$sample_name, params$normal_group, params$cancer_group)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

```{r gene_table_fusions_1, comment = NA, message=FALSE, warning=FALSE}
fusion.df <- ref_datasets.list[[ref]][[5]]
fusion.df <- rbind(fusion.df[fusion.df$SYMBOL==geneA, ], fusion.df[fusion.df$SYMBOL==geneB, ])
exprTable(fusion.df$SYMBOL, data, target, params$sample_name, params$normal_group, params$cancer_group, ref_datasets.list[[ref]][[5]][, c(1,3)], ref_genes.list[["cancer_genes"]][,c(1:2)])[[1]]
```

#### `r paste(pizzly.fusions2$geneA.name[3], pizzly.fusions2$geneB.name[3], sep="-")`

##### Fusion events visualization

```{r fusions_figs2, comment = NA, message=TRUE, warning=FALSE}
##### Convert the fusion image from pdf to png and present it in the report
geneA <- pizzly.fusions2$geneA.name[3]
geneB <- pizzly.fusions2$geneB.name[3]

fusion_png(geneA, geneB, params$pizzly_folder )
```

```{r fusions_tables2, comment = NA, message=TRUE, warning=FALSE}
##### Present a table with number of reads supporting this fusion
fusion_result_reads <- result_reads[ result_reads$geneA.name == geneA & result_reads$geneB.name == geneB, ]
kable(fusion_result_reads, row.names = FALSE, caption = paste0("Number of reads supporting ", paste(geneA, geneB, sep="-"), " fusion")) %>%
  kable_styling(font_size = 12, "striped", "bordered") %>%
  scroll_box(width = "100%")
```

***

##### Fusion genes expression

mRNA expression levels of fusion genes detected in patient's sample and their average mRNA expression in samples from cancer patients and healthy individuals.

```{r cdf_plot_fusions_2, comment = NA, message=FALSE, warning=FALSE, fig.width = 7, fig.height = 2.5}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
ref <- params$tissue
target <- ref_datasets.list[[ref]][[2]]
data <- ref_datasets.list[[ref]][[3]]
targets.colour <- ref_datasets.list[[ref]][[4]]$targets
datasets.colour <- ref_datasets.list[[ref]][[4]]$datasets
geneA <- pizzly.fusions2$geneA.name[3]
geneB <- pizzly.fusions2$geneB.name[3]

cdfPlot(geneA, data, target, params$sample_name, params$normal_group, params$cancer_group)
cdfPlot(geneB, data, target, params$sample_name, params$normal_group, params$cancer_group)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

```{r gene_table_fusions_2, comment = NA, message=FALSE, warning=FALSE}
fusion.df <- ref_datasets.list[[ref]][[5]]
fusion.df <- rbind(fusion.df[fusion.df$SYMBOL==geneA, ], fusion.df[fusion.df$SYMBOL==geneB, ])
exprTable(fusion.df$SYMBOL, data, target, params$sample_name, params$normal_group, params$cancer_group, ref_datasets.list[[ref]][[5]][, c(1,3)], ref_genes.list[["cancer_genes"]][,c(1:2)])[[1]]
```

#### `r paste(pizzly.fusions2$geneA.name[4], pizzly.fusions2$geneB.name[4], sep="-")`

##### Fusion events visualization

```{r fusions_figs3, comment = NA, message=TRUE, warning=FALSE}
##### Convert the fusion image from pdf to png and present it in the report
geneA <- pizzly.fusions2$geneA.name[4]
geneB <- pizzly.fusions2$geneB.name[4]

fusion_png(pizzly.fusions2$geneA.name[4], pizzly.fusions2$geneB.name[4], params$pizzly_folder )
```

```{r fusions_tables3, comment = NA, message=TRUE, warning=FALSE}
##### Present a table with number of reads supporting this fusion
fusion_result_reads <- result_reads[ result_reads$geneA.name == geneA & result_reads$geneB.name == geneB, ]
kable(fusion_result_reads, row.names = FALSE, caption = paste0("Number of reads supporting ", paste(geneA, geneB, sep="-"), " fusion")) %>%
  kable_styling(font_size = 12, "striped", "bordered") %>%
  scroll_box(width = "100%")
```

***

##### Fusion genes expression

mRNA expression levels of fusion genes detected in patient's sample and their average mRNA expression in samples from cancer patients and healthy individuals.

```{r cdf_plot_fusions_3, comment = NA, message=FALSE, warning=FALSE, fig.width = 7, fig.height = 2.5}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
ref <- params$tissue
target <- ref_datasets.list[[ref]][[2]]
data <- ref_datasets.list[[ref]][[3]]
targets.colour <- ref_datasets.list[[ref]][[4]]$targets
datasets.colour <- ref_datasets.list[[ref]][[4]]$datasets
geneA <- pizzly.fusions2$geneA.name[4]
geneB <- pizzly.fusions2$geneB.name[4]

cdfPlot(geneA, data, target, params$sample_name, params$normal_group, params$cancer_group)
cdfPlot(geneB, data, target, params$sample_name, params$normal_group, params$cancer_group)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

```{r gene_table_fusions_3, comment = NA, message=FALSE, warning=FALSE}
fusion.df <- ref_datasets.list[[ref]][[5]]
fusion.df <- rbind(fusion.df[fusion.df$SYMBOL==geneA, ], fusion.df[fusion.df$SYMBOL==geneB, ])
exprTable(fusion.df$SYMBOL, data, target, params$sample_name, params$normal_group, params$cancer_group, ref_datasets.list[[ref]][[5]][, c(1,3)], ref_genes.list[["cancer_genes"]][,c(1:2)])[[1]]
```

***

## Immune Response Markers

Section presenting expression levels for immune response markers to assess pre-existing anti-cancer immunity and likelihood of response to immunotherapy (similar to [this report](https://trello-attachments.s3.amazonaws.com/5753fc730bff8d2b24f159df/59912803fd0e33e3395d05e7/dc9a81ae11a9d1825ab0028d01dc8c53/Advance-sample-report-card-final.pdf))

```{r immune_genes_table, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for cancer genes from OncoKB and PMCC
ref <- params$tissue
target <- ref_datasets.list[[ref]][[2]]
data <- ref_datasets.list[[ref]][[3]]

immune_genes.expr <- exprTable(unlist(ref_genes.list[["genes_immune"]]), data, target, params$sample_name, params$normal_group , params$cancer_group, ref_datasets.list[[ref]][[5]][, c(1,3)])

##### Present the expression summary table
immune_genes.expr[[1]]
```

WORK IN PROGRESS...

***

## Drug matching

Section reporting drugs that target deregulated genes, fusion events (deregulated pathways to be added) based on data from:

* *[CIViC](https://civicdb.org/home)* ([Griffith *et al.* (2017)](https://www.ncbi.nlm.nih.gov/pubmed/28138153))
* *[OncoKB](http://oncokb.org/#/about)* (data availabe [here](https://github.com/oncokb/oncokb-public/tree/master/data))
* *[DrugBank](https://www.drugbank.ca/)*
* *[KEGG Drug](https://www.genome.jp/kegg/drug/)*

TO BE ADDED...

***

## References

TO BE ADDED...

***

## Parameters

```{r params_info, comment = NA}
for ( i in 1:length(params) ) {

  cat(paste("Parameter: ", names(params)[i], "\nValue: ", paste(unlist(params[i]), collapse = ","), "\n\n", sep=""))
}
```

***

## Addendum

```{r sessioninfo, comment = NA}
devtools::session_info()
```

