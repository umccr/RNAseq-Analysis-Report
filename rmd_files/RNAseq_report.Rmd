---
title: 'UMCCR Transcriptome Patient Summary'
author: 'UMCCR'
date: '`r Sys.Date()`'
output:
  html_document:
    keep_md: yes
    code_download: true
    code_folding: hide
    theme: readable
    css: RNAseq_report.css
    toc: true
    toc_float: true
  rmdformats::material:
    highlight: kate
params:
  sample_name: 
  dataset: 
  count_file: 
  report_dir: 
  transform: 
  filter: 
  norm: 
  log: 
  scaling: 
  umccrise: 
  clinical_info: 
  subject_id: 
  plots_mode: 
  hide_code_btn: 
  pcgr_tier: 
  cn_loss: 
  cn_gain: 
  grch_version: 
  ensembl_version: 
  ucsc_genome_assembly:  
  ref_data_dir: '../data'
  annot_file: '../data/genes/tx2gene.ensembl.v95.csv'
  genes_cancer: 'genes/umccr_cancer_genes.20190122.tsv'
  genes_immune: 'genes/Genes_immune.txt'
  genes_hrd: 'genes/Genes_HRD.txt'
  oncokb_genes: 'OncoKB/CancerGenesList.txt'
  oncokb_clin_vars: 'OncoKB/allActionableVariants.txt'
  oncokb_all_vars: 'OncoKB/allAnnotatedVariants.txt'
  civic_var_summaries: 'CIViC/01-Oct-2018-VariantSummaries.tsv'
  civic_clin_evid: 'CIViC/01-Oct-2018-ClinicalEvidenceSummaries.tsv'
  cancer_biomarkers_trans: 'cancer_biomarkers_database/cancer_genes_upon_trans.tsv'
  FusionGDB: 'FusionGDB/TCGA_ChiTaRS_combined_fusion_ORF_analyzed_gencode_h19v19_fgID.txt'
---

RNA-seq report for patient sample **`r params$sample_name`**.

```{r script_description, eval=FALSE}
##### We attempt to structure the script in the following way:

# 1. Defining functions
# 2. Loading libraries
# 3. Loading sample data and reference datasets
# Then... code chunks involving data processing
# Then... code chunks calling the processed data to produce tables / plots / data summary
# Finish with Session info in Addendum section

##### The processed data is stored in "ref_datasets.list" list variable with elements holding the following data:

# 1. ref_datasets.list[[dataset]][["combined_data"]] = combined read count data (reference datasets + sample data) ("combineDatasets" function output in the "load_ref_data chunk")

# 2. ref_datasets.list[[dataset]][["sample_annot"]] = combined data samples annotation ("combineDatasets" function output in the "load_ref_data chunk")

# 3. ref_datasets.list[[dataset]][["clinical_info"]] = clinical information (survival and treatment info)

# 4. ref_datasets.list[[dataset]][["combined_data_processed"]] = transformed, filtered and normalised data (see "data_transformation" and "data_normalisation" chunks)

# 5. ref_datasets.list[[dataset]][["batch_effect_corrected"]] = transformed, filtered, normalised and batch effect corrected data (see "batch_effect_correction" chunk)

# 6. ref_datasets.list[[dataset]][["pca_combined_data_processed"]] = PCA results for combined data

# 7. ref_datasets.list[[dataset]][["pca_batch_effect_corrected"]] = PCA results for batch-effect corrected data

# 8. ref_datasets.list[[dataset]][["gene_annot_all"]] = gene annotation for combined read count data, containing all input genes. The annotation includes "SYMBOL", "GENEBIOTYPE", "ENSEMBL", "SEQNAME", "GENESEQSTART", "GENESEQEND". "ENSEMBL" is used for rownames

# 9. ref_datasets.list[[dataset]][["gene_annot"]] = gene annotation for transformed, filtered and normalised data. The annotation includes "SYMBOL", "GENEBIOTYPE", "ENSEMBL", "SEQNAME", "GENESEQSTART", "GENESEQEND". "SYMBOL" is used for rownames

# 10. ref_datasets.list[[dataset]][["expr_mut_cn_data"]] = combined expression, mutation and copy-number data


##### Genes of interest are stored in "ref_genes.list" list variable with elements holding the following gene sets:

# 1. ref_genes.list[["genes_cancer"]] = list of cancer genes derived from UMCCR Cancer Gene list and OncoKB portal (http://oncokb.org/#/cancerGenes) 

# 2. ref_genes.list[["genes_oncokb"]] = list of cancer genes derived from OncoKB portal (http://oncokb.org/#/cancerGenes) alone (although genes present on the UMCCR panel are also flagged)

# 3. ref_genes.list[["genes_immune"]] = list of immune reponse markers provided in OmniSeq report (https://www.omniseq.com/)

# 4. ref_genes.list[["genes_hrd"]] = list of hrd (homologous recombination deficiency) genes - provided by Richard

# 5. ref_genes.list[["pcgr"]] = list and PCGR annotation of mutated genes in given patient based on PCGR report

# 6. ref_genes.list[["purple"]] = list and PURPLE annotation of copy-number (CN) altered genes in given patient based on PURPLE results

# 7. ref_genes.list[["manta"]] = list and MANTA annotation of structural variants (SVs) with affected genes in given patient based on MANTA results

# 8. ref_genes.list[["pizzly"]] = list and PIZZLY annotation of gene fusion events detected in given patient based on PIZZLY results

# 9. ref_genes.list[["kallisto"]] = genes quantification file from KALLISTO. This is required for gene fusion events filtering

# 10. ref_genes.list[["pizzly_manta"]] = list and annotation of gene fusion events detected in given patient based on both PIZZLY and MANTA results
```

```{r code_display, echo = FALSE}
##### Include or exclude the "Code" buttom allowing to "show"/"hide" code chunks from the report 
if ( params$hide_code_btn ) {
  
  writeLines(".btn { display: none ;", con = "RNAseq_report.css")
} else {
  writeLines(" ", con = "RNAseq_report.css")
}
```
  
```{r chunks_timing, comment=NA, message=FALSE, warning=FALSE}
NOW <- Sys.time()

##### Time chunks during knitting
knitr::knit_hooks$set(timeit = function(before) {
  
  if (before) {
    print(paste("Start:", Sys.time()))
    NOW <<- Sys.time()
    
  } else {
    print(paste("Stop:", Sys.time()))
    print(Sys.time() - NOW)
  }
})

knitr::opts_chunk$set(
  timeit = TRUE
)
```

```{r define_functions, comment=NA, message=FALSE, warning=FALSE}
##### Define functions
##### Create 'not in' operator
"%!in%" <- function(x,table) match(x,table, nomatch = 0) == 0

##### Prepare object to write into a file
prepare2write <- function (x) {
  
  x2write <- cbind(rownames(x), x)
  colnames(x2write) <- c("",colnames(x))
  return(x2write)
}

##### Combine sample expression profile with reference datasets. This function outputs a vector with first element containing the merged data and second element containing merged targets info
combineDatasets <- function(sample_name, sample_counts, ref_dataset) {
  
  ##### Read file with reference datasets information
  DatasetInput <- read.table(ref_dataset, sep="\t", as.is=TRUE, header=TRUE, row.names=1)
  
  ##### Extract info about target file for the first dataset
  fileInfo <- strsplit(DatasetInput[,"Target_file"], split='/', fixed=TRUE)
  targetFile <- read.table(DatasetInput[1,"Target_file"], sep="\t", as.is=TRUE, header=TRUE)[,c(1:4)]
  targetFile <- cbind(targetFile[,1:4],rownames(DatasetInput[1,]))
  colnames(targetFile)[ncol(targetFile)] <- "Dataset"
  
  ##### Add prexit to sample names
  rownames(targetFile) <- paste(targetFile[,"Dataset"], targetFile[,"Sample_name"], sep = ".")
  targetFile <- targetFile[, -1]
  
  if ( nrow(DatasetInput) > 1 ) {
    for ( i in 2:nrow(DatasetInput) ) {
        
      ##### Create a temporary object to store info from the remaining target files
      targetFileTmp <- read.table(DatasetInput[i,"Target_file"], sep="\t", as.is=TRUE, header=TRUE)[,c(1:4)]
      targetFileTmp <- cbind(targetFileTmp[,1:4],rownames(DatasetInput[i,]))
      colnames(targetFileTmp)[ncol(targetFileTmp)] <- "Dataset"
      
      ##### Add prexit to sample names
      rownames(targetFileTmp) <- paste(targetFileTmp[,"Dataset"], targetFileTmp[,"Sample_name"], sep = ".")
      targetFileTmp <- targetFileTmp[, -1]
        
      targetFile <- rbind(targetFile, targetFileTmp)
    }
  }  
  
  ##### Add sample info
  sampleTargetFile <- data.frame("Patient", sample_name, NA, sample_name)
  names(sampleTargetFile) <- names(targetFile)
  rownames(sampleTargetFile) <- sample_name
  targetFile <- rbind( targetFile, sampleTargetFile )
  
  ##### Make syntactically valid names
  rownames(targetFile) <- make.names(rownames(targetFile))
  
  ##### Read sample read count file and combine it with reference datasets
  datasets.comb <- sample_counts
  names(datasets.comb) <- c("", sample_name)
      
  ##### list genes present in the read count file
  gene_list <- as.vector(datasets.comb[,1])
      
  ##### Loop through the expression data from different datasets and merge them into one matrix
  for ( i in 1:length(DatasetInput[ , "Expression_matrix" ]) ) {
    
    data_matrix <- DatasetInput[ , "Expression_matrix" ][i]
    
    ##### Add data from the reference datasets
    dataset <- as.data.frame( read.table(data_matrix, header=TRUE, sep="\t", row.names=NULL) )
    
    ##### Add prexit to sample names
    colnames(dataset) <- paste(levels(targetFile[,"Dataset"])[i], colnames(dataset), sep = ".")
    
    ##### list genes present in individal files
    gene_list <- c( gene_list, as.vector(dataset[,1]) )
    
    ##### Merge the expression datasets and make sure that the genes order is the same
    datasets.comb <- merge( datasets.comb, dataset, by=1, all = FALSE, sort= TRUE)
      
    ##### Remove per-sample data for merged samples to free some memory
    rm(dataset)
  }
  
  ##### Use gene IDs as rownames
  rownames(datasets.comb) <- datasets.comb[,1]
  datasets.comb <- datasets.comb[, -1]
  
  ##### Make syntactically valid names
  colnames(datasets.comb) <- make.names(colnames(datasets.comb))
  
  ##### Make sure that the target file contains info only about samples present in the data matrix
  targetFile <- targetFile[ rownames(targetFile) %in% colnames(datasets.comb),  ]
  
  ##### Make sure that the samples order in the data matrix is the same as in the target file 
  datasets.comb <- datasets.comb[ , rownames(targetFile) ]
  
  ##### Identify genes that were not present across all per-sampel files and were ommited in the merged matrix
  gene_list <- unique(gene_list)
  gene_list.missing <- gene_list[ gene_list %!in% rownames(datasets.comb) ]
  
  ##### Write list of missing genes into a file
  if ( length(gene_list.missing) > 0 ) {
    write.table(prepare2write(gene_list.missing), file = paste0(params$report_dir, "/", sample_name, ".", params$dataset, ".missing_genes.txt"), sep="\t", quote=FALSE, row.names=TRUE, append = FALSE )
  }
  
    return( list(datasets.comb, targetFile) )
}

##### Assign colours to different groups
getTargetsColours <- function(targets) {
  
##### Predefined selection of colours for groups
targets.colours <- c("powderblue", "red", "gray50")
  
  f.targets <- factor(targets)
  vec.targets <- targets.colours[1:length(levels(f.targets))]
  targets.colour <- rep(0,length(f.targets))
  for(i in 1:length(f.targets))
    targets.colour[i] <- vec.targets[ f.targets[i]==unique(f.targets)]
  
  return( list(vec.targets, targets.colour) )
}

##### Assign colours to different datasets
getDatasetsColours <- function(datasets) {
  
  ##### Predefined selection of colours for datasets
  datasets.colours <- c("dodgerblue","firebrick","lightslategrey","darkseagreen","orange","darkcyan","bisque", "coral2", "cadetblue3","red","blue","green")
  
  f.datasets <- factor(datasets)
  vec.datasets <- datasets.colours[1:length(levels(f.datasets))]
  datasets.colour <- rep(0,length(f.datasets))
  for(i in 1:length(f.datasets))
    datasets.colour[i] <- vec.datasets[ f.datasets[i]==levels(f.datasets)]
  
  return( list(vec.datasets, datasets.colour) )
}

##### Calculate TPM from RPKM (from http://luisvalesilva.com/datasimple/rna-seq_units.html )
tpm_from_rpkm <- function(x) {
  rpkm.sum <- colSums(x)
  return(t(t(x) / (1e-06 * rpkm.sum)))
}

##### Function to generate a full-resolution pdf image before generating a small image in the chunk (from https://stackoverflow.com/questions/37834053/what-is-a-simple-way-to-thumbnail-some-plots-in-r-markdown-knitr )
allow_thumbnails <- function(x, options) {
  if (!is.null(options$thumb)) {
    filename <- sprintf("%s.full.pdf", strsplit(basename(x), "\\.")[[1]][1])
    absolute_path <- file.path(dirname(x), filename)

    # generate the full resolution pdf
    pdf(absolute_path, width = options$thumb$width, height = options$thumb$height)
      eval(parse(text = options$code))
    dev.off()

    # add an html link to the low resolution png
    options$fig.link = absolute_path
  }

  knitr:::hook_plot_md_base(x, options)
}

##### Perform PCA. This function outputs a list with dataframe and samples colouring info ready for plotting
pca <- function(data, targets, plot_mode = "static" ) {

  ##### Keep only genes with variance > 0 across all samples
  rsd <- apply(data,1,sd)
  data.subset <- data[rsd>0,]
  
  ##### Perform PCA
  data.subset_pca <- prcomp(t(data.subset), scale=FALSE)
  
  ##### Get variance importance for all principal components
  importance_pca <- summary(data.subset_pca)$importance[2,]
  importance_pca <- paste(round(100*importance_pca, 2), "%", sep="")
  names(importance_pca) <- names(summary(data.subset_pca)$importance[2,])
    
  ##### Prepare data frame
  data.subset_pca.df <- data.frame(targets$Target, targets$Dataset, data.subset_pca$x[,"PC1"], data.subset_pca$x[,"PC2"], data.subset_pca$x[,"PC3"])
  colnames(data.subset_pca.df) <- c("Target", "Dataset", "PC1", "PC2", "PC3")
  
  ##### Assigne colours to targets and datasets
  targets.colour <- getTargetsColours(targets$Target)
  datasets.colour <- getDatasetsColours(targets$Dataset)
  
  ##### Create a list with dataframe and samples colouring info
  pca.list <- list(data.subset_pca.df, importance_pca, targets.colour, datasets.colour)
  names(pca.list) <- c("pca.df", "importance_pca", "targets", "datasets")
  
  ##### Change the targets levels order
  data.subset_pca.df$Target <- factor(data.subset_pca.df$Target, levels = unique(data.subset_pca.df$Target))
  
  ##### Generate PCA 2-D plot
  pca_plot <- plot_ly(data.subset_pca.df, x = ~PC1, y = ~PC2, color = ~Target, text=paste(targets$Target, rownames(data.subset_pca.df), sep=": "), colors = targets.colour[[1]], type='scatter', mode = "markers", marker = list(size=10, opacity = 0.7), width = 800, height = 400) %>%
  layout(title = "", xaxis = list(title = paste( "PC1", " (",importance_pca["PC1"],")",sep="")), yaxis = list(title = paste( "PC2", " (",importance_pca["PC2"],")",sep="")), margin = list(l=50, r=50, b=50, t=20, pad=4), autosize = FALSE, showlegend = TRUE, legend = list(orientation = "v", y = 0.9))

  ##### Generate scree plot
  data.subset_scree.df <- data.frame(paste0("PC ", c(1:length(data.subset_pca$sdev))), data.subset_pca$sdev)
colnames(data.subset_scree.df) <- c("PC", "Variances")

  ##### The default order will be alphabetized unless specified as below
  data.subset_scree.df$PC <- factor(data.subset_scree.df$PC, levels = data.subset_scree.df[["PC"]])
  
  scree_plot <- plot_ly(data.subset_scree.df, x = ~PC, y = ~Variances, type = 'bar', width = 800, height = 400) %>%
    layout(title = "", xaxis = list(title = ""), margin = list(l=50, r=50, b=100, t=20, pad=4), autosize = F)
  
  ##### Embed static rather interactive plots into the html report if requested by user. This will reduce the report size. To this end the orca() function in plotly is used. Of note, this requires orca (https://github.com/plotly/orca) installation (conda option worked well for me, https://github.com/plotly/orca#method-1-conda), but the orca needs to be in the PATH, see https://github.com/plotly/orca/pull/122). In case of issues/errors (such as orca utility is required to use orca() function), it might be needed to restart Rstudio from the commandline using "open -na Rstudio" and for 'Argument list too long' try "devtools::install_github('ropensci/plotly')"
  if ( plot_mode == "static" ) {

      PlotsDir <- paste(params$report_dir, "InputDataPlots", sep = "/")
      if ( !file.exists(PlotsDir) ) {
      
        dir.create(PlotsDir, recursive=TRUE)
      }
        
      ##### Add access token, required by orca function, to the shell environment
      Sys.setenv('MAPBOX_TOKEN' = 'secret token')
  
      ##### Change directory to folder with CDF plots
      setwd(PlotsDir)
 
      ##### Save the static image into a file
      orca(pca_plot, format = "png", file = "pca_plot.png", width = 800, height = 600)
  
      ##### Present the static plot in the report
      pca_plot <- include_graphics(paste(PlotsDir, "pca_plot.png", sep = "/"), dpi = 144)
      
      ##### Save the static image into a file
      orca(scree_plot, format = "png", file = "scree_plot.png", width = 1200, height = 400)
  
      ##### Present the static plot in the report
      scree_plot <- include_graphics(paste(PlotsDir, "scree_plot.png", sep = "/"), dpi = 144)
    
      return( list(pca.list, pca_plot, scree_plot) )
      
    } else if ( plot_mode == "interactive" || plot_mode == "semi-interactive" ) {

      return( list(pca.list, pca_plot, scree_plot) )
    }
}

##### Convert a vector of numbers into corresponding vector of their percentiles
perc.rank <- function(x) trunc(rank(x))*100/length(x)

##### Perform range standardization between 0 and 1 (for the cumulative sums)
standardization <- function(x) c(x-min(x))/(max(x)-min(x))

##### Calculating cumulative sum for while keeping the original data order
cumsum_ordered <- function(x) {
  
  ##### Perform range standardization between 0 and 1, otherwise the negative values are summed up
  standarised <- standardization(x)
  
  ##### Sort and cumsum values
  sorted_cumsum <- cumsum(sort(standarised))
  
  ##### Restore the original elements order
  ordered_cumsum <- sorted_cumsum[ names(standarised) ]
  
  ##### Perform range standardization between 0 and 1, otherwise the negative values are summed up
  standarised_cumsum <- standardization(ordered_cumsum)
  
  return( standarised_cumsum )
}

##### Check for nearest value in a vector
nearest_position <- function(vector, x) {
  
  y <- which.min(abs(vector - x))
  
return( y )
}

##### Calculate gene-wise median, sd, quantiles and cumulative franctions for expression data
exprGroupsStats_geneWise <- function(data, targets) {
  
  ##### Perform Z-score transformation of the expression values
  data.z <- t(apply(data, 1, scale, scale = TRUE))
  colnames(data.z) <- colnames(data)

  ##### Perform the gene-wise calculations across all groups
  ##### Convert a expression values into corresponding percentiles
  data.q <- t(apply(data, 1, perc.rank))
 
  ##### Calculate cumulative sums and perform range standardization between 0 and 1
  data.cum <- t(apply(data, 1, cumsum_ordered))
 
  ##### Create lists with stats for each group and gene
  targets.list <- unique(targets$Target)
  group_stats.list <- vector("list", length(targets.list))
  names(group_stats.list) <- targets.list
  
  #### For each group...
  for ( group in targets.list ) {
    
    ##### For groups with > 1 sample get the median values for each gene
    if ( sum(c(targets$Target %in% group), na.rm = TRUE) > 1 && nrow(data) > 1 )  {
      
      ##### Extract the median expression values
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], rowMedians(data[ , colnames(data)[ targets$Target %in% group ] ]))

      ##### Extract the expression sd values
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], rowSds(data[ , colnames(data)[ targets$Target %in% group ] ]))
      
      ##### Extract the median Z-scores
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], rowMedians(data.z[ , colnames(data)[ targets$Target %in% group ] ]))

      ##### Extract the median percentiles
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], rowMedians(data.q[ , colnames(data)[ targets$Target %in% group ] ]))
      
      ##### Extract the cumulative fraction corresponding to the median Z-score
      ##### First, need to get the position of the Z-score nearest to the median Z-score, and then extract the cumulative value at this position
      data.z.median_pos <- apply(data.z, 1, nearest_position, median(data.z[ , colnames(data)[ targets$Target %in% group, drop = FALSE ] ]))
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], data.cum[ data.z.median_pos ] )
      
      group_stats.list[[group]] <- as.data.frame(group_stats.list[[group]])
      names( group_stats.list[[group]] ) <- c("median", "sd", "z", "quantile", "cum")
      
    } else if ( sum(c(targets$Target %in% group), na.rm = TRUE) > 1 && nrow(data) == 1 ) {
      
      ##### Extract the median expression values
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], median(data[ , colnames(data)[ targets$Target %in% group, drop = FALSE ] ]))

      ##### Extract the expression sd values
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], sd(data[ , colnames(data)[ targets$Target %in% group, drop = FALSE ] ]))
      
      ##### Extract the median Z-scores
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], median(data.z[ , colnames(data)[ targets$Target %in% group, drop = FALSE ] ]))

      ##### Extract the median percentiles
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], median(data.q[ , colnames(data)[ targets$Target %in% group, drop = FALSE ] ]))
      
      ##### Extract the cumulative fraction corresponding to the median Z-score
      ##### First, need to get the position of the Z-score nearest to the median Z-score, and then extract the cumulative value at this position
      data.z.median_pos <- nearest_position( data.z, median(data.z[ , colnames(data)[ targets$Target %in% group, drop = FALSE ] ]))
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], data.cum[ data.z.median_pos ] ) 

      group_stats.list[[group]] <- as.data.frame(group_stats.list[[group]])
      names( group_stats.list[[group]] ) <- c("median", "sd", "z", "quantile", "cum")
      rownames( group_stats.list[[group]] ) <- rownames(data)
      
    } else {

      ##### Extract the median expression values
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], data[ , colnames(data)[ targets$Target %in% group ] ])

      ##### Extract the expression sd values
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], rep( NA, nrow(data)))
      
      ##### Extract the median Z-scores
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], data.z[ , colnames(data)[ targets$Target %in% group ] ])

      ##### Extract the median percentiles
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], data.q[ , colnames(data)[ targets$Target %in% group ] ])
      
      ##### Extract the median cumulative fraction
      group_stats.list[[group]] <- cbind(group_stats.list[[group]], data.cum[ , colnames(data)[ targets$Target %in% group ] ])
      
      group_stats.list[[group]] <- as.data.frame(group_stats.list[[group]])
      names( group_stats.list[[group]] ) <- c("median", "sd", "z", "quantile","cum")
      rownames( group_stats.list[[group]] ) <- rownames(data)
     }
  }
  
  ##### Finally, extract cumulative values for each gene within individual groups
  gene_stats.list <- vector("list", length(targets.list))
  names(gene_stats.list) <- targets.list
  
  #### For each group...
  for ( group in targets.list ) {
    
    ##### Extract per-gene expression values
    gene_stats.list[[group]]$median <- data[ , colnames(data)[ targets$Target %in% group ], drop = FALSE ]
    
    ##### Extract per-gene z-score values
    gene_stats.list[[group]]$z <- data.z[ , colnames(data.z)[ targets$Target %in% group ], drop = FALSE ]
    
    ##### Extract per-gene percentile values
    gene_stats.list[[group]]$q <- data.q[ , colnames(data.q)[ targets$Target %in% group ], drop = FALSE ]
    
    ##### Extract per-gene cumulative values
    gene_stats.list[[group]]$cum <- data.cum[ , colnames(data.cum)[ targets$Target %in% group ], drop = FALSE ]

  }
  
  return( list( group_stats.list, gene_stats.list) )
}

##### Calculate group-wise median, sd, quantiles and cumulative franctions for expression data from specific sample group
exprGroupStats_groupWise <- function(data, targets, target) {
  
  ##### Subset data for defined biological group
  data.group <- data[, targets$Target %in% target ]
  
  ##### For groups with > 1 sample get the median and standard deviation for each gene
  if ( !is.null(ncol(data.group)) )  {
    
    data.group.median <- rowMedians(data.group)
    data.group.median <- sort(data.group.median)
    data.group.sd <- rowSds(data.group)
    
  } else {
    data.group.median <- sort(data.group)
    data.group.sd <- rep( NA, length(data.group))
  }
  
  ##### Make sure the median and sd vectors have the same gene order
  names(data.group.sd) <- rownames(data.group)
  data.group.sd <- data.group.sd[names(data.group.median)]

  ##### Convert a expression values into corresponding percentiles
  data.group.q <- perc.rank(data.group.median)
  
  ##### Perform range standardization between 0 and 1 (for the cumulative sums), otherwise the negative values are summed up
  data.group.s <- sort(standardization(data.group.median))
  
  ##### Calculate cumulative sums and perform range standardization between 0 and 1 
  data.group.cum <- standardization(cumsum(data.group.s))
  
  ##### Perform Z-score transformation of the median expression values
  data.group.z <- scale(data.group.median, scale = FALSE)
  
  ##### Organise the data into data frame
  data.group.df <- as.data.frame(cbind( data.group.median, data.group.sd, data.group.z, data.group.q, data.group.cum))
  names(data.group.df) <- c("median", "sd", "z", "quantile", "cum")
  
  return( data.group.df )
}

##### Generate cumulative distribution function (CDF) plot for selected gene. If option "addBoxPlot" = TRUE, then generate additional boxplot below to show the data variance for selected gene in individual groups
cdfPlot <- function(gene, data, targets, sampleName, int_cancer, ext_cancer, addBoxPlot = FALSE, plot_mode = "static", scaling = "gene-wise") {
  
  ##### Initiate lists with stats for each group
  targets.list <- unique(targets$Target)
  group.z <- vector("list", length(targets.list))
  names(group.z) <- targets.list
  
  ##### .... and for selected gene
  group.z.gene <- vector("list", length(targets.list))
  names(group.z.gene) <- targets.list

  ##### Get expression-related stats for each group
  ##### ... from gene-wise approach 
  if ( scaling == "gene-wise" ) {

    ##### Get stats for each group
    gene.data <- data[ gene, , drop = FALSE]
    group.z.gene <- exprGroupsStats_geneWise(gene.data, targets)[[1]]
    
    ##### ... and for each sample in individual groups
    gene.stats <- exprGroupsStats_geneWise(gene.data, targets)[[2]]

    for ( group in targets.list ) {
        
        group.z[[ group]] <- cbind(t(gene.stats[[ group]]$median), t(gene.stats[[ group]]$z), t(gene.stats[[ group]]$q), t(gene.stats[[ group]]$cum) )
        group.z[[ group]] <- as.data.frame(group.z[[ group]])
        colnames(group.z[[ group]]) <- c("median", "z", "quantile", "cum")
    }
    
    group.z[[ sampleName ]] <- do.call("rbind", group.z)
    
  ##### ... or from group-wise approach
  } else {

    group.z[[ sampleName ]] <- exprGroupStats_groupWise(data, targets, sampleName)
    group.z[[ int_cancer ]] <- exprGroupStats_groupWise(data, targets, int_cancer)
    group.z[[ ext_cancer ]] <- exprGroupStats_groupWise(data, targets, ext_cancer)
    
    ##### Extract expression for selected genes
    group.z.gene[[ sampleName ]] <- group.z[[ sampleName ]][ rownames(group.z[[ sampleName ]]) %in% gene, ]
    group.z.gene[[ int_cancer ]] <- group.z[[ int_cancer ]][ rownames(group.z[[ int_cancer ]]) %in% gene, ]
    group.z.gene[[ ext_cancer ]] <- group.z[[ ext_cancer ]][ rownames(group.z[[ ext_cancer ]]) %in% gene, ]
  }
  
  ##### Generate box-plot for selected gene
  if ( addBoxPlot ) {
    
    ##### Perform Z-score transformation of the median expression values
    if ( scaling == "gene-wise" ) {
      
      data.z <- t(scale(t(data)))
    } else {
      data.z <- scale(data, scale = FALSE)
    }
    
    targets$Target[ targets$Target==sampleName ] <- "Patient"
    
    gene.expr.df <- data.frame(targets$Target, data.z[gene, ])
    colnames(gene.expr.df) <- c("Group", "Expression")
    
    ##### Reorder groups
    gene.expr.df$Group <- factor(gene.expr.df$Group, levels=c(ext_cancer, int_cancer, "Patient"))
    
    p2 <- plot_ly(gene.expr.df, x= ~Expression, color = ~Group, type = 'box', jitter = 0.3, pointpos = 0, boxpoints = 'all', colors = c("lightcyan2", "red", "black"), opacity = 0.5, orientation = 'h', width = 800, height = 600, showlegend=FALSE)
  }
  
  ##### Generate interactive CFD plot with plotly
  p1 <- plot_ly(group.z[[ sampleName ]], x = ~z, color = I("black")) %>%
  
    ##### Add sample data
    add_markers(y = group.z.gene[[ sampleName ]]$cum, x = group.z.gene[[ sampleName ]]$z,
                text = rownames(group.z.gene[[ sampleName ]] ),
                name = "Patient",
                marker = list(size = 12, color = "black"),
                showlegend = TRUE) %>%
  
    add_lines(y = group.z[[ sampleName ]]$cum, x = group.z[[ sampleName ]]$z, 
              line = list(color = "grey"),
              text = rownames( group.z[[ sampleName ]] ),
              name = "Patient", showlegend = FALSE) %>%
    
    ##### Add int_cancer data
    add_markers(y = group.z.gene[[ int_cancer ]]$cum, x =  group.z.gene[[ int_cancer ]]$z,
                text = rownames( group.z.gene[[ int_cancer ]]),
                name = int_cancer,
                marker = list(size = 12, opacity = 0.5, color = "red"),
                showlegend = TRUE) %>%
  
    add_lines(y = group.z[[ int_cancer ]]$cum, x = group.z[[ int_cancer ]]$z, opacity = 0.5,
              line = list(color = "red", dash = "dash"),
              text = rownames( group.z[[ int_cancer ]] ),
              name = int_cancer, showlegend = FALSE) %>%
    
    ##### Add ext_cancer data
    add_markers(y = group.z.gene[[ ext_cancer ]]$cum, x =  group.z.gene[[ ext_cancer ]]$z,
                text = rownames( group.z.gene[[ ext_cancer ]] ),
                name = ext_cancer,
                marker = list(size = 12, opacity = 0.5, color = "cornflowerblue"),
                showlegend = TRUE) %>%
  
    add_lines(y = group.z[[ ext_cancer ]]$cum, x = group.z[[ ext_cancer ]]$z, opacity = 0.5,
              line = list(color = "cornflowerblue", dash = "dash"),
              text = rownames( group.z[[ ext_cancer ]] ),
              name = ext_cancer, showlegend = FALSE) %>%
    
    ##### Add quantile lines
    add_lines(y = seq(0,1,0.1), x = rep(quantile(group.z[[ sampleName ]]$z)[2], 11), opacity = 0.5,
              line = list(color = "gray", dash = "dash"),
              name = "Q1", showlegend = FALSE) %>%
    
    add_lines(y = seq(0,1,0.1), x = rep(quantile(group.z[[ sampleName ]]$z)[3], 11), opacity = 0.5,
              line = list(color = "gray", dash = "dash"),
              name = "Q2", showlegend = FALSE) %>%
    
    add_lines(y = seq(0,1,0.1), x = rep(quantile(group.z[[ sampleName ]]$z)[4], 11), opacity = 0.5,
              line = list(color = "gray", dash = "dash"),
              name = "Q3", showlegend = FALSE) %>% 
    
        layout(title = gene, xaxis = list(title = "mRNA expression (Z-score)", zeroline = FALSE, range = c(min(group.z[[ sampleName ]]$z)-1.5, max(group.z[[ sampleName ]]$z)+1.5)),
           yaxis = list(title = "Cumulative fraction"),
           legend = list(orientation = 'v', x = 0.02, y = 1, bgcolor = "white")
    )
  
  ##### Combine CDF plot with boxplot if this option is selected
  if ( addBoxPlot ) {
    
    p1_2 <- subplot(p1, p2, nrows = 2, shareX = TRUE, shareY = FALSE, titleY = TRUE) %>%
  layout(xaxis = list(title = "mRNA expression (Z-score)", zeroline = FALSE, range = c(min(group.z[[ sampleName ]]$z)-1.5, max(group.z[[ sampleName ]]$z)+1.5)),
          yaxis = list(title = "Cumulative fraction"),
          legend = list(orientation = 'v', x = 0.02, y = 1, bgcolor = "white"),
          yaxis2 = list( title =""), xaxis2 = list(title = paste0(gene, " mRNA expression (Z-score)")), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE,
         showlegend=TRUE, showlegend2=FALSE)
    
    ##### Embed static rather interactive plots into the html report if requested by user. This will reduce the report size. To this end the orca() function in plotly is used. Of note, this requires orca (https://github.com/plotly/orca) installation (conda option worked well for me, https://github.com/plotly/orca#method-1-conda), but the orca needs to be in the PATH, see https://github.com/plotly/orca/pull/122). In case of issues/errors (such as orca utility is required to use orca() function), it might be needed to restart Rstudio from the commandline using "open -na Rstudio" and for 'Argument list too long' try "devtools::install_github('ropensci/plotly')"
    if ( plot_mode == "static" || plot_mode == "semi-interactive" ) {

      ##### Create directory for CDF plots
      PlotsDir <- paste(params$report_dir, "CDF_plots", sep = "/")
      if ( !file.exists(PlotsDir) ) {

        dir.create(PlotsDir, recursive=TRUE)
      }
  
      ##### Add access token, required by orca function, to the shell environment
      Sys.setenv('MAPBOX_TOKEN' = 'secret token')
  
      ##### Change directory to folder with CDF plots
      setwd(PlotsDir)
 
      ##### Save the static image into a file
      orca(p1_2, format = "png", file = paste0(gene, "_cdf_box_plot.png"), width = 800, height = 600)
  
      ##### Present the static plot in the report
      include_graphics(paste(PlotsDir, paste0(gene, "_cdf_box_plot.png"), sep = "/"), dpi = 72)
  
    } else if ( plot_mode == "interactive" ) {

      return( p1_2 )
    }
    
  } else {
   
    if ( plot_mode == "static" || plot_mode == "semi-interactive" ) {

      ##### Create directory for CDF plots
      PlotsDir <- paste(params$report_dir, "CDF_plots", sep = "/")
      if ( !file.exists(PlotsDir) ) {

        dir.create(PlotsDir, recursive=TRUE)
      }
  
      ##### Add access token, required by orca function, to the shell environment
      Sys.setenv('MAPBOX_TOKEN' = 'secret token')
  
      ##### Change directory to folder with CDF plots
      setwd(PlotsDir)
  
      ##### Save the static image into a file
      orca(p1, format = "png", file = paste0(gene, "_cdf_plot.png"), width = 800, height = 200)
  
      ##### Present the static plot in the report
      include_graphics(paste(PlotsDir, paste0(gene, "_cdf_plot.png"), sep = "/"), dpi = 72)
  
    } else if ( plot_mode == "interactive" ) {

      return( p1 )
    }
  }
}


##### Generate boxplot presenting expression profiles for selected set of genes
glanceExprPlot <- function(genes, data, targets, sampleName, int_cancer, ext_cancer, comp_cancer, plot_mode = "static", hexcode, scaling = "gene-wise") {
  
  ##### Perform Z-score transformation of the median expression values
  if ( scaling == "gene-wise" ) {
      
    data.z <- t(scale(t(data)))
  } else {
    data.z <- scale(data, scale = FALSE)
  }
  
  targets$Target[ targets$Target==sampleName ] <- "Patient"
  
  ##### Make sure that all genes are present in the expression matrix
  genes <- genes[ genes %in% rownames(data.z) ]
  
  ##### Sort genes by the highest values in the "comp_cancer" cohort
  comp_cancer.medians <- rowMedians( data.z[ genes ,targets$Target==comp_cancer ] )
  names(comp_cancer.medians) <- genes
  genes <- genes [ order(comp_cancer.medians) ]
   
  ##### Prepare dataframe for plotly
  gene.expr.df <- NULL
  
  for ( gene in genes ) {
  
    gene.expr.df <- rbind(gene.expr.df, data.frame(gene, targets$Target, data.z[gene, ]))
  }
  
  colnames(gene.expr.df) <- c("Gene", "Group", "Expression")
  
  ##### Reorder groups
  gene.expr.df$Group <- factor(gene.expr.df$Group, levels=c("Patient", int_cancer, ext_cancer))
    
  p <- plot_ly( gene.expr.df, x = ~Gene, y = ~Expression, color = ~Group, type = "box", colors = c(I("black"), "red", "cornflowerblue"), opacity=0.2, showlegend = TRUE, width = 800, height = 400 ) %>% 
    add_markers(x = ~Gene[ gene.expr.df$Group %in% "Patient" ], y = ~Expression[ gene.expr.df$Group %in% "Patient" ], color = ~Group[ gene.expr.df$Group %in% "Patient" ], marker = list(size = 7), opacity=1, showlegend = FALSE) %>%
    
    layout(boxmode = "group", xaxis = list(title = ""), yaxis = list(title = "mRNA expression (Z-score)"), legend = list( orientation = 'h', y = max(gene.expr.df$Expression), yancho = "top", bgcolor = "white"))
    
  ##### Create directory for "at glance" plots
  PlotsDir <- paste(params$report_dir, "glanceExprPlots", sep = "/")
    
  if ( !file.exists(PlotsDir) ) {

    dir.create(PlotsDir, recursive=TRUE)
  }
    
  ##### Embed static rather interactive plots into the html report if requested by user. This will reduce the report size. To this end the orca() function in plotly is used. Of note, this requires orca (https://github.com/plotly/orca) installation (conda option worked well for me, https://github.com/plotly/orca#method-1-conda), but the orca needs to be in the PATH, see https://github.com/plotly/orca/pull/122). In case of issues/errors (such as orca utility is required to use orca() function), it might be needed to restart Rstudio from the commandline using "open -na Rstudio" and for 'Argument list too long' try "devtools::install_github('ropensci/plotly')"
  if ( plot_mode == "static" ) {
  
    ##### Add access token, required by orca function, to the shell environment
    Sys.setenv('MAPBOX_TOKEN' = 'secret token')
  
    ##### Change directory to folder with plots
    setwd(PlotsDir)
 
    ##### Save the static image into a file
    orca(p, format = "png", file = paste0(hexcode, "_glance_expr_plot.png"), width = 1200, height = 600)
  
    ##### Present the static plot in the report
    include_graphics(paste(PlotsDir, paste0(hexcode, "_glance_expr_plot.png"), sep = "/"), dpi = 72)
  
  } else if ( plot_mode == "interactive" || plot_mode == "semi-interactive" ) {
    
    p <- plot_ly( gene.expr.df, x = ~Gene, y = ~Expression, color = ~Group, type = "box", colors = c(I("black"), "red", "cornflowerblue"), opacity=0.2, showlegend = TRUE, width = 800, height = 600 ) %>% 
    add_markers(x = ~Gene[ gene.expr.df$Group %in% "Patient" ], y = ~Expression[ gene.expr.df$Group %in% "Patient" ], color = ~Group[ gene.expr.df$Group %in% "Patient" ], marker = list(size = 7), opacity=1, showlegend = FALSE) %>%
    
    layout(boxmode = "group", xaxis = list(title = ""), yaxis = list(title = "mRNA expression (Z-score)"), legend = list( orientation = 'h', y = max(gene.expr.df$Expression), yancho = "top", bgcolor = "white"))
    
    ##### Save interactive plot as html file
    htmlwidgets::saveWidget(p, file = paste(PlotsDir, paste0(hexcode, "_glance_expr_plot.html"), sep = "/"))
    
    return( p )
  }
}


##### Generate scatterplot with per-gene expression values (y-axis), CN values (x-axis) and mutation status info (colours), if provided
mutCNexprPlot <- function(data, mut_data = FALSE, cn_bottom = 1.5, cn_top = 3, comp_cancer, plot_mode = "static") {
  
  ##### Extract info for genes to be annotated on the plot
  genes2annot <- data[ data$CN > cn_top | data$CN < cn_bottom ,]$Gene
  
  if ( length(genes2annot) == 0 ) {
    
    genes2annot <- ""
  }
  
  ##### Generate scatterplot with per-gene expression values (y-axis) (difference between Patient's and [comp_cancer] data), CN values (x-axis) and mutation status info (colours)
  if ( mut_data ) {
  
    p <- plot_ly(data, x = ~CN, y = ~Z_score_diff, color = ~Mutation, text=~Gene, type='scatter', mode = "markers", marker = list(size=10, symbol="circle"), width = 800, height = 600) %>%
      
      add_annotations( text="Mutation", xref="paper", yref="paper",
                      x=1.02, xanchor="left",
                      y=1, yanchor="top",
                      legendtitle=TRUE, showarrow=FALSE ) %>%
      
      add_annotations( data = data[ data$CN > cn_top | data$CN < cn_bottom ,], text=genes2annot,
                      x=~CN, xanchor="left",
                      y=~Z_score_diff, yanchor="top",
                      font = list(color = "Grey",
                                size = 10),
                      legendtitle=TRUE, showarrow=FALSE ) %>%
      
      layout( xaxis = list(title = "CN values"), yaxis = list(title = paste0("mRNA expression (Z-score [Patient vs ", comp_cancer, "])")), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = F, legend = list( orientation = 'v', x=1, y=0.97, yanchor="top"), showlegend=TRUE)
  
  ##### Generate scatterplot with per-gene expression values (y-axis) and CN values (x-axis)
  } else {
  
    p <- plot_ly(data, x = ~CN, y = ~Z_score_diff, text=~Gene, type='scatter', mode = "markers", marker = list(size=10, symbol="circle"), width = 800, height = 600) %>%
      
      add_annotations( data = data[ data$CN > cn_top | data$CN < cn_bottom ,], text=~Gene,
                      x=~CN, xanchor="left",
                      y=~Z_score_diff, yanchor="top",
                      font = list(color = "Grey",
                                size = 10),
                      legendtitle=TRUE, showarrow=FALSE ) %>%
      
      layout( xaxis = list(title = "CN values"), yaxis = list(title =  paste0("mRNA expression (Z-score [Patient vs ", comp_cancer, "])")), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = F, legend = list( orientation = 'v', y=0.8, yanchor="top"), showlegend=FALSE)
  }
  
  ##### Create directory for the plots
  mutCNexprPlotDir <- paste(params$report_dir, "mut_cn_expr_plot", sep = "/")
  if ( !file.exists(mutCNexprPlotDir) ) {

    dir.create(mutCNexprPlotDir, recursive=TRUE)
  }
    
  ##### Embed static rather interactive plots into the html report if requested by user. This will reduce the report size. TO this end the orca() function in plotly is used. Of note, this requires orca (https://github.com/plotly/orca) installation (conda option worked well for me, https://github.com/plotly/orca#method-1-conda), but the orca needs to be in the PATH, see https://github.com/plotly/orca/pull/122). 
  if ( plot_mode == "static" ) {
    
    ##### Add access token, required by orca function, to the shell environment
    Sys.setenv('MAPBOX_TOKEN' = 'secret token')

    ##### Change directory to folder with CDF plots
    setwd(mutCNexprPlotDir)

    ##### Save the static image into a file
    orca(p, format = "png", file = "mut_cn_expr_plot.png", width = 800, height = 600)

    ##### Present the static plot in the report
    include_graphics(paste(mutCNexprPlotDir, "mut_cn_expr_plot.png", sep = "/"), dpi = 72)
  
  } else if ( plot_mode == "interactive" || plot_mode == "semi-interactive" ) {
    
    ##### Save interactive plot as html file
    htmlwidgets::saveWidget(p, file = paste(mutCNexprPlotDir, "mut_cn_expr_plot.html", sep = "/"))
  
    return( p )
  }
}

##### Fusion visualisation 
fusion_png <- function(geneA, geneB, clinker_results ) {

  ##### Get path to fusion visualisation  pdf file
  fusion_pdf <- paste(clinker_results, paste0(geneA, "_", geneB, ".pdf"), sep = "/")
  
  ##### Export pdf to png
  fusion_png <- paste(clinker_results, paste0(geneA, "_", geneB, ".png"), sep = "/")
  fusion <- pdf_render_page(fusion_pdf, page = 1, dpi = 300, numeric = TRUE, opw = "", upw = "")
  writePNG(fusion, fusion_png)
  
  ##### Present the converted file in the report
  include_graphics(fusion_png)
}


##### Generate table with coloured cells indicating expression values for selected genes
exprTable <- function(genes, data, cn_data = NULL, sv_data = NULL, cn_decrease = TRUE, targets, sampleName, int_cancer, ext_cancer, comp_cancer, genes_annot = NULL, cancer_genes = NULL, mut_annot = NULL, fusion_genes = NULL, ext_links = FALSE, type = "z", scaling = "gene-wise") {
  
  ##### Check which of the selected genes are not present in the expression data
  genes.absent <- genes[ genes %!in% rownames(data) ]
  
  ##### Initiate dataframe for expression median values in each group
  targets.list <- unique(targets$Target)
  group.z <- as.data.frame(matrix(NA, ncol = length(targets.list), nrow = nrow(data)))
  colnames(group.z) <- targets.list
  rownames(group.z) <- rownames(data)
    
  ##### Perform scaling gene-wise
  if ( scaling == "gene-wise" ) {

    ##### Calculate z-score for each group  
    group.stats <- exprGroupsStats_geneWise(data, targets)[[1]]
      
    #### Present expression data as percentiles or z-score values (default)
    for ( group in targets.list ) {
        
      if ( type == "perc" ) {
        
        group.z[, group] <- round(group.stats[[ group ]]$quantile, digits=1)
        
      } else {
        
        group.z[, group] <- round(group.stats[[ group ]]$z, digits=2)
      }
    }
    
  ##### Perform scaling group-wise
  } else {
  
    for ( group in targets.list ) {
      
      ##### Calculate z-score for each group  
      group.stats <- exprGroupStats_groupWise(data[rownames(group.z), ], targets, group)
      group.stats <- group.stats[order(rownames(group.stats)), ]
      
      #### Present expression data as percentiles or z-score values (default)
      if ( type == "perc" ) {
        
        group.z[, group] <- round(group.stats$quantile, digits=1)
  
      } else {
        group.z[, group] <- round(group.stats$z, digits=2)
      }
    } 
  }
  
  ##### Compute Z-scores sd for each gene across groups
  group.z <- cbind(group.z, round(rowSds(as.matrix(group.z)), digits = 2))
  names(group.z)[ncol(group.z)] <- "SD"
  
  ##### Calculate Z-score differneces between investigated sample and median values in the cancer group of interest
  group.z <- cbind(group.z, round((group.z[, sampleName] - group.z[, comp_cancer]), digits = 2))
  names(group.z)[ncol(group.z)] <- "Diff"
  
  ##### Add NAs for genes that are absent in the expression matrix. In the "Patient vs [comp_cancer]" columns provide "0"s to facilitate interactive sorting the table. These will appear in blank cells in the table
  if ( length(genes.absent) > 0 ) {
    
    NAs.df <- data.frame(matrix(NA, ncol = ncol(group.z), nrow = length(genes.absent)))
    names(NAs.df) <- names(group.z)
    rownames(NAs.df) <- genes.absent
    NAs.df[ names(NAs.df) %in% "Diff" ] <- 0
    
    group.z <- rbind( group.z,  NAs.df)
  }
  
  ##### Change sample ID to "Patient" for better visualisation
  names(group.z)[names(group.z)==sampleName] <- "Patient"
  targets.list[targets.list==sampleName] <- "Patient"
  
  ##### Reorder groups
  group.z <- cbind(group.z[ , c(ext_cancer, int_cancer, "Patient")], group.z[, c("SD", "Diff" )])
  
  ##### Add "Gene" column to facilitate adding annotations
  group.z$Gene <- rownames(group.z)
  
  ##### Add genes annotation
  if ( !is.null(genes_annot) ) {
    
    ##### Remove rows with duplicated gene symbols
    if ( "SYMBOL" %in% names(genes_annot) ) {
      
      genes_annot <- genes_annot[!duplicated(genes_annot$SYMBOL),]  
    }
    
    ##### Merge the dataframe with groups median expression values and gene annotations
    group.z <- merge(genes_annot, group.z, by.x="SYMBOL", by.y="Gene", all = TRUE, sort = FALSE)
    names(group.z) <- gsub("SYMBOL", "Gene", names(group.z))
    
  }
  
  ##### Define colours for cells background for each group and the patient vs [comp_cancer] difference
  ##### Initiate dataframe for expression median values in each group
  brks.q <- as.data.frame( matrix(NA, ncol = length(targets.list), nrow = length(seq(.05, .95, .0005)) ))
  colnames(brks.q) <- targets.list
  clrs.q <- as.data.frame( matrix(NA, ncol = length(targets.list), nrow = length(seq(.05, .95, .0005))+1 ))
  colnames(clrs.q) <- targets.list
  
  for ( group in c(targets.list, "Diff") ) {

    brks.q[[group]] <- quantile(group.z[, group], probs = seq(.05, .95, .0005), na.rm = TRUE)
    #brks.q[[group]] <- sort(group.z[, group])
    
    clrs_pos.q <- round(seq(255, 150, length.out = length(brks.q[[group]])/2 + 1.5), 0) %>%
    {paste0("rgb(255,", ., ",", ., ")")}
    clrs_neg.q <- rev(round(seq(255, 150, length.out = length(brks.q[[group]])/2 - 0.5), 0)) %>%
    {paste0("rgb(", .,",", .,",", "255)")}
    
    clrs.q[[group]] <- c(clrs_neg.q, clrs_pos.q)
  }
  
  ##### Subset the expression data to include only the user-defined genes
  group.z <- group.z[ group.z$Gene %in% genes, ]
    
  #### Add variants information to the expression table - if exists. Note, "TIER" and "CONSEQUENCE" columns are required
  if( !is.null(mut_annot) && "TIER" %in% colnames(mut_annot) && length(genes) > 0 ) {
    
    mut_annot <- mut_annot[mut_annot$SYMBOL %in% genes,]
    
    #### keep only varaints that has the lowest tier value. Multiple varaints detected in same gene but with higher tier will be added to additional column "CONSEQUENCE_OTHER". Applies to the ones that may have multiple mutations and hence tiers
    ##### First, create a list of genes to store multiple variants
    mut_consequence <- vector("list", length(unique(mut_annot$SYMBOL)))
    mut_consequence  <- setNames(mut_consequence,  unique(mut_annot$SYMBOL) )
    
    ##### Record all varaints detected in individual genes
    if ( nrow(mut_annot) > 0 ) {
      
      for ( i in 1:nrow(mut_annot) ) {
        
        mut_consequence[[ mut_annot$SYMBOL[i] ]] <- unique(c( mut_consequence[[ mut_annot$SYMBOL[i] ]], mut_annot$CONSEQUENCE[i] ))
      }
      
      mut_annot$CONSEQUENCE_OTHER <- "-"
    }
    
    ##### Remove the first elements since these variant consequences will be reported as the "canonical" CONSEQUENCE
    mut_consequence <- lapply(mut_consequence, function(x) x[-1])
    
    ##### Order variant entires based on tier info, to make sure that the varaints with the lowest tier are reported first
    mut_annot <- mut_annot[ order(mut_annot$TIER), ]
    
    ##### Remove rows with duplicated gene symbols
    mut_annot <- mut_annot[!duplicated(mut_annot$SYMBOL),]  
    rownames(mut_annot) <- mut_annot$SYMBOL
    
    ##### Add other provided variants consequences for individual genes
    for ( gene in rownames(mut_annot) ) {
      
      if ( length(mut_consequence[[ gene ]]) > 0 ) {
        
        mut_annot$CONSEQUENCE_OTHER[ match(gene, mut_annot$SYMBOL)  ] <- mut_consequence[[ gene ]]
      }
    }
    
    #### merge the variants information with the dataframe
    group.z <- merge(group.z, mut_annot, by.x = "Gene", by.y = "SYMBOL", all = TRUE, sort = FALSE)
  }
  
  ##### Add CN data if provided
  if ( !is.null(cn_data) ) {
    
    ##### Get the position of "Diff" column
    col_idx <- grep("Diff", names(group.z), fixed = TRUE)
    
    ##### Now place the CN data after the "Diff" column
    if ( length(genes) > 0 ) {
      
      group.z <- add_column(group.z, round(cn_data[ group.z$Gene, "CN"], digits=2), .after = col_idx)
      colnames(group.z)[ col_idx+1 ] <- "Patient (CN)"
      cn_range <- base::range(group.z[ ,"Patient (CN)" ], na.rm = TRUE)
      
    } else {
      
      group.z <- add_column(group.z, "", .after = col_idx)
      colnames(group.z)[ col_idx+1 ] <- "Patient (CN)"
      cn_range <- 0
    }
  }

  ##### Add structural variants results from MANTA
  if ( !is.null(sv_data) && length(genes) > 0 ) {
    
    ##### NOTE: when merging per-gene exprssion data with SV data from MANTA the "gene" column is used since multiple entires are possible for one gene in MANTA output
    group.z <- merge(group.z, sv_data, by.x="Gene", by.y="Gene", all = TRUE, sort = FALSE)
  }
  
  ##### Add info about known fusion genes
  if ( !is.null(fusion_genes) && length(genes) > 0 ) {
    
    group.z$Fusion_gene <- NA
    group.z$Fusion_gene[ group.z$Gene %in% fusion_genes  ] <- "Yes"
  }
  
  ##### Add cancer gene resources info
  if ( !is.null(cancer_genes) && length(genes) > 0 ) {
    
    group.z <- merge(group.z, cancer_genes, by.x="Gene", by.y="row.names", all = TRUE, sort = FALSE)
  }
  
  ##### Include only queried genes
  group.z <- group.z[ group.z$Gene %in% genes, ]
    
  group.z$SYMBOL <- group.z$Gene
  
  ##### Add links to external gene annotation resourses
  if ( ext_links && length(genes) > 0 ) {
    
    ##### Place the external links after the "Diff" column
    ##### Get the position of "Diff" column
    col_idx <- grep("Diff", names(group.z), fixed = TRUE)
    group.z <- add_column(group.z, NA, .after = col_idx)
    names(group.z)[ col_idx+1 ] <- "ext_links"
    
    for ( gene in genes ) {

      ##### Provide link to VICC meta-knowledgebase ( https://search.cancervariants.org )
      group.z$ext_links[ group.z$Gene==gene ] <- paste0("<a href='https://search.cancervariants.org/#", gene, "' target='_blank'>VICC</a>")
      
      ##### Provide link to OncoKB
      if ( gene %in% rownames(ref_genes.list[["genes_oncokb"]]) & ref_genes.list[["genes_oncokb"]][gene, "OncoKB"] == "Yes" ) {
        
        group.z$ext_links[ group.z$Gene == gene ] <- paste( group.z$ext_links[ group.z$Gene==gene ] , paste0("<a href='http://oncokb.org/#/gene/", gene, "' target='_blank'>OncoKB</a>"), sep = ", ")
      }
      
      ##### Provide link to CIViC database druggable genes ( https://civicdb.org )
      if ( gene %in% caner_genes_annot.list[["civic_clin_evid"]]$gene ) {
    
        group.z$ext_links[ group.z$Gene==gene ] <- paste( group.z$ext_links[ group.z$Gene==gene ] , paste0("<a href='", unique(caner_genes_annot.list[["civic_clin_evid"]][ caner_genes_annot.list[["civic_clin_evid"]]$gene == gene , "gene_civic_url"]), "' target='_blank'>CIViC</a>"), sep = ", ")
      }
    }
    
    names(group.z) <- gsub("ext_links", "External resources", names(group.z))
  }
  
  ##### Attach links to GeneCards and Ensembl (if provided). Here we assume that gene names are
  for ( gene in genes ) {
    
    if ( "ENSEMBL" %in% names(group.z) ) {
      
        if ( !is.na(group.z$ENSEMBL[ group.z$Gene==gene ]) ) {
          
        group.z$ENSEMBL[ group.z$Gene==gene ] <- paste0("<a href='http://ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=", group.z$ENSEMBL[ group.z$Gene==gene], "' target='_blank'>", group.z$ENSEMBL[ group.z$Gene == gene ], "</a>")
      }
    }
    
    group.z$Gene[ group.z$Gene==gene ] <- paste0("<a href='https://www.genecards.org/cgi-bin/carddisp.pl?gene=", gene, "' target='_blank'>", gene, "</a>")
  }

  ##### Order the data by CN values (to allow filtering based on CN information) and then by the highest absolute values for Patient vs [comp_cancer] difference (to allow filtering based on z-score differences)
  if ( !is.null(cn_data) && length(genes) > 0 ) {
    
    ##### Get the position of "Patient (CN)" column
    col_idx <- grep("Patient (CN)", names(group.z), fixed = TRUE)

    group.z <- group.z[ order(abs(group.z[, "Diff"]),  decreasing = TRUE), ]
    group.z <- group.z[ order(group.z[ ,col_idx ],  decreasing = cn_decrease), ]
    
  ##### Order the data by increasing TIER category (to allow filtering based on tier information) and then by the highest absolute values for "Diff" difference (to allow filtering based on z-score differences)
  } else if  ( !is.null(mut_annot) && length(genes) > 0 ) {
    
    group.z <- group.z[ order(abs(group.z[, "Diff"]),  decreasing = TRUE), ]
    group.z <- group.z[ order(group.z$TIER), ]
    
  ##### Order the data by MANTA increasing Tier (to prioritise SVs, based on https://github.com/AstraZeneca-NGS/simple_sv_annotation/blob/master/simple_sv_annotation.py), event type and then by the highest absolute values for Patient vs [comp_cancer] difference
  } else if  ( !is.null(sv_data) && length(genes) > 0 ) {
    
    group.z <- group.z[ order(abs(group.z[, "Diff"]),  decreasing = TRUE), ]
    group.z <- group.z[ order(group.z$"Fusion genes",  decreasing = TRUE), ]
    group.z <- group.z[ order(group.z$Tier), ]
    
  ##### Otherwise order table by the highest absolute values for Patient vs [comp_cancer] difference
  } else if ( length(genes) > 0 ) {
    
    group.z <- group.z[ order(abs(group.z[, "Diff"]),  decreasing = TRUE), ]
  }
  
  ##### Remove the internal reference cohort column if the patient samples origins from other tissue. Of note, the internal reference cohort was only used to process the in-house data (including the investigated patient sample) and to correct batch-effects
  if ( comp_cancer != int_cancer ) {
      
      group.z <- group.z[ , names(group.z) %!in% int_cancer ]
      targets.list[ match(int_cancer, targets.list) ] <- "Patient"
      
      ##### Get the position of "Diff" column
      diff_col_idx <- grep("Diff", names(group.z), fixed = TRUE)
      
  } else {
    
      ##### Get the position of "Diff" column
      diff_col_idx <- grep("Diff", names(group.z), fixed = TRUE)
      names(group.z)[ match("Diff", names(group.z)) ] <- paste0("Patient vs ", comp_cancer)
  }
  
  if ( !is.null(cn_data) ) {
    
    ##### Generate a table with genes annotations and coloured expression values in each group
    dt.table <- DT::datatable( data = group.z[, names(group.z) %!in% "SYMBOL"], filter="none", rownames = FALSE, extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800, caption = htmltools::tags$caption( style = 'caption-side: top; text-align: left; color:grey; font-size:100% ;'), escape = FALSE) %>%
      DT::formatStyle( columns = names(group.z)[names(group.z) %!in% "SYMBOL"], `font-size` = '12px', 'text-align' = 'center' ) %>%
      
      ##### Colour cells according to the expression values quantiles in each group
      DT::formatStyle(columns = targets.list[1], 
                      backgroundColor = DT::styleInterval(brks.q[[targets.list[1]]], clrs.q[[targets.list[1]]])) %>%
      DT::formatStyle(columns = targets.list[2], 
                      backgroundColor = DT::styleInterval(brks.q[[targets.list[2]]], clrs.q[[targets.list[2]]])) %>%
      DT::formatStyle(columns = targets.list[3], 
                      backgroundColor = DT::styleInterval(brks.q[[targets.list[3]]], clrs.q[[targets.list[3]]])) %>%
      DT::formatStyle(columns = names(group.z)[diff_col_idx], 
                      backgroundColor = DT::styleInterval(brks.q[["Diff"]], clrs.q[["Diff"]])) %>%
      DT::formatStyle(columns = "Patient (CN)", background = DT::styleColorBar(cn_range, 'lightblue'), backgroundSize = '98% 88%', backgroundRepeat = 'no-repeat', backgroundPosition = 'center')
    
  } else {
    
    ##### Generate a table with genes annotations and coloured expression values in each group
    dt.table <- DT::datatable( data = group.z[, names(group.z) %!in% "SYMBOL"], filter="none", rownames = FALSE, extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800, caption = htmltools::tags$caption( style = 'caption-side: top; text-align: left; color:grey; font-size:100% ;'), escape = FALSE) %>%
      DT::formatStyle( columns = names(group.z)[names(group.z) %!in% "SYMBOL"], `font-size` = '12px', 'text-align' = 'center' ) %>%
      
      ##### Colour cells according to the expression values quantiles in each group
      DT::formatStyle(columns = targets.list[1], 
                      backgroundColor = DT::styleInterval(brks.q[[targets.list[1]]], clrs.q[[targets.list[1]]])) %>%
      DT::formatStyle(columns = targets.list[2], 
                      backgroundColor = DT::styleInterval(brks.q[[targets.list[2]]], clrs.q[[targets.list[2]]])) %>%
      DT::formatStyle(columns = targets.list[3], 
                      backgroundColor = DT::styleInterval(brks.q[[targets.list[3]]], clrs.q[[targets.list[3]]])) %>%
      DT::formatStyle(columns = names(group.z)[diff_col_idx], 
                      backgroundColor = DT::styleInterval(brks.q[["Diff"]], clrs.q[["Diff"]]))
  }
  
  return( list(dt.table,  group.z) )
}

##### Generate table with drugs targeting selected set of genes using info from CIViC database (https://civicdb.org/)
civicDrugTable <- function(genes, civic_var_summaries, civic_clin_evid, evid_type = "Predictive", var_type = NULL) {
  
  ##### Initialize data frame to the about drug-target info from CIViC
  drug.info <- setNames(data.frame(matrix(ncol = 18, nrow = 0)), c("Gene", "Variant", "variant_types", "drugs", "nct_ids", "evidence_level", "evidence_type", "evidence_direction", "clinical_significance", "rating", "civic_actionability_score", "Disease", "phenotypes", "pubmed_id", "variant_origin", "representative_transcript", "representative_transcript2", "last_review_date"))
  
  evid_levels <- list("A" = "A: Validated association", "B" = "B: Clinical evidence", "C" = "C: Case study", "D" = "D: Preclinical evidence", "E" = "E: Inferential association")
  
  ##### Loop thourgh each gene and check if they are druggable
  for ( gene in genes) {
    
    ##### Get summary info about druggable genes
    if ( gene %in% civic_clin_evid$gene ) {
      
      ##### Extract info about all reported variants's clinical evidence for queried gene
      clin.evid.info <- civic_clin_evid[ civic_clin_evid$gene == gene , ]

      ##### Use more descriptive evidence level info
      for ( level in unique(clin.evid.info$evidence_level) ) {
        
        clin.evid.info$evidence_level[ clin.evid.info$evidence_level == level ] <- evid_levels[[ level ]]
      }
      
      ##### Subset table to include only variants with the evidence type of interest
      clin.evid.info <- clin.evid.info[ clin.evid.info$evidence_type == evid_type,  ]
        
      if ( nrow(clin.evid.info) > 0 ) {
        
        ##### Provide link to CIViC clinical evidence summary
        clin.evid.info$drugs <- paste0("<a href='", clin.evid.info$evidence_civic_url, "' target='_blank'>", clin.evid.info$drugs, "</a>")
        
        ##### Provide link to CIViC clinical evidence summary
        clin.evid.info$evidence_type <- paste0("<a href='", clin.evid.info$evidence_civic_url, "' target='_blank'>", clin.evid.info$evidence_type, "</a>")
        
        ##### Provide link to CIViC gene summary
        clin.evid.info$gene_civic_url <- paste0("<a href='", clin.evid.info$gene_civic_url, "' target='_blank'>", gene, "</a>")
        names(clin.evid.info)[ names(clin.evid.info) =="gene_civic_url" ] <- "Gene"
        
        ##### Provide link to CIViC variants summary
        clin.evid.info$variant_civic_url <- paste0("<a href='", clin.evid.info$variant_civic_url, "' target='_blank'>", clin.evid.info$variant, "</a>")
        names(clin.evid.info)[ names(clin.evid.info) =="variant_civic_url" ] <- "Variant"
        
        ##### Provide link to ClinicalTrials.gov variants summary based on NCT IDs
        for ( nct_id in clin.evid.info$nct_ids ) {
          
          if ( !is.empty(nct_id) ) {
            
            ##### Deal with multiple NCT IDs (separated by comma)
            nct_id_url <- gsub(" '" , "'", paste(gsub("/ " , "/", paste("<a href='https://clinicaltrials.gov/ct2/show/", unlist(strsplit(nct_id, split=",", fixed=TRUE)) , "' target='_blank'>", unlist(strsplit(nct_id, split=",", fixed=TRUE)), "</a>")), collapse = ", "))
            clin.evid.info$nct_ids[ clin.evid.info$nct_ids==nct_id ] <- nct_id_url
          }
        }
        
        ##### Provide link to PubMed variants summary
        clin.evid.info$pubmed_id <- paste0("<a href='https://www.ncbi.nlm.nih.gov/pubmed/", clin.evid.info$pubmed_id, "' target='_blank'>", clin.evid.info$pubmed_id, "</a>")
        
        ##### Provide link to Disease Ontology
        clin.evid.info$doid <- paste0("<a href='http://www.disease-ontology.org/?id=DOID:", clin.evid.info$doid, "' target='_blank'>", clin.evid.info$disease, "</a>")
        names(clin.evid.info)[ names(clin.evid.info) =="doid" ] <- "Disease"
        
        ##### Extract info about all variants it that gene
        var.info <- civic_var_summaries[ civic_var_summaries$gene == gene , ]
        var.info <- var.info[, c("variant", "variant_types", "civic_actionability_score")]
        var.info[,"variant_types"] <- gsub("_", " ", var.info[,"variant_types"])
        var.info[,"variant_types"] <- gsub(",", ", ", var.info[,"variant_types"])
        
        ##### Merge about all variants it that gene and clinical evidence info
        clin.evid.info <- merge(clin.evid.info, var.info, by = "variant", all.x = TRUE)
        
        ##### Filter drug matching info depending on the variant type
        var_type.keep <- NULL
        
        if ( !is.null(var_type) && var_type == "mutation" ) {
          
          ##### Remove entries containing "EXPRESSION", "AMPLIFICATION", "DELETION", "METHYLATION", "WILD TYPE", "FUSION", "COPY", "REARRANGEMENT", "PHOSPHORYLATION", "TRANSCRIPT", "GAIN", "LOSS"
          var_type.keep <- c(var_type.keep, grep( "EXPRESSION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "AMPLIFICATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "DELETION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "METHYLATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "WILD TYPE", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "FUSION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "REARRANGEMENT", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "PHOSPHORYLATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "COPY", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "TRANSCRIPT", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "GAIN", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "LOSS", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          
          clin.evid.info <- clin.evid.info[ -c(unique(var_type.keep)), ]
          
        } else if ( !is.null(var_type) && var_type == "expression" ) {
          
          ##### Keep only entries containing "EXPRESSION", "FUSION", "TRANSCRIPT", "ALTERATION"
          var_type.keep <- c(var_type.keep, grep( "EXPRESSION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "FUSION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "TRANSCRIPT", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "ALTERATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          
          clin.evid.info <- clin.evid.info[ c(unique(var_type.keep)), ]
          
        } else if ( !is.null(var_type) && var_type == "fusion" ) {
          
          ##### Keep only entries containing "FUSION", "ALTERATION", "[gene]-", "-[gene]"
          
          ##### Keep only entries containing "FUSION", "ALTERATION", "-"
          var_type.keep <- c(var_type.keep, grep( "FUSION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( paste0(gene, "-"), clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( paste0("-", gene), clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "ALTERATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          
          clin.evid.info <- clin.evid.info[ c(unique(var_type.keep)), ]
          
        } else if ( !is.null(var_type) && var_type == "copy_gain" ) {
          
          ##### Keep only entries containing "AMPLIFICATION", "COPY", "GAIN", "ALTERATION"
          var_type.keep <- c(var_type.keep, grep( "AMPLIFICATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "COPY", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "GAIN", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "ALTERATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          
          clin.evid.info <- clin.evid.info[ c(unique(var_type.keep)), ]
          
        } else if ( !is.null(var_type) && var_type == "copy_loss" ) {
          
          ##### Keep only entries containing "DELETION", "COPY", "LOSS", "ALTERATION"
          var_type.keep <- c(var_type.keep, grep( "DELETION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "COPY", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "LOSS", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "ALTERATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          
          clin.evid.info <- clin.evid.info[ c(unique(var_type.keep)), ]
        }
      }
      
      if ( nrow(clin.evid.info) > 0 ) {
        
        ##### Subset table to include only most important info
        clin.evid.info <- clin.evid.info[ , names(drug.info)]
        
        ##### Add drugs info for subsequent gene
        drug.info <- rbind(drug.info, clin.evid.info)
      }
    }
  }
  
  ##### Use more friendly column names for the table
  names(drug.info) <- c("Gene", "Variant", "Variant type", "Drugs", "Clinical trials", "Evidence level", "Evidence type", "Evidence direction", "Clinical significance", "Trust rating", "Actionability score", "Disease", "Phenotypes", "PubMed ID",  "Variant origin", "Representative transcript", "Representative transcript 2", "Review date")
  
  ##### Limit the info to fewer columns
  drug.info <- drug.info[ , c("Gene", "Variant", "Variant type", "Drugs", "Clinical trials", "Evidence level", "Evidence direction", "Clinical significance", "Trust rating", "Actionability score", "Disease", "Phenotypes", "PubMed ID",  "Representative transcript", "Representative transcript 2")] 
  
  ##### Generate a table
  dt.table <- DT::datatable( data = drug.info, filter = "none", rownames = FALSE, extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left; color:grey; font-size:100% ;'), escape = FALSE) %>%
    DT::formatStyle( columns = names(drug.info), `font-size` = '12px', 'text-align' = 'center' ) %>%
    
    ##### Colour cells according to evidence level and trust rating
    DT::formatStyle(columns = "Evidence level", 
                    backgroundColor = DT::styleEqual(c("A: Validated association", "B: Clinical evidence", "C: Case study", "D: Preclinical evidence", "E: Inferential association"), c("mediumseagreen", "deepskyblue", "mediumpurple", "darkorange", "coral")) )  %>%
    #DT::formatStyle(columns = "Trust rating", 
    #                backgroundColor = DT::styleEqual(c(1:5), c(rev(round(seq(0, 200, length.out = 5), 0) %>%  {paste0("rgb(", .,",200,", ., ")")}))) )
    DT::formatStyle(columns = "Trust rating", 
                    backgroundColor = DT::styleEqual(c(1:5), c("coral", "azure", "lightskyblue", "palegreen", "mediumseagreen")) )
  
  return( list(dt.table,  drug.info) )
}

##### Generate bezier curves-like plot representing gene fusion events
fusionsBezierPlot <- function(fusion_annot, genes_annot) {
  
  ##### Get the genes chromosomes...
  chr1 <- paste0("chr", fusion_annot$SEQNAME)
  chr2 <- paste0("chr", fusion_annot$SEQNAME.1)
  
  ##### ...positions
  pos1 <- fusion_annot$GENESEQSTART
  pos2 <- fusion_annot$GENESEQSTART.1
  
  ##### ... and the events type
  type <- paste( fusion_annot$reported_fusion, fusion_annot$fusions_abundant, fusion_annot$geneA_dna_support, fusion_annot$geneB_dna_support, sep = "-") 
  type <- gsub("Yes-Yes-Yes-Yes","Reported fusion, abundant and DNA-supported gene(s)", type)
  type <- gsub("Yes-Yes---Yes","Reported fusion, abundant and DNA-supported gene(s)", type)
  type <- gsub("Yes-Yes-Yes--","Reported fusion, abundant and DNA-supported gene(s)", type)
  type <- gsub("Yes-Yes----","Reported fusion and abundant gene(s)", type)
  type <- gsub("Yes---Yes-Yes","Reported fusion and DNA-supported gene(s)", type)
  type <- gsub("Yes---Yes--","Reported fusion and DNA-supported gene(s)", type)
  type <- gsub("Yes-----Yes","Reported fusion and DNA-supported gene(s)", type)
  type <- gsub("Yes------","Reported fusion", type)
  type <- gsub("--Yes-Yes-Yes","Abundant and DNA-supported gene(s)", type)
  type <- gsub("--Yes-Yes--","Abundant and DNA-supported gene(s)", type)
  type <- gsub("--Yes---Yes","Abundant and DNA-supported gene(s)", type)
  type <- gsub("--Yes----","Abundant gene(s)", type)
  type <- gsub("----Yes-Yes","DNA-supported gene(s)", type)
  type <- gsub("----Yes--","DNA-supported gene(s)", type)
  type <- gsub("------Yes","DNA-supported gene(s)", type)
  type <- gsub("-------","Other", type)

  #### Prepare x-axis coordinates info for ggplot
  ##### This part of the script converts the genomic positions from hg38 to coordinates that can be plotted on the ggplot x-axis.
  ##### Start with calculating the whole genome length. Here we consider chromosomes 1-22, X and Y
  genome.length <- sum(seqlengths(Hsapiens)[1:24])
  
  ##### Now calculate fake chromosomes' start positions so that they match with the x-axis coordinates in the ggplot
  chrs_fake_starts <- vector("list", 24)
  chrs_fake_starts  <- setNames(chrs_fake_starts,  names(Hsapiens)[1:24] )
  
  ##### Chromosome 1 has coordingate 0
  chrs_fake_starts[["chr1"]] <- 0
  
  ##### The coordinates for the remaining chromosomes will be calculated by adding the lengths of individual preceding chromosomes
  length_sum <- 0
  for ( i in 2:length(chrs_fake_starts) ) {
  	#cat(paste("\nThe fake start position for " , names(chrs_fake_starts)[i], " is ", length_sum + as.numeric(seqlengths(Hsapiens)[[i-1]]), sep=""))
  #	cat(paste("\nLength of " , names(chrs_fake_starts)[i-1], " = ", as.numeric(seqlengths(Hsapiens)[[i-1]]), " and the sum of the preceding chromosomes = ", length_sum, ".\n\n", sep=""))
  	length_sum <- length_sum + as.numeric(seqlengths(Hsapiens)[[i-1]])
  	chrs_fake_starts[[names(Hsapiens)[i]]] <- length_sum
  }
  
  ##### Calculate the coordinates for x-axis labels (chr1, chr2...) for ggplot by adding the half-lenght of each chrosomome to its fake start
  chrs_fake_label.pos <- vector("list", 24)
  chrs_fake_label.pos  <- setNames(chrs_fake_label.pos,  names(Hsapiens)[1:24] )
  for ( i in 1:length(chrs_fake_starts) ) {
  	chrs_fake_label.pos[[names(Hsapiens)[i]]] <- seqlengths(Hsapiens)[[i]]/2 + chrs_fake_starts[[names(Hsapiens)[i]]]
  	# cat(paste("\nThe x-axis coordinate for " , names(chrs_fake_starts)[i], " label is ", chrs_fake_label.pos[[names(Hsapiens)[i]]], " = ",  seqlengths(Hsapiens)[[i]]/2, " (half-length) + ", chrs_fake_starts[[names(Hsapiens)[i]]]," (fake start)", sep=""))
  }
  
  #### Calculate ggplot x-axis coordinates for fusion events
  ##### Calculate the coordinates to draw bezier curves by adding the fusion events position info to the fake start coordinates of corresponding chromosomes
  pos1_fake <- vector("list", nrow(fusion_annot))
  pos2_fake <- vector("list", nrow(fusion_annot))
  
  for ( i in 1:nrow(fusion_annot) ) {

  	pos1_fake[[i]] <- chrs_fake_starts[[chr1[i]]] + pos1[i]
  	pos2_fake[[i]] <- chrs_fake_starts[[chr2[i]]] + pos2[i]
  }
  
  ##### Get random number for the bezier curves' heigths and caluclate the middle point for each bezier curve
  beziers.height <- runif(nrow(fusion_annot), 1, 2)
  beziers.mid <- unlist(pos1_fake)+(unlist(pos2_fake)-unlist(pos1_fake))/2
  
  ##### Create data-frame with beziers curves info
  beziers <- data.frame(
      x = c(rbind( unlist(pos1_fake), beziers.mid, unlist(pos2_fake) )),
      y = c(rbind( 0.2, beziers.height, 0.2 ) ),
      type = rep( paste( chr1, make.names(pos1, unique=TRUE), chr2, make.names(pos2, unique=TRUE), sep="_" ), each=3),
  		group = rep( type, each=3)
  )
  
  ##### Generate a bezier curves-like plot representing fusion events
  p <- ggplot() + geom_bezier(aes(x= x, y = y, group = type, color = group ), data = beziers, show.legend = TRUE, size = 0.2) +
  		##### Remove default axes labels and grey backgroud
  		theme(axis.title.x=element_blank(), axis.text.x= element_blank(), axis.ticks.x=element_blank(), axis.title.y=element_blank(), axis.text.y= element_blank(), axis.ticks.y=element_blank(),
  		##### ...and the grey backgroud
  					panel.background = element_rect(fill = NA),
  		##### ...change the legend parameters
  					legend.title=element_text(size=6), legend.text=element_text(size=10), legend.key.size = unit(1,"line"), legend.key= element_blank(), legend.position = c(0.8,0.65) ) +
  		##### Set the axes limits
  		scale_x_continuous(limits = c(1, genome.length)) +
  		scale_y_continuous(limits = c(0, 2)) +
  		##### Add chromosomes boundaries
  		geom_segment(aes(x = c(1,unlist(chrs_fake_starts)[2:24],genome.length) , xend = c(1,unlist(chrs_fake_starts)[2:24],genome.length), y = 0, yend = 0.2), colour = 'grey', size = 0.2) +
  		labs( color = "") +
  		##### Add chromosomes labels
  		annotate(geom = 'text', label = names(chrs_fake_label.pos), x = unlist(chrs_fake_label.pos), y = 0.1, size = 2, angle = 45)
      ##### Add gene fusion labels
      #annotate(geom = 'text', label = paste(fusion_annot$fusion_data.geneA.name, fusion_annot$fusion_data.geneB.name, sep="-"), x = beziers.mid, y = beziers.height-0.5, size = 1.5)
  
  return( p )
}

sv_prioritize_short <- function(sv_file) {
  
  col_types <- "ccciicccccc"
  sv_all = NULL
  
  if (length(readLines(con = sv_file, n = 2)) > 1) {
    sv_all <- readr::read_tsv(sv_file, col_names = TRUE, col_types = col_types) %>%
      tidyr::unnest(annotation = strsplit(annotation, ',')) %>% # Unpack multiple annotations per region
      tidyr::separate(annotation,
                      c('Event', 'Annotation', 'Gene', 'Transcript', 'Priority', 'Tier'),
                      sep = '\\|', convert = TRUE) %>% # Unpack annotation columns %>%
      dplyr::mutate(start = format(start, big.mark = ',', trim = T),
                    end = format(end, big.mark = ',', trim = T)) %>% 
      dplyr::mutate(Location = str_c(chrom, ':', start, sep = ''),
                    Location = ifelse(is.na(end), Location, str_c(Location))) %>%
      dplyr::mutate(SR = split_read_support, PR = paired_support_PR) %>%
      dplyr::select(Location, Gene, Priority, Tier, Annotation, Event, SR, PR) %>%
      dplyr::distinct()
      # dplyr::mutate(Chrom = factor(Chrom, levels = c(1:22, "X", "Y", "MT")))
  }
  return( sv_all )
}
  
##### Code from UMCCRISE to prioritise SV events https://github.com/umccr/umccrise/blob/master/umccrise/rmd_files/index.Rmd
sv_prioritize <- function(sv_file) {
  
  col_types <- "ccciiccccciiccccdl"
  sv_all = NULL

  if (length(readLines(con = sv_file, n = 2)) > 1) {
    
    sv_all <- readr::read_tsv(sv_file, col_names = TRUE, col_types = col_types) %>%
      dplyr::select(-caller, -sample) %>% 
      split_sv_field(BPI_AF, is_pct = T) %>% 
      split_sv_field(AF, is_pct = T) %>% 
      split_sv_field(CN) %>% 
      split_sv_field(CN_change) %>% 
      dplyr::mutate(
        Ploidy = as.double(Ploidy),
        Ploidy = format(Ploidy, nsmall = 2)
      ) %>% 
      tidyr::separate(split_read_support, c("SR (alt)", "SR (ref)"), ",") %>% 
      dplyr::mutate(SR = as.integer(`SR (alt)`)) %>% 
      tidyr::separate(paired_support_PR, c("PR (alt)", "PR (ref)"), ",") %>% 
      dplyr::mutate(PR = as.integer(`PR (alt)`)) %>% 
      tidyr::separate(paired_support_PE, c("PE (alt)", "PE (ref)"), ",") %>% 
      dplyr::mutate(PE = as.integer(`PE (alt)`)) %>% 
      
      dplyr::filter(svtype != 'BND' | is.na(SR) | PR>SR) %>%  # remove BND with split read support higher than paired
      
      tidyr::unnest(annotation = strsplit(annotation, ',')) %>%  # Unpack multiple annotations per region
      tidyr::separate(annotation,
                      c('event', 'effect', 'genes', 'transcript', 'detail', 'tier'),
                      sep = '\\|', convert = TRUE) %>%  # Unpack annotation columns
    
      dplyr::mutate(start = format(start, big.mark = ',', trim = T),
                    end = format(end, big.mark = ',', trim = T)) %>% 
      dplyr::mutate(location = str_c(chrom, ':', start, sep = ''),
                    location = ifelse(is.na(end), location, str_c(location))) %>% 
      dplyr::arrange(tier, effect, desc(AF), genes) %>% 
          
      dplyr::mutate(Gene = subset_genes(genes, c(1, 2)),
                    Gene = ifelse((str_split(genes, '&') %>% map_int(length)) > 2,
                                  str_c(Gene, '...', sep = ', '),
                                  Gene),
                    `Other affected genes` = subset_genes(genes, -c(1,2)) %>% str_replace_all('&', ', '),
                    Gene = ifelse(str_detect(effect, "gene_fusion"),
                                  Gene,
                                  Gene %>% str_replace_all('&', ', '))
                    ) %>% 
      separate(effect, c("Effect", "Other effects"), sep = '&') %>% 
      dplyr::select(Tier = tier, Event = svtype, Gene, Effect = Effect, Detail = detail, Location = location, AF, `CN chg` = CN_change, SR, PR, CN, Ploidy, PURPLE_status, `SR (ref)`, `PR (ref)`, PE, `PE (ref)`, `Somatic score` = somaticscore, Transcript = transcript, `Other effects`, `Other affected genes`, `AF at breakpoint 1` = AF1, `AF at breakpoint 2` = AF2, `CN at breakpoint 1` = CN1, `CN at breakpoint 2` = CN2, `CN change at breakpoint 1` = CN_change1, `CN change at breakpoint 2` = CN_change2, `AF before adjustment, bp 1` = BPI_AF1, `AF before adjustment, bp 2` = BPI_AF2
      ) %>%
      dplyr::distinct()
      # dplyr::mutate(chr = factor(chr, levels = c(1:22, "X", "Y", "MT"))) %>%

  } else {
    warning('No prioritized events detected')
  }
  return( sv_all )
}

##### Function used in the "sv_prioritize" function
subset_genes = function(genes, ind) {
  genes %>% str_split('&') %>% map(~ .[ind] %>% replace("", NA) %>% .[!is.na(.)]) %>% map_chr(~ ifelse(length(.) > 0, str_c(., collapse = '&'), ""))
}

##### Function used in the "sv_prioritize" function
format_val = function(val, is_pct = F) {
  ifelse(!is.na(val), 
         format(val,  digits = 1) %>% str_c(ifelse(is_pct, "%", "")), 
         NA)
}

##### Function used in the "sv_prioritize" function 
split_sv_field = function(.data, field, is_pct = F) {
  f_q = rlang::enquo(field)
  f_str = rlang::quo_name(f_q)
  f1_str = str_c(f_str, '1')
  f2_str = str_c(f_str, '2')
  f1_q = sym(f1_str)
  f2_q = sym(f2_str)
  .data %>% 
    separate(!!f_q, c(f1_str, f2_str), ",") %>% 
    dplyr::mutate(
      !!f1_q := as.double(!!f1_q) * ifelse(is_pct, 100, 1),
      !!f2_q := as.double(!!f2_q) * ifelse(is_pct, 100, 1),
      !!f_q  := (!!f1_q + ifelse(is.na(!!f2_q), !!f1_q, !!f2_q)) / 2,
      !!f_q  := format_val(!!f_q, is_pct),
      !!f1_q := format_val(!!f1_q, is_pct),
      !!f2_q := format_val(!!f2_q, is_pct)
    )
}
```

```{r plot_thumbnail, comment=NA, message=FALSE, warning=FALSE}
##### Generate a full-resolution pdf image before generating a small image in the chunk
knitr::knit_hooks$set(plot = allow_thumbnails)
```

```{r load_libraries, warning=FALSE}
##### Load libraries
suppressMessages(library(edgeR))
suppressMessages(library(limma))
suppressMessages(library(rapportools))
suppressMessages(library(openxlsx))
suppressMessages(library(readr))
suppressMessages(library(tidyverse))
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))
suppressMessages(library(rlang))
suppressMessages(library(DT))
suppressMessages(library(kableExtra))
suppressMessages(library(matrixStats))
suppressMessages(library(tibble))
suppressMessages(library(knitr))
suppressMessages(library(ggplot2))
suppressMessages(library(ggforce))
suppressMessages(library(pdftools))
suppressMessages(library(png))
suppressMessages(library(htmltools))
suppressMessages(library(htmlwidgets))
suppressMessages(library(devtools))
suppressMessages(library(lares))
suppressMessages(library(tximport))
suppressMessages(library(package=paste0("EnsDb.Hsapiens.v", params$ensembl_version), character.only = TRUE))
suppressMessages(library(package=paste0("BSgenome.Hsapiens.UCSC.hg", params$ucsc_genome_assembly), character.only = TRUE)) # required to get chromosomes lengts for fusionsBezierPlot function generating Bezier plot to present gene fusions in the genomics context
```

```{r define_parameters, message=FALSE, warning=FALSE}
##### Define Z-transformation direction
if (tolower(params$scaling) == "gene-wise"){
      
  scaling <- "gene-wise"
} else {
  scaling <- "group-wise"
}
```

```{r load_ref_data, message=FALSE, warning=FALSE}
##### Load reference datasets
##### Define the reference datasets based on user-defined input
ref_dataset <- list( "paad" = c(paste(params$ref_data_dir, "Datasets_list_PAAD.txt", sep="/"), "PDAC (UMCCR)", "PDAC (TCGA)"), 
                     "cesc" = c(paste(params$ref_data_dir, "Datasets_list_CESC.txt", sep="/"), "PDAC (UMCCR)", "CESC (TCGA)"), 
                     "blca" = c(paste(params$ref_data_dir, "Datasets_list_BLCA.txt", sep="/"), "PDAC (UMCCR)", "BLCA (TCGA)"),
                     "brca" = c(paste(params$ref_data_dir, "Datasets_list_BRCA.txt", sep="/"), "PDAC (UMCCR)", "BRCA (TCGA)"),
                     "thca" = c(paste(params$ref_data_dir, "Datasets_list_THCA.txt", sep="/"), "PDAC (UMCCR)", "THCA (TCGA)"),
                     "hnsc" = c(paste(params$ref_data_dir, "Datasets_list_HNSC.txt", sep="/"), "PDAC (UMCCR)", "HNSC (TCGA)"),
                     "lgg" = c(paste(params$ref_data_dir, "Datasets_list_LGG.txt", sep="/"), "PDAC (UMCCR)", "LGG (TCGA)"),
                     "kirc" = c(paste(params$ref_data_dir, "Datasets_list_KIRC.txt", sep="/"), "PDAC (UMCCR)", "KIRC (TCGA)"),
                     "lusc" = c(paste(params$ref_data_dir, "Datasets_list_LUSC.txt", sep="/"), "PDAC (UMCCR)", "LUSC (TCGA)"),
                     "luad" = c(paste(params$ref_data_dir, "Datasets_list_LUAD.txt", sep="/"), "PDAC (UMCCR)", "LUAD (TCGA)"),
                     "prad" = c(paste(params$ref_data_dir, "Datasets_list_PRAD.txt", sep="/"), "PDAC (UMCCR)", "PRAD (TCGA)"),
                     "skcm" = c(paste(params$ref_data_dir, "Datasets_list_SKCM.txt", sep="/"), "PDAC (UMCCR)", "SKCM (TCGA)"),
                     "stad" = c(paste(params$ref_data_dir, "Datasets_list_STAD.txt", sep="/"), "PDAC (UMCCR)", "STAD (TCGA)"),
                     "lihc" = c(paste(params$ref_data_dir, "Datasets_list_LIHC.txt", sep="/"), "PDAC (UMCCR)", "LIHC (TCGA)"),
                     "coad" = c(paste(params$ref_data_dir, "Datasets_list_COAD.txt", sep="/"), "PDAC (UMCCR)", "COAD (TCGA)"),
                     "kirp" = c(paste(params$ref_data_dir, "Datasets_list_KIRP.txt", sep="/"), "PDAC (UMCCR)", "KIRP (TCGA)"),
                     "ov" = c(paste(params$ref_data_dir, "Datasets_list_OV.txt", sep="/"), "PDAC (UMCCR)", "OV (TCGA)"),
                     "sarc" = c(paste(params$ref_data_dir, "Datasets_list_SARC.txt", sep="/"), "PDAC (UMCCR)", "SARC (TCGA)"),
                     "pcpg" = c(paste(params$ref_data_dir, "Datasets_list_PCPG.txt", sep="/"), "PDAC (UMCCR)", "PCPG (TCGA)"),
                     "ucec" = c(paste(params$ref_data_dir, "Datasets_list_UCEC.txt", sep="/"), "PDAC (UMCCR)", "UCEC (TCGA)"),
                     "laml" = c(paste(params$ref_data_dir, "Datasets_list_LAML.txt", sep="/"), "PDAC (UMCCR)", "LAML (TCGA)"),
                     "esca" = c(paste(params$ref_data_dir, "Datasets_list_ESCA.txt", sep="/"), "PDAC (UMCCR)", "ESCA (TCGA)"),
                     "gbm" = c(paste(params$ref_data_dir, "Datasets_list_GBM.txt", sep="/"), "PDAC (UMCCR)", "GBM (TCGA)"),
                     "tgct" = c(paste(params$ref_data_dir, "Datasets_list_TGCT.txt", sep="/"), "PDAC (UMCCR)", "TGCT (TCGA)"),
                     "thym" = c(paste(params$ref_data_dir, "Datasets_list_THYM.txt", sep="/"), "PDAC (UMCCR)", "THYM (TCGA)"),
                     "read" = c(paste(params$ref_data_dir, "Datasets_list_READ.txt", sep="/"), "PDAC (UMCCR)", "READ (TCGA)"),
                     "kich" = c(paste(params$ref_data_dir, "Datasets_list_KICH.txt", sep="/"), "PDAC (UMCCR)", "KICH (TCGA)"),
                     "uvm" = c(paste(params$ref_data_dir, "Datasets_list_UVM.txt", sep="/"), "PDAC (UMCCR)", "UVM (TCGA)"),
                     "meso" = c(paste(params$ref_data_dir, "Datasets_list_MESO.txt", sep="/"), "PDAC (UMCCR)", "MESO (TCGA)"),
                     "acc" = c(paste(params$ref_data_dir, "Datasets_list_ACC.txt", sep="/"), "PDAC (UMCCR)", "ACC (TCGA)"),
                     "ucs" = c(paste(params$ref_data_dir, "Datasets_list_UCS.txt", sep="/"), "PDAC (UMCCR)", "UCS (TCGA)"),
                     "dlbc" = c(paste(params$ref_data_dir, "Datasets_list_DLBC.txt", sep="/"), "PDAC (UMCCR)", "DLBC (TCGA)"),
                     "chol" = c(paste(params$ref_data_dir, "Datasets_list_CHOL.txt", sep="/"), "PDAC (UMCCR)", "CHOL (TCGA)")
)

dataset <- tolower(params$dataset)
int_cancer_group <- ref_dataset[[dataset]][2]
ext_cancer_group <- ref_dataset[[dataset]][3]

##### Define the cancer group to be used to compare per-gene expression values and report in the summary tables
if ( dataset == "paad" ) {
  
  comp_cancer_group <- int_cancer_group
  
} else {
  comp_cancer_group <- ext_cancer_group
}

##### Create a list with reference datasets
ref_datasets <- c(dataset)
ref_datasets.list <- vector("list", length(ref_datasets))
names(ref_datasets.list) <- ref_datasets

##### Create a list with various sets of genes
ref_genes <- c("genes_cancer", "oncokb_genes", "genes_immune", "genes_hrd")
ref_genes.list <- vector("list", length(ref_genes))
names(ref_genes.list) <- ref_genes

##### Create a list with cancer genes annotations
caner_genes_annot <- c("oncokb_clin_vars", "oncokb_all_vars")
caner_genes_annot.list <- vector("list", length(caner_genes_annot))
names(caner_genes_annot.list) <- caner_genes_annot

##### Get patient data dir and sample file name
dataDir <- unlist(strsplit(params$count_file, split='/', fixed=TRUE))
dataDir <- paste(dataDir[-c(length(dataDir), length(dataDir)-1)], collapse ="/")
##### Getting sample name from the params - which now SHOULD be pre-defined
sampleName <- params$sample_name

##### Read-in the annotation file for tximport
tx2ensembl <- read.csv(file.path(params$annot_file), header = FALSE)
colnames(tx2ensembl) <- c("tx_name", "gene_id")

##### Look at countsFromAbundance parameter to change the method to generate the counts
txi.kallisto <- tximport(params$count_file, type = "kallisto", tx2gene = tx2ensembl)

##### Extract salmon counts to prepare dataframe
kallisto.counts <- as.data.frame(txi.kallisto$counts) %>%
  tibble::rownames_to_column() %>%
  dplyr::rename(count = V1)

##### Create directory for results
if ( !file.exists(params$report_dir) ) {

  dir.create(params$report_dir, recursive=TRUE)
}

##### Read in reference datasets and merge them with sample data. This part outputs a vector with first element containing the merged data and second element containing merged targets info
ref_datasets.list[[dataset]] <- combineDatasets(sample_name=params$sample_name, sample_counts=kallisto.counts, ref_dataset=ref_dataset[[dataset]][1])
names(ref_datasets.list[[dataset]]) <- c("combined_data", "sample_annot")

##### Check if spreadsheet with clinical information exists
clinical_info_file <- params$clinical_info
runClinicalChunk <- TRUE

if ( file.exists(clinical_info_file) ) {
  
  ref_datasets.list[[dataset]][["clinical_info"]] <- read.xlsx(xlsxFile = clinical_info_file, sheet = 1, colNames = TRUE, rowNames = FALSE, detectDates = TRUE, skipEmptyRows = TRUE, skipEmptyCols = TRUE, check.names = TRUE)
  
} else {
  runClinicalChunk <- FALSE
}

##### Read in selected genes list
ref_genes.list[["genes_cancer"]] <- read.table(paste(params$ref_data_dir, params$genes_cancer, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="")
ref_genes.list[["genes_oncokb"]] <- read.table(paste(params$ref_data_dir, params$oncokb_genes, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="", comment.char = "")
ref_genes.list[["genes_immune"]] <- read.table(paste(params$ref_data_dir, params$genes_immune, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="")
ref_genes.list[["genes_hrd"]] <- read.table(paste(params$ref_data_dir, params$genes_hrd, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="")

##### Read in gene fusion data for investigate sample
##### Read in the pizzly fusion calls
##### Check if pizzly output file exists
pizzly_file <- paste(dataDir, "pizzly", paste0(sampleName, "-flat.tsv"), sep = "/")

if ( file.exists(pizzly_file) ) {
  
  ref_genes.list[["pizzly"]] <- read.table(file = pizzly_file, header = TRUE)
}

##### Read in the quantification file from kallisto
##### ... but first check if kallisto re-quntified transcripts file is available
kallisto_file <- paste(dataDir, "kallisto/quant_pizzly_post/abundance.tsv", sep = "/")
runKallistoChunk <- TRUE
runFusionChunk <- TRUE

if ( file.exists(kallisto_file) ) {

ref_genes.list[["kallisto"]] <- read.table(kallisto_file, header = TRUE)

} else {
  
  ref_genes.list[["kallisto"]] <- NULL
  runKallistoChunk <- FALSE
  runClinkerChunk <- FALSE
  runFusionChunk <- FALSE
}

##### Read in mutation data for investigate sample
##### Get the genomic output data from umccrise
umccrise <- unlist(strsplit(params$umccrise, split='/', fixed=TRUE))
umccrise <- umccrise[length(umccrise)]

##### Check if PCGR (mutation) output file exists
runPcgrChunk <- TRUE

if ( file.exists(paste(params$umccrise, "pcgr", paste0(umccrise, "-somatic.pcgr_acmg.grch37.snvs_indels.tiers.tsv"), sep = "/")) ) {
  
pcgr_file <- paste(params$umccrise, "pcgr", paste0(umccrise, "-somatic.pcgr_acmg.grch37.snvs_indels.tiers.tsv"), sep = "/")

} else if ( file.exists(paste(params$umccrise, "pcgr", paste0(umccrise, "-somatic.pcgr.snvs_indels.tiers.tsv"), sep = "/")) ) {
  
  pcgr_file <- paste(params$umccrise, "pcgr", paste0(umccrise, "-somatic.pcgr.snvs_indels.tiers.tsv"), sep = "/")
  
} else {
  runPcgrChunk <- FALSE
}

if ( runPcgrChunk ) {
  
  ref_genes.list[["pcgr"]] <- read.table(pcgr_file, sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, fill = TRUE)
  
  ##### Simplify the variants types
  ref_genes.list[["pcgr"]]$CONSEQUENCE <- gsub("_variant", "", ref_genes.list[["pcgr"]]$CONSEQUENCE)
  ref_genes.list[["pcgr"]]$CONSEQUENCE <- gsub("_", " ", ref_genes.list[["pcgr"]]$CONSEQUENCE)
  
  ##### Simplify tiers' annotations and AFs
  ref_genes.list[["pcgr"]]$TIER <- gsub("TIER ", "", ref_genes.list[["pcgr"]]$TIER)
  
  ref_genes.list[["pcgr"]]$AF_TUMOR <- round(ref_genes.list[["pcgr"]]$AF_TUMOR, digits = 2)
  
} else {
  
  ref_genes.list[["pcgr"]] <- NULL
}

##### Check if purple (CN) output file exists
purple_file <- paste(params$umccrise, "purple", paste0(umccrise, ".purple.gene.cnv"), sep = "/")
runPurpleChunk <- TRUE

if ( file.exists(purple_file) ) {
  
  ref_genes.list[["purple"]] <- read.table(purple_file, sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, fill = TRUE)
  
} else {
  
  ref_genes.list[["purple"]] <- NULL
  runPurpleChunk <- FALSE
}

##### Check if manta (structural variants (SVs)) file exists
sv_file_1 <- paste(params$umccrise, "structural", paste0(umccrise, "-sv-prioritize-manta-pass.tsv"), sep = "/")
sv_file_2 <- paste(params$umccrise, "structural", paste0(umccrise, "-manta.tsv"), sep = "/")
runSVsChunk <- TRUE

if ( file.exists(sv_file_1) ) {
  
  ref_genes.list[["manta"]] <- sv_prioritize_short(sv_file_1)

} else if ( file.exists(sv_file_2) ) {
  
  ref_genes.list[["manta"]] <- sv_prioritize(sv_file_2)
  ref_genes.list[["manta"]] <- ref_genes.list[["manta"]][, c("Tier", "Event", "Gene", "Effect", "Detail", "Location", "AF", "CN chg", "SR", "PR", "CN", "Ploidy", "Transcript", "Other effects")]
  
  ##### Omit SVs without assigned gene
  ref_genes.list[["manta"]] <- ref_genes.list[["manta"]][ ref_genes.list[["manta"]]$Gene != "",  ]
  
} else {
  
  ref_genes.list[["manta"]] <- NULL
  runSVsChunk <- FALSE
}

##### Read in OncoKB (http://oncokb.org) annotations
caner_genes_annot.list[["oncokb_clin_vars"]] <- read.table(paste(params$ref_data_dir, params$oncokb_clin_vars, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="")
caner_genes_annot.list[["oncokb_all_vars"]] <- read.table(paste(params$ref_data_dir, params$oncokb_all_vars, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="", fill = TRUE)

##### Read in CIViC (https://civicdb.org/) annotations
caner_genes_annot.list[["civic_var_summaries"]] <- read.table(paste(params$ref_data_dir, params$civic_var_summaries, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="", fill = TRUE)
caner_genes_annot.list[["civic_clin_evid"]] <- read.table(paste(params$ref_data_dir, params$civic_clin_evid, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="", fill = TRUE)

##### Read in Cancer Biomarkers database (https://www.cancergenomeinterpreter.org/biomarkers) annotations. This is mainly used to annotate reported fusion events
caner_genes_annot.list[["cancer_biomarkers_trans"]] <- read.table(paste(params$ref_data_dir, params$cancer_biomarkers_trans, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="", fill = TRUE)

##### Read in FusionGDB database (https://ccsm.uth.edu/FusionGDB/) used to annotate reported fusion events, with info about head and tail genes.
caner_genes_annot.list[["FusionGDB"]] <- read.table(paste(params$ref_data_dir, params$FusionGDB, sep="/"), sep="\t", as.is=TRUE, header=FALSE, row.names=NULL, quote="", fill = TRUE)
names(caner_genes_annot.list[["FusionGDB"]]) <- c("Hgene", "HgeneID", "Tgene", "TgeneID", "FGname", "FGID")
```

```{r treatment_info, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 5, eval = runClinicalChunk }
##### Prapare data for the treatment timeline plot
##### Search for row with clinical info for investigated patient
sampleID.col <- grep(params$subject_id, ref_datasets.list[[dataset]][["clinical_info"]])

if ( length(sampleID.col) > 0 ) {
  
  ##### Identify column and row with patients details
  sampleID.row <- grep(params$subject_id, ref_datasets.list[[dataset]][["clinical_info"]][, sampleID.col])

  clinical_info <- ref_datasets.list[[dataset]][["clinical_info"]][ sampleID.row, ]
  
  ##### Prepare data frame structure for plotting
  ##### Define treatment types
  treamtent.types <- make.names(c("NEOADJUVANT REGIMEN", "ADJUVANT REGIMEN", "FIRST LINE REGIMEN", "SECOND LINE REGIMEN", "THIRD LINE REGIMEN"))
  treamtent.types_simple <- c("Neoadjuvant", "Adjuvant", "1st line", "2nd line", "3rd line")
  
  treamtent.df <- data.frame(matrix(ncol = 4, nrow = 0))
  colnames(treamtent.df) <- c("Treatment", "Type", "Start", "End")

  for ( i in 1:length(treamtent.types) ) {
    
    ##### Identify treatment column number
    treamtent.types.col <- grep(paste0("^",treamtent.types[i], "$"), names(clinical_info))
    
    ##### Check how many treatments of particular type were used
    treamtent.types.details <- unlist(strsplit(clinical_info[, treamtent.types.col], split=',', fixed=TRUE))
    
    ##### Add start and end info for each treatment
    if ( any(!is.na(treamtent.types.details ), na.rm = FALSE) ) {
    
      for ( treatment in treamtent.types.details ) {
        
        treamtent.start <- clinical_info[, treamtent.types.col+1]
        treamtent.end <- clinical_info[, treamtent.types.col+2]

        ##### Use current data if treatment is still ongoing
        today <- as.character(Sys.Date())
        treamtent.end[ is.na(treamtent.end) ] <- today
        treamtent.tmp <- data.frame( treatment, treatment, treamtent.types_simple[i], treamtent.start, treamtent.end)
        
        treamtent.df <- rbind( treamtent.df, treamtent.tmp)
      }
    }
  }
  
  if ( nrow(treamtent.df) > 0 ) {
    ##### For security reasons (wrt plots that go to PIEdb), change the dates but preserve the duration of the treatments
    ##### Get the earliest treatment date and set it as day 0. Then, create fake start and end dates based on the treatment length
    day0 <- sort(treamtent.df$treamtent.start, decreasing = FALSE)[1]
    treamtents.length <- treamtent.df$treamtent.end - treamtent.df$treamtent.start
    treamtents.reset <- as.Date("2000-01-01") - day0
    treamtent.df$treamtent.start <- treamtent.df$treamtent.start + treamtents.reset
    treamtent.df$treamtent.end <- treamtent.df$treamtent.start + treamtents.length
  
    names(treamtent.df) <- c("Treatment", "Drug", "Type", "Start",  "End")
    
    ##### Create directory for timeline plot
    PlotsDir <- paste(params$report_dir, "clinical_info", sep = "/")
    if ( !file.exists(PlotsDir) ) {
  
      dir.create(PlotsDir, recursive=TRUE)
    }
        
    setwd(PlotsDir)
     
    ##### Record the timeline plot. NOTE, the modified dates are used here
    treatment_timeline <- lares::plot_timeline(event = treamtent.df$Treatment, 
                start = treamtent.df$Start, 
                end = treamtent.df$End, 
                label = NA, 
                group = treamtent.df$Type,
                title = "",
                subtitle = "",
                save = FALSE)
    
    ##### Save the plot into png file. NOTE, the modified dates are used here. As default, the plot is saved as "cv_timeline"
    lares::plot_timeline(event = treamtent.df$Treatment, 
                start = treamtent.df$Start, 
                end = treamtent.df$End, 
                label = NA, 
                group = treamtent.df$Type,
                title = "",
                subtitle = "",
                save = TRUE)
    
    cv_timeline.png <- readPNG(paste(PlotsDir, "cv_timeline.png", sep="/"), native = FALSE, info = FALSE)
    
    ##### Change the size of the timeline png plot and save it as "treatment_timeline.png"
    png::writePNG(cv_timeline.png, paste(PlotsDir, "treatment_timeline.png", sep="/"), dpi=300)
    #png(paste(PlotsDir, "treatment_timeline.png", sep="/"), width = 900, height = 600, pointsize = 0.0001, res=300)
    #plot(cv_timeline.png)
    #invisible(dev.off())
    
    ##### Remove the original plot
    system(paste("rm ", paste(PlotsDir, "cv_timeline.png", sep="/")), ignore.stdout = TRUE, ignore.stderr = TRUE)
    
  } else {
    runClinicalChunk <- FALSE
  }

} else {
  runClinicalChunk <- FALSE
}
```

```{r data_transformation_filtering, comment = NA, message=FALSE, warning=FALSE}
##### Filtering to remove low expressed genes. For differential expression and related analyses, gene expression is rarely considered at the level of raw counts since libraries sequenced at a greater depth will result in higher counts. Rather, it is common practice to transform raw counts onto a scale that accounts for such library size differences. Genes with very low counts across all libraries provide little evidence for differential expression. In the biological point of view, a gene must be expressed at some minimal level before it is likely to be translated into a protein or to be biologically important. In addition, the pronounced discretenes of these counts interferes with some of the statistical approximations that are used later in the pipeline. These genes should be filtered out prior to further analysis. Users should filter with CPM rather than filtering on the counts directly, as the latter does not account for differences in library sizes between samples. For instance for the CPM-transformed data we keep only genes that have CPM of 1

##### Transformation to CPM or TPM scale (see these blogs for details https://www.rna-seqblog.com/rpkm-fpkm-and-tpm-clearly-explained/ and https://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/ ).  CPM = Counts Per Million,  TPM = Transcripts Per Kilobase Million. 

##### For counts data processing consider the investigated sample and internal reference cohort as one group  (regardless of the investigated patient tissie origin), and TCGA data (of any cancer type) as another group. This is to facilitate batch-effects (related with technical aspects) correction process
target_mod <- ref_datasets.list[[dataset]][["sample_annot"]]
target_mod$Target <- gsub(params$sample_name, int_cancer_group, target_mod$Target)
targets_mod.list <- unique(target_mod$Target)

##### Create lists with processed data each group
y <- vector("list", length(targets_mod.list))
names(y) <- targets_mod.list
  
#### For each group...
for ( group in targets_mod.list ) {
  
    target <- target_mod[ target_mod$Target==group, ]
    data <- ref_datasets.list[[dataset]][["combined_data"]]
    data <- data[ , target_mod$Target==group]
    
  ##### CPM transformation and filtering
  if ( params$filter && params$transform == "CPM" ) {
    
    ##### Create EdgeR DGEList object
    y[[group]] <- edgeR::DGEList(counts=data,  group=target$Target)
    
    ##### Remove genes with CPM of at least 1 in less than 10% of samples
    #cat("The CPM of 1 (cut-off for removing low expressed genes) corresponds to", round(min(as.numeric(colSums(data)*1e-6)), digits=0), "reads in sample with the lowest sequencing depth, and", round(max(as.numeric(colSums(data)*1e-6)), digits=0), "reads in sample with the greatest sequencing depth\n")
    
    keep <- rowSums(edgeR::cpm(y[[group]])>1) >= ncol(data)/10
    y[[group]]$filtered <- y[[group]][keep, , keep.lib.sizes=FALSE]
    
    #cat(nrow(y[[group]]$filtered$counts), "genes remained after filtering out of the", nrow(data), "genes in the input read count matrix\n\n")
    
    ##### Transform the raw-scale to CPM. Add small offset to each observation to avoid taking log of zero
    y[[group]]$samples["norm.factors"] <- edgeR::calcNormFactors(y[[group]], method = "none")$samples["norm.factors"]
    y[[group]]$transformed <- edgeR::cpm(y[[group]], normalized.lib.sizes=FALSE, log=params$log, prior.count=0.25)
    y[[group]]$filtered.transformed <- edgeR::cpm(y[[group]]$filtered, normalized.lib.sizes=FALSE, log=params$log, prior.count=0.25)
  
  ##### CPM transformation without filtering
  } else if ( !params$filter && params$transform == "CPM" ) {
    
    ##### Create EdgeR DGEList object
    y[[group]] <- edgeR::DGEList(counts=data,  group=target$Target)
    
    ##### Transform the raw-scale to CPM. Add small offset to each observation to avoid taking log of zero
    y[[group]]$transformed <- edgeR::cpm(y[[group]], normalized.lib.sizes=FALSE, log=params$log, prior.count=0.25)
    
  ##### TPM data transformation. We can convert RPKM to TPM in two different ways: from pre-calculated RPKM, by diving by the sum of RPKM values, or directly from the normalized counts. Here we calculate TPM starting from RPKM values computed using edgeR's rpkm function ( from http://luisvalesilva.com/datasimple/rna-seq_units.html )
  ##### TPM transformation with filtering
  } else if ( params$filter && params$transform == "TPM" ) {
    
    ##### Get genes lengths
    edb <- eval(parse(text = paste0("EnsDb.Hsapiens.v", params$ensembl_version)))
    
    gene.length <- lengthOf(edb, filter = GeneIdFilter(rownames(data)))
    
    ##### Check for which genes the lenght info is not available and remove them from the data
    genes.no_length <- rownames(data)[ rownames(data) %!in% names(gene.length)]
    data <- data[ rownames(data) %!in% genes.no_length, ]
    
    ##### Create EdgeR DGEList object
    y[[group]] <- edgeR::DGEList(counts=data,  group=target$Target)
    
    ##### Convert data into RPKM
    y[[group]]$transformed <- edgeR::rpkm(yy[[group]], gene.length = gene.length, normalized.lib.sizes=FALSE, log=FALSE)
    
    ##### Remove genes with TPM of at least 0.2 in less than 10% of samples
    keep <- rowSums(y[[group]]$transformed>0.2) >= ncol(y[[group]]$transformed)/10
    y[[group]]$filtered <- y[[group]]$counts[keep, ]
    y[[group]]$filtered.transformed <- y[[group]]$transformed[keep, ]
    
    ##### ... and then to TPM scale. Add small offset to each observation to avoid taking log of zero
    if ( params$log ) {
      
      y[[group]]$transformed <- log2(tpm_from_rpkm(y[[group]]$transformed+0.25))
      y[[group]]$filtered.transformed <- log2(tpm_from_rpkm(y[[group]]$filtered.transformed+0.25))
    
    } else {
      
      y[[group]]$transformed <- tpm_from_rpkm(y[[group]]$transformed)
      y[[group]]$filtered.transformed <- tpm_from_rpkm(y[[group]]$filtered.transformed)
    }
  
  ##### TPM transformation without filtering
  } else if ( !params$filter && params$transform == "TPM" ) {
    
    ##### Get genes lengths
    edb <- eval(parse(text = paste0("EnsDb.Hsapiens.v", params$ensembl_version)))
    
    gene.length <- lengthOf(edb, filter = GeneIdFilter(rownames(data)))
    
    ##### Check for which genes the lenght info is not available and remove them from the data
    genes.no_length <- rownames(data)[ rownames(data) %!in% names(gene.length)]
    data <- data[ rownames(data) %!in% genes.no_length, ]
    
    ##### Create EdgeR DGEList object
    y[[group]] <- edgeR::DGEList(counts=data,  group=target$Target)
    
    ##### Convert data into RPKM
    y[[group]]$transformed <- edgeR::rpkm(y[[group]], gene.length = gene.length, normalized.lib.sizes=FALSE, log=FALSE)
    
    ##### ... and then to TPM scale. Add small offset to each observation to avoid taking log of zero
    if ( params$log ) {
      
      y[[group]]$transformed <- log2(tpm_from_rpkm(y[[group]]$transformed+0.25))
    
    } else {
      
      y[[group]]$transformed <- tpm_from_rpkm(y[[group]]$transformed)
    }
  }
}

##### Now combine DGEList objects created for each group
y[["comb"]]$transformed <- cbind(y[[targets_mod.list[1]]]$transformed, y[[targets_mod.list[2]]]$transformed)
y[["comb"]]$samples <- rbind(y[[targets_mod.list[1]]]$samples, y[[targets_mod.list[2]]]$samples)

if ( params$filter ) {
  
  ##### Keep only genes present in all sets
  genes_mod <- intersect(rownames(y[[targets_mod.list[1]]]$filtered), rownames(y[[targets_mod.list[2]]]$filtered))
  y[[targets_mod.list[1]]]$filtered <- y[[targets_mod.list[1]]]$filtered[ rownames(y[[targets_mod.list[1]]]$filtered) %in% genes_mod, ]
  y[[targets_mod.list[2]]]$filtered <- y[[targets_mod.list[2]]]$filtered[ rownames(y[[targets_mod.list[2]]]$filtered) %in% genes_mod, ]
  y[[targets_mod.list[1]]]$filtered.transformed <- y[[targets_mod.list[1]]]$filtered.transformed[ rownames(y[[targets_mod.list[1]]]$filtered.transformed) %in% genes_mod, ]
  y[[targets_mod.list[2]]]$filtered.transformed <- y[[targets_mod.list[2]]]$filtered.transformed[ rownames(y[[targets_mod.list[2]]]$filtered.transformed) %in% genes_mod, ]
 
  
  y[["comb"]]$filtered <- cbind(y[[targets_mod.list[1]]]$filtered, y[[targets_mod.list[2]]]$filtered)
  y[["comb"]]$filtered.transformed <- cbind(y[[targets_mod.list[1]]]$filtered.transformed, y[[targets_mod.list[2]]]$filtered.transformed)
}
```

```{r data_transformation_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 6, fig.show="hide"}
##### Create directory for input data plots
PlotsDir <- paste(params$report_dir, "InputDataPlots", sep = "/")
if ( !file.exists(PlotsDir) ) {

  dir.create(PlotsDir, recursive=TRUE)
}

target <- ref_datasets.list[[dataset]][["sample_annot"]]

##### Assigne colours to targets and datasets
targets.colour <- getTargetsColours(target$Target)
  
##### Collect the most extreme density values for set the x-axis and y-axis boundaries
den.x <- density(y[["comb"]]$transformed[,1])$x
den.y <- density(y[["comb"]]$transformed[,1])$y
  
for (i in 2:ncol(y[["comb"]]$transformed)) {
    
  den <- density(y[["comb"]]$transformed[,i])
  den.x <- sort(c(den.x, den$x))
  den.y <- sort(c(den.y, den$y))
}

if ( params$filter ) {
  
  par(mfrow=c(1,2))
  
  ##### Before filtering
  plot(density(y[["comb"]]$transformed[,1]), lwd=2, xlim=c(den.x[1],den.x[length(den.x)]), ylim=c(den.y[1],den.y[length(den.y)]), las=2, main="", xlab="", col=targets.colour[[2]][1])
  title(main="Transformed data (unfiltered)", xlab=params$transform)
  abline(v=0, lty=3)
  
  for (i in 2:ncol(y[["comb"]]$transformed)){
    den <- density(y[["comb"]]$transformed[,i])
    lines(den$x, den$y, lwd=2, col=targets.colour[[2]][i])
  }
  legend("topright", legend=c(ext_cancer_group, int_cancer_group, "Patient"), fill=targets.colour[[1]], bty="n", bg = "transparent")
  
  data_transformation_nonfiltered <- recordPlot()
  
  ##### After filtering
  plot(density(y[["comb"]]$filtered.transformed[,1]), lwd=2, xlim=c(den.x[1],den.x[length(den.x)]), ylim=c(den.y[1],den.y[length(den.y)]), las=2, main="", xlab="", col=targets.colour[[2]][1])
  title(main="Transformed and filtered data", xlab=params$transform)
  abline(v=0, lty=3)
  
  for (i in 2:ncol(y[["comb"]]$filtered.transformed)){
    den <- density(y[["comb"]]$filtered.transformed[,i])
    lines(den$x, den$y, lwd=2, col=targets.colour[[2]][i])
  }
  legend("topright", legend=c(ext_cancer_group, int_cancer_group, "Patient"), fill=targets.colour[[1]], bty="n", bg = "transparent")
  
  data_transformation_filtered <- recordPlot()
  
  ##### Save the plot as pdf file
  pdf(paste0(PlotsDir, "/filtering.pdf"), width=8, height=5)
  par(mfrow=c(1,2))
  
  ##### Before filtering
  plot(density(y[["comb"]]$transformed[,1]), lwd=2, xlim=c(den.x[1],den.x[length(den.x)]), ylim=c(den.y[1],den.y[length(den.y)]), las=2, main="", xlab="", col=targets.colour[[2]][1])
  title(main="Transformed data (unfiltered)", xlab=params$transform)
  abline(v=0, lty=3)
  
  for (i in 2:ncol(y[["comb"]]$transformed)){
    den <- density(y[["comb"]]$transformed[,i])
    lines(den$x, den$y, lwd=2, col=targets.colour[[2]][i])
  }
  legend("topright", legend=c(ext_cancer_group, int_cancer_group, "Patient"), fill=targets.colour[[1]], bty="n", bg = "transparent")
  
  ##### After filtering
  plot(density(y[["comb"]]$filtered.transformed[,1]), lwd=2, xlim=c(den.x[1],den.x[length(den.x)]), ylim=c(den.y[1],den.y[length(den.y)]), las=2, main="", xlab="", col=targets.colour[[2]][1])
  title(main="Transformed and filtered data", xlab=params$transform)
  abline(v=0, lty=3)
  
  for (i in 2:ncol(y[["comb"]]$filtered.transformed)){
    den <- density(y[["comb"]]$filtered.transformed[,i])
    lines(den$x, den$y, lwd=2, col=targets.colour[[2]][i])
  }
  legend("topright", legend=c(ext_cancer_group, int_cancer_group, "Patient"), fill=targets.colour[[1]], bty="n", bg = "transparent")
  invisible(dev.off())
  
} else {
  
  ##### Without filtering
  plot(density(y[["comb"]]$transformed[,1]), lwd=2, xlim=c(den.x[1],den.x[length(den.x)]), ylim=c(den.y[1],den.y[length(den.y)]), las=2, main="", xlab="", col=targets.colour[[2]][1])
  title(main="Transformed data (unfiltered)", xlab=params$transform)
  abline(v=0, lty=3)
  
  for (i in 2:ncol(y[["comb"]]$transformed)){
    den <- density(y[["comb"]]$transformed[,i])
    lines(den$x, den$y, lwd=2, col=targets.colour[[2]][i])
  }
  legend("topright", legend=c(ext_cancer_group, int_cancer_group, "Patient"), fill=targets.colour[[1]], bty="n", bg = "transparent")
  
  ##### Save the plot as pdf file
  pdf(paste0(PlotsDir, "/filtering.pdf"), width=8, height=5)

  ##### Without filtering
  plot(density(y[["comb"]]$transformed[,1]), lwd=2, xlim=c(den.x[1],den.x[length(den.x)]), ylim=c(den.y[1],den.y[length(den.y)]), las=2, main="", xlab="", col=targets.colour[[2]][1])
  title(main="Transformed data (unfiltered)", xlab=params$transform)
  abline(v=0, lty=3)
  
  for (i in 2:ncol(y[["comb"]]$transformed)){
    den <- density(y[["comb"]]$transformed[,i])
    lines(den$x, den$y, lwd=2, col=targets.colour[[2]][i])
  }
  legend("topright", legend=c(ext_cancer_group, int_cancer_group, "Patient"), fill=targets.colour[[1]], bty="n", bg = "transparent")
  invisible(dev.off())
}
```

```{r data_normalisation, comment = NA, message=FALSE, warning=FALSE }
##### During the sample preparation or sequencing process, external factors that are not of biological interest can affect the expression of individual samples. For example, samples processed in the first batch of an experiment can have higher expression overall when compared to samples processed in a second batch. It is assumed that all samples should have a similar range and distribution of expression values. Normalisation for sample-specific effects is required to ensure that the expression distributions of each sample are similar across the entire experiment.

##### TMM normalsation. Trimmed mean of M-values (https://www.ncbi.nlm.nih.gov/pubmed/20196867) (TMM) is performed using the calcNormFactors function in edgeR. The normalisation factors calculated here are used as a scaling factor for the library sizes. TMM is the recommended for most RNA-Seq data where the majority (more than half) of the genes are believed not differentially expressed between any pair of the samples. It adjusts for RNA composition effect, calculates scaling factors for the library sizes with calcNormFactors function using trimmed mean of M-values (TMM) between each pair of samples. Note, that the raw read counts are used to calculate the normalisation factors
  
#### For each group...
for ( group in targets_mod.list ) {
  if ( params$transform == "CPM" ) {
    
    ##### Calculate normalization factors and transformations from the raw-scale to CPM and normalisation using user-defined method
    if ( params$filter ) {
      
      y[[group]]$noNorm <- y[[group]]$filtered.transformed
      y[[group]]$filtered$samples["norm.factors"] <- edgeR::calcNormFactors(y[[group]]$filtered, method = params$norm)$samples["norm.factors"]
      y[[group]]$norm <- edgeR::cpm(y[[group]]$filtered, normalized.lib.sizes=TRUE, log=params$log, prior.count=0.25)
    
    } else {
      
      y[[group]]$noNorm <- y[[group]]$transformed
      y[[group]]$samples["norm.factors"] <- edgeR::calcNormFactors(y[[group]], method = params$norm)$samples["norm.factors"]
      y[[group]]$norm <- edgeR::cpm(y[[group]], normalized.lib.sizes=TRUE, log=params$log, prior.count=0.25)
    }
    
  ##### Quantile normalsation (from https://www.biostars.org/p/296992/ )
  } else if ( params$transform == "TPM" ) {
    
    ##### Normalisation using quantile method
    if ( params$filter ) {
      
      y[[group]]$noNorm <- y[[group]]$filtered.transformed
      y[[group]]$filtered.transformed <- data.matrix(y[[group]]$filtered.transformed) 
      
      if ( tolower(params$norm) != "none" ) {
        
        y[[group]]$norm  <- normalize.quantiles(y[[group]]$filtered.transformed, copy = TRUE)
        colnames(y[[group]]$norm) <- colnames(y[[group]]$filtered.transformed)
        rownames(y[[group]]$norm) <- rownames(y[[group]]$filtered.transformed)
        
      } else {
        
        y[[group]]$norm  <- y[[group]]$filtered.transformed
      }
    
    } else {
      
      y[[group]]$noNorm <- y[[group]]$transformed
      y[[group]]$transformed <- data.matrix(y[[group]]$transformed)
      
      if ( tolower(params$norm) != "none" ) {
        
        y[[group]]$norm  <- normalize.quantiles(y[[group]]$transformed, copy = TRUE)
        colnames(y[[group]]$norm) <- colnames(y[[group]]$transformed)
        rownames(y[[group]]$norm) <- rownames(y[[group]]$transformed)
        
      } else {
        
        y[[group]]$norm  <- y[[group]]$transformed
      }
    }
  }
}  

##### Combine DGEList objects created for each group
y[["comb"]]$noNorm <- cbind(y[[targets_mod.list[1]]]$noNorm, y[[targets_mod.list[2]]]$noNorm)
y[["comb"]]$norm <- cbind(y[[targets_mod.list[1]]]$norm, y[[targets_mod.list[2]]]$norm)

ref_datasets.list[[dataset]][["combined_data_processed"]] <- y[["comb"]]$norm
```

```{r data_normalisation_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 6, fig.show="hide"}
##### Plot expression distribution of samples for unnormalised and normalised data
par(mfrow=c(2,1), mar=c(2, 5, 3, 2))
  
##### Unnormalised data
boxplot(y[["comb"]]$noNorm, las=2, col=targets.colour[[2]], main="", pch=".", las=3, xaxt="n")
title(main="Unnormalised data", ylab=params$transform)
legend("topright", legend=c(ext_cancer_group, int_cancer_group, "Patient"), fill=targets.colour[[1]], horiz=TRUE, bg = "transparent", box.col="transparent")

data_nonnormalised <- recordPlot()

##### Normalised data
boxplot(y[["comb"]]$norm, las=2, col=targets.colour[[2]], main="", pch=".", las=3, xaxt="n")
title(main=paste0("Normalised data (", params$norm, ")"), ylab=params$transform)
legend("topright", legend=c(ext_cancer_group, int_cancer_group, "Patient"), fill=targets.colour[[1]], horiz=TRUE, bg = "transparent", box.col="transparent")
  
data_normalised <- recordPlot()

##### Save the plot as pdf file
pdf(paste0(PlotsDir, "/normalisation.pdf"), width=8, height=8)
par(mfrow=c(2,1), mar=c(2, 5, 3, 2))
  
##### Unnormalised data
boxplot(y[["comb"]]$noNorm, las=2, col=targets.colour[[2]], main="", pch=".", las=3, xaxt="n")
title(main="Unnormalised data", ylab=params$transform)
legend("topright", legend=c(ext_cancer_group, int_cancer_group, "Patient"), fill=targets.colour[[1]], horiz=TRUE, bg = "transparent", box.col="transparent")
  
##### Normalised data
boxplot(y[["comb"]]$norm, las=2, col=targets.colour[[2]], main="", pch=".", las=3, xaxt="n")
title(main=paste0("Normalised data (", params$norm, ")"), ylab=params$transform)
legend("topright", legend=c(ext_cancer_group, int_cancer_group, "Patient"), fill=targets.colour[[1]], horiz=TRUE, bg = "transparent", box.col="transparent")
invisible(dev.off())
```

```{r batch_effect_correction, comment = NA, message=FALSE, warning=FALSE}
##### The strategy for correcting data for batch effects is to consider the investigated sample and internal reference cohort as one group (batch) (regardless of the investigated patient tissiu origin), and TCGA data (of any cancer type) as another batch. The objective is to remove as much as possible data variation due to technical factors.
batches <- as.character(ref_datasets.list[[dataset]][["sample_annot"]]$Target)

##### Change the sample dataset name to internal reference cohort
batches[ match(params$sample_name, batches) ] <- int_cancer_group

##### Perform batch-effect correctrion using limma
ref_datasets.list[[dataset]][["batch_effect_corrected"]] <- limma::removeBatchEffect(ref_datasets.list[[dataset]][["combined_data_processed"]], batch = batches)
```

```{r pca, comment = NA, message=FALSE, warning=FALSE}
suppressMessages(library(plotly))

##### Perform principal component analysis (PCA) using combined-only data and batch-effect corrected data
##### Loop through combined datasets and perform PCA
for ( dataset in names(ref_datasets.list) ) {
  
  target <- ref_datasets.list[[dataset]][["sample_annot"]]
  
  ref_datasets.list[[dataset]][["pca_combined_data_processed"]] <- pca(ref_datasets.list[[dataset]][["combined_data_processed"]], target, plot_mode = params$plots_mode)
  ref_datasets.list[[dataset]][["pca_batch_effect_corrected"]] <- pca(ref_datasets.list[[dataset]][["batch_effect_corrected"]], target, plot_mode = params$plots_mode)
}
##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

```{r gene_annot_count_data, comment = NA, message=FALSE, warning=FALSE}
##### Loop through combined, BUT NOT PROCESSED, datasets and annotate ALL genes. This part is mainly required for biotype detection step
for ( dataset in names(ref_datasets.list) ) {
  
  ##### Convert data into a data frame to make the Ensembl ID and gene symbol matches (with merge function)
  data <- ref_datasets.list[[dataset]][["combined_data"]]
  data.df <- as.data.frame(cbind(rownames(data), data))
  colnames(data.df)[1] <- "ENSEMBL"

  ##### Get genes annotation and genomic locations
  edb <- eval(parse(text = paste0("EnsDb.Hsapiens.v", params$ensembl_version)))
  
  ##### Get keytypes for gene SYMBOL
  keys <- keys(edb, keytype="GENEID")
  
  ##### Get genes genomic coordiantes
  gene_info <- ensembldb::select(edb, keys=keys, columns=c("GENEID", "GENEBIOTYPE", "GENENAME", "SEQNAME", "GENESEQSTART", "GENESEQEND"), keytype="GENEID")
  names(gene_info) <- gsub("GENEID", "ENSEMBL", names(gene_info))
  names(gene_info) <- gsub("GENENAME", "SYMBOL", names(gene_info))
  
  ##### Limit genes annotation to those genes for which sample expression measurments are available
  gene_info <-  gene_info[ gene_info$ENSEMBL %in% data.df$ENSEMBL,  ]
  
  ##### Remove rows with duplicated ENSEMBL IDs
  gene_info = gene_info[!duplicated(gene_info$ENSEMBL),]
  rownames(gene_info) <- gene_info$ENSEMBL
  
  ##### Remove rows with duplicated gene symbols (Y_RNAs, SNORs, LINC0s etc)
  gene_info = gene_info[!duplicated(gene_info$SYMBOL),]
  
  ##### Add info about immune response markers
  gene_info <- merge(gene_info, ref_genes.list[["genes_immune"]], by = "SYMBOL", all.x = TRUE)
  
  ##### Keep only immune response marjers for which there is available annotation
  ref_genes.list[["genes_immune"]] <- ref_genes.list[["genes_immune"]][ ref_genes.list[["genes_immune"]]$SYMBOL %in% gene_info$SYMBOL, ]
  
  ##### Merge genes genomic coordinates info with their annotation and expression data
  data.annot <- merge(gene_info, data.df, by = "ENSEMBL", all.x = FALSE)
  rownames(data.annot) <- data.annot$ENSEMBL
  
  ##### Get data matrix with gene symbols
  ref_datasets.list[[dataset]][["gene_annot_all"]] <- data.annot[, c("SYMBOL", "GENEBIOTYPE", "ENSEMBL", "SEQNAME", "GENESEQSTART", "GENESEQEND", "Immune_Cycle_Role")]
}
```

```{r gene_annot_processed_data, comment = NA, message=FALSE, warning=FALSE}
##### Loop through combined datasets and annotate genes
for ( dataset in names(ref_datasets.list) ) {
  
  ##### Convert data into a data frame to make the Ensembl ID and gene symbol matches (with merge function)
  data <- ref_datasets.list[[dataset]][["batch_effect_corrected"]]
  data.df <- as.data.frame(cbind(rownames(data), data))
  colnames(data.df)[1] <- "ENSEMBL"
  
  ##### Merge genes genomic coordinates info with their annotation and expression data
  data.annot <- merge(gene_info, data.df, by = "ENSEMBL", all.x = FALSE)
  
  ##### Keep only genes fo which gene symbol is available
  data.annot <- data.annot[!(is.na(data.annot$SYMBOL) | data.annot$SYMBOL==""), ]
  rownames(data.annot) <- data.annot$SYMBOL
  
  ##### Get data matrix with gene symbols
  ref_datasets.list[[dataset]][["batch_effect_corrected"]] <- apply(data.annot[, colnames(data)], 2, as.numeric)
  rownames(ref_datasets.list[[dataset]][["batch_effect_corrected"]]) <- data.annot$SYMBOL
  ref_datasets.list[[dataset]][["gene_annot"]] <- data.annot[, c("SYMBOL", "GENEBIOTYPE", "ENSEMBL", "SEQNAME", "GENESEQSTART", "GENESEQEND", "Immune_Cycle_Role")]
  
  ##### Save the combined expression matrix, genes list and associated targets into txt files
  write.table(prepare2write(ref_datasets.list[[dataset]][["batch_effect_corrected"]]), file = paste0(params$report_dir, "/", params$sample_name, ".", params$dataset, ".combined_data_processed.txt"), sep="\t", quote=FALSE, row.names=FALSE, col.names=TRUE, append = FALSE )
  write.table(prepare2write(rownames(ref_datasets.list[[dataset]][["batch_effect_corrected"]])), file = paste0(params$report_dir, "/", params$sample_name, ".", params$dataset,  ".combined_data_processed.genes.txt"), sep="\t", quote=FALSE, row.names=FALSE, col.names=TRUE, append = FALSE )
  write.table(prepare2write(ref_datasets.list[[dataset]][["sample_annot"]]), file = paste0(params$report_dir, "/", params$sample_name, ".", params$dataset, ".sample_annot.txt"), sep="\t", quote=FALSE, row.names=FALSE, col.names=TRUE, append = FALSE )
}
```

```{r cancer_genes_prep, comment = NA, message=FALSE, warning=FALSE}
##### Combine UMCCR cancer gene list with OncoKB cancer genes
genes_cancer <- ref_genes.list[["genes_oncokb"]]
genes_cancer$UMCCR <- rep("No", nrow(genes_cancer))
genes_cancer$Oncogene <- rep("-", nrow(genes_cancer))
genes_cancer$TSG <- rep("-", nrow(genes_cancer))
genes_cancer$Fusion <- rep("-", nrow(genes_cancer))
genes_cancer$Germline <- rep("-", nrow(genes_cancer))

##### Flag Oncogenes, TSGs and fusion genes in the UMCCR cancer genes list
ref_genes.list[["genes_cancer"]]$germ <- gsub("TRUE", "Yes", ref_genes.list[["genes_cancer"]]$germ)
ref_genes.list[["genes_cancer"]]$germ <- gsub("FALSE", "-", ref_genes.list[["genes_cancer"]]$germ)
ref_genes.list[["genes_cancer"]]$fusion <- gsub("TRUE", "Yes", ref_genes.list[["genes_cancer"]]$fusion)
ref_genes.list[["genes_cancer"]]$fusion <- gsub("FALSE", "-", ref_genes.list[["genes_cancer"]]$fusion)
ref_genes.list[["genes_cancer"]]$tumorsuppressor <- gsub("TRUE", "Yes", ref_genes.list[["genes_cancer"]]$tumorsuppressor)
ref_genes.list[["genes_cancer"]]$tumorsuppressor <- gsub("FALSE", "-", ref_genes.list[["genes_cancer"]]$tumorsuppressor)
ref_genes.list[["genes_cancer"]]$oncogene <- gsub("TRUE", "Yes", ref_genes.list[["genes_cancer"]]$oncogene)
ref_genes.list[["genes_cancer"]]$oncogene <- gsub("FALSE", "-", ref_genes.list[["genes_cancer"]]$oncogene)

for ( gene in unlist(ref_genes.list[["genes_cancer"]]$symbol ) ) {

  ##### Check if the UMCCR genes is already reported in OncoKB
  if ( gene %in% genes_cancer$Hugo.Symbol ) {
   
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$UMCCR <- "Yes"
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$Oncogene <- ref_genes.list[["genes_cancer"]]$oncogene[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$TSG <- ref_genes.list[["genes_cancer"]]$tumorsuppressor[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$Fusion <- ref_genes.list[["genes_cancer"]]$fusion[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$Germline <- ref_genes.list[["genes_cancer"]]$germ[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
    
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, 2] <- as.numeric(genes_cancer[ genes_cancer$Hugo.Symbol==gene, 2]) + 1
    
  ##### Add if not present
  } else {
    
    genes_cancer <- rbind(genes_cancer, c(gene, 1, "No", rep("", 8), "Yes"))
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$Oncogene <- ref_genes.list[["genes_cancer"]]$oncogene[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$TSG <- ref_genes.list[["genes_cancer"]]$tumorsuppressor[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$Fusion <- ref_genes.list[["genes_cancer"]]$fusion[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$Germline <- ref_genes.list[["genes_cancer"]]$germ[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
  }
}

##### Make the data frame to look nicer
rownames(genes_cancer) <- genes_cancer$Hugo.Symbol
names(genes_cancer) <- c("Gene", "Gene panels no.", "OncoKB", "Oncogene (OncoKB)", "TSG (OncoKB)", "MSK-IMPACT", "MSK-HEME", "Foundation One", "Foundation One Heme", "Vogelstein", "Sanger CGC", "UMCCR", "Oncogene", "TSG", "Fusion", "Germline")
genes_cancer <- genes_cancer[,c("Oncogene", "TSG", "Fusion", "Germline", "Gene panels no.", "UMCCR", "OncoKB", "MSK-IMPACT", "MSK-HEME", "Foundation One", "Foundation One Heme", "Vogelstein", "Sanger CGC")]
genes_cancer[ genes_cancer=="No" ] <- "-"
genes_cancer[ genes_cancer=="" ] <- "-"

ref_genes.list[["genes_cancer"]] <- genes_cancer
ref_genes.list[["genes_oncokb"]] <- genes_cancer[ rownames(genes_cancer) %in% ref_genes.list[["genes_oncokb"]]$Hugo.Symbol, ]
```

```{r gene_annot_processed_data_save, comment = NA, message=FALSE, warning=FALSE}
##### Save the entire expression data with cancer genes annotaiton as a data table html file
##### Generate expression summary table for mutated genes
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
    
  targets <- ref_datasets.list[[dataset]][["sample_annot"]]
  data <- apply(data.annot[ , names(data.annot) %!in% c(names(ref_datasets.list[[dataset]][["gene_annot"]])) ], 2, as.numeric)
  rownames(data) <- ref_datasets.list[[dataset]][["gene_annot"]]$SYMBOL
    
  genes.expr.z <- exprTable( genes = rownames(data), data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]], ext_links = TRUE, type = "z", scaling = scaling)
  
  genes.expr.perc <- exprTable( genes = rownames(data), data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]], ext_links = TRUE, type = "perc", scaling = scaling)
  
  ##### Create directory for saving tables
  exprTableDir <- paste(params$report_dir, "exprTables", sep = "/")
  
  if ( !file.exists(exprTableDir) ) {
  
          dir.create(exprTableDir, recursive=TRUE)
  }
  
  ##### Save the expression tables as html file
  DT::saveWidget(widget=genes.expr.z[[1]], file=paste(exprTableDir, "genes.expr.z.html", sep = "/"), selfcontained=TRUE)
  DT::saveWidget(widget=genes.expr.perc[[1]], file=paste(exprTableDir, "genes.expr.perc.html", sep = "/"), selfcontained=TRUE)
}
```

```{r mut_cn_expr_data_prep, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Combine expression data with mutation and CN data if available
cn_data <- ref_genes.list[["purple"]]
expr_data <- ref_datasets.list[[dataset]][["batch_effect_corrected"]]
targets <- ref_datasets.list[[dataset]][["sample_annot"]]

##### Get the "Diff" (Patient vs [comp_cancer]) Z-scores using exprTable function
expr_data <- exprTable( genes = rownames(expr_data), data = expr_data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, type = "z", scaling = scaling)[[2]]

if ( comp_cancer_group != int_cancer_group ) {

  expr_data.z <- expr_data[, "Diff" ]
} else {
  expr_data.z <- expr_data[, paste0( "Patient vs ", comp_cancer_group)]
}

names(expr_data.z) <- rownames(expr_data)
    
##### Remove entries with missing gene symbol (mainly variants in intergenic regions)
cn_data <- cn_data[ cn_data$Gene %!in% "", ]

##### Keep only genes with available expression data
cn_data <- cn_data[ cn_data$Gene %in% names(expr_data.z), ]

##### Calculate the mean CN for each gene
cn_data$MeanCopyNumber <- rowMeans(cbind(cn_data$MinCopyNumber, cn_data$MaxCopyNumber))
  
##### Deal with negative CN values
cn_data$MeanCopyNumber[ cn_data$MeanCopyNumber < 0 ] <- 0

##### Keep only altered genes with CN values below loss threshold (default CN value = 1) and above gain threshold (default CN value = 4)
cn_data.all <- cn_data
cn_data <- cn_data[ cn_data$MeanCopyNumber < params$cn_loss | cn_data$MeanCopyNumber > params$cn_gain, ]
  
##### Add mutation data if available
if ( !is.null(ref_genes.list[["pcgr"]]) ) {

  mut_data <- ref_genes.list[["pcgr"]]
    ##### Remove entries with missing gene symbol (mainly variants in intergenic regions)
  mut_data <- mut_data[ mut_data$SYMBOL %!in% "", ]

  ##### Prepare mutation data to include multiple mutations per gene
  ##### Initiate variable for the gene mutation status for each gene
  gene.mut <- as.matrix(rep("not mutated", length(expr_data.z)))
  colnames(gene.mut) <- "Mutation"
  rownames(gene.mut) <- names(expr_data.z)

  for ( i in 1:nrow(gene.mut) ) {
  
    ##### Check if any mutations are reported for each gene
    if (  rownames(gene.mut)[i] %in% mut_data$SYMBOL ) {
    
      ##### Deal with multiple mutations per gene
      if ( length(mut_data[ mut_data$SYMBOL %in% rownames(gene.mut)[i],  ]$CONSEQUENCE) > 1 ) {

        gene.mut[ rownames(gene.mut)[i],"Mutation" ] <- "multiple hits"

      } else {
      
        gene.mut[ rownames(gene.mut)[i],"Mutation" ] <- mut_data[ mut_data$SYMBOL %in% rownames(gene.mut)[i],  ]$CONSEQUENCE
      }
    }
  }

  ##### If there is no expression value for a specific gene than assume it's not expressed at all and assign the lowest value observed in that sample
  for ( gene in unique(mut_data$SYMBOL) ) {
  
    if ( gene %!in% rownames(gene.mut) ) {
        
      expr_data.z <- c(expr_data.z, min(expr_data.z))
      names(expr_data.z)[length(expr_data.z)] <- gene
    
      ##### Deal with multiple mutations per gene
      if ( length(mut_data[ mut_data$SYMBOL %in% gene,  ]$CONSEQUENCE) > 1 ) {

        gene.mut <- rbind( gene.mut,  "multiple hits")

      } else {
      
        gene.mut <- rbind( gene.mut,  mut_data[ mut_data$SYMBOL %in% gene,  ]$CONSEQUENCE )
      }
      rownames(gene.mut)[nrow(gene.mut)] <- gene
    }
  }

  ##### Subset expression, mutation and copy-number data to include only overlapping genes
  genes.intersect <- intersect(intersect(rownames(gene.mut), cn_data$Gene), names(expr_data.z))
  
  gene.mut.sub <- gene.mut[ rownames(gene.mut) %in% genes.intersect, ]
  cn_data.sub <- cn_data[ cn_data$Gene %in% genes.intersect, ]
  expr_data.z.sub <- expr_data.z[ names(expr_data.z) %in% genes.intersect ]
  
  ##### Make sure thay are all in the same order
  gene.mut.sub <- gene.mut.sub[ genes.intersect ]
  rownames(cn_data.sub) <- cn_data.sub$Gene
  cn_data.sub <- cn_data.sub[ genes.intersect,  ]
  expr_data.z.sub <- expr_data.z.sub[ genes.intersect  ]
  
  ##### Prepare data frame
  ref_datasets.list[[dataset]][["expr_mut_cn_data"]] <- data.frame(names(expr_data.z.sub), cn_data.sub$MeanCopyNumber, expr_data.z.sub, gene.mut.sub)
  colnames(ref_datasets.list[[dataset]][["expr_mut_cn_data"]]) <- c("Gene", "CN", "Z_score_diff", "Mutation")
  
} else {
  
  ##### Skip the step for processing mutation info and deal with expression and copy-number data
  ##### Subset expression and copy-number data to include only overlapping genes
  genes.intersect <- intersect(cn_data$Gene, names(expr_data.z))
  
  cn_data.sub <- cn_data[ cn_data$Gene %in% genes.intersect, ]
  expr_data.z.sub <- expr_data.z[ names(expr_data.z) %in% genes.intersect ]
  
  ##### Make sure thay are all in the same order
  rownames(cn_data.sub) <- cn_data.sub$Gene
  cn_data.sub <- cn_data.sub[ genes.intersect,  ]
  expr_data.z.sub <- expr_data.z.sub[ genes.intersect  ]
  
  ##### Prepare data frame
  ref_datasets.list[[dataset]][["expr_mut_cn_data"]] <- data.frame(names(expr_data.z.sub), cn_data.sub$MeanCopyNumber, expr_data.z.sub)
  colnames(ref_datasets.list[[dataset]][["expr_mut_cn_data"]]) <- c("Gene", "CN", "Z_score_diff")
}
```

```{r cn_data_distribution, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Get the percentiles from from the CN values
cn_data.all.percent <- quantile(cn_data.all$MeanCopyNumber, probs = seq(0, 1, .05), na.rm = TRUE)
  
##### Draw histogram of CN data
cn_dist_plot <- plot_ly(x = cn_data.all$MeanCopyNumber, type = 'histogram', name = "CN data", width = 800, height = 500) %>%
  
  ##### Add 10th percentile threshold
  add_lines(y = seq(0,1000, 100), x = rep(cn_data.all.percent[2],11), 
              line = list(color = "black", dash = "dash"), opacity = 0.4,
              name = "10th percentile", showlegend = TRUE) %>%
  
  ##### Add 50th percentile
  add_lines(y = seq(0,1000, 100), x = rep(cn_data.all.percent[11],11), 
              line = list(color = "black", dash = "dash"), opacity = 0.7,
              name = "50th percentile", showlegend = TRUE) %>%
  
  ##### Add 90th percentile threshold
  add_lines(y = seq(0,1000, 100), x = rep(cn_data.all.percent[20],11), 
              line = list(color = "black", dash = "dash"), opacity = 1,
              name = "80th percentile", showlegend = TRUE) %>%
  
  layout(xaxis = list( range=c(0,3), title = "CN values"), yaxis = list( title = "Frequency"), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = F)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

```{r pizzly_filtering, comment = NA, message=FALSE, warning=FALSE, eval = runKallistoChunk}
#read in the pizzly fusion calls
pizzly.fusions <- ref_genes.list[["pizzly"]]
quant <- ref_genes.list[["kallisto"]]
#sort and filter quantification file on tpm values. First, grep only the transcript ids for fusion genes from quantification #file. Currently filtering on quantiles. Selected 0.997 because that reduces the #final fusion calls to the value we are #interested in (~15)
quant.fusions.only.transcripts <- quant[grep(":", quant$target_id), ]
quant.sorted.filtered <- dplyr::filter(dplyr::arrange(quant.fusions.only.transcripts, desc(quant.fusions.only.transcripts$tpm)), tpm >= (quantile(quant.fusions.only.transcripts$tpm, 0.9)))

#initialize an empty dataframe
result <- data.frame()

#let's try using for loop for iterating over pizzly.fusions dataframe and get transcriptID and fusion gene pair information.
#can also filter quant.sorted.filtered$target_id to have only fusion gene target ids (that is two transcripts instead of one-
#this will increase speed

for (row in 1:nrow(pizzly.fusions)){
  y <- strsplit(as.character(pizzly.fusions[row, "transcripts.list"]), "\\;")
  y <- unname(y)
  for (i in 1:length(y[[1]])){
    if (y[[1]][i] %in% quant.sorted.filtered$target_id){
      #creating a new dataframe for the filtered pizzly results
      result <- rbind(result, data.frame(pizzly.fusions[row,]))
    }
  }
}

#remove duplicated values from result filtered using expression count (as multiple transcripts might support fusion between same gene) and sort the results by number of events (first by split count and then paircount)
deduped.result <- unique(result)

if ( nrow(deduped.result) > 0 ) {
    
  idx <- order(deduped.result$splitcount, deduped.result$paircount, decreasing = TRUE)
  deduped.result <- deduped.result[idx, ]
  
  #Extract only those fusion genes that are in cancer genes list
  result.cancer_genes <- data.frame()
  for (row in 1:nrow(pizzly.fusions)){
    if(pizzly.fusions[row,"geneA.name"] %in% rownames(ref_genes.list[["genes_cancer"]]) | pizzly.fusions[row,"geneB.name"] %in% rownames(ref_genes.list[["genes_cancer"]])) {
      #creating a new dataframe for extracting pizzly rows with cancer gene hits
      result.cancer_genes <- rbind(result.cancer_genes, data.frame(pizzly.fusions[row,]))
    }
  }
  
  ##### Ordering pizzly's cancer genes results on the basis of read count values
  ##### Skip ordering if no of the fusion genes is a cancer gene
  if ( nrow(result.cancer_genes) > 0 ) {
    
    idx2 <- order(result.cancer_genes$splitcount, result.cancer_genes$paircount, decreasing = TRUE)
    result.cancer_genes <- result.cancer_genes[idx2,]
  }
  
  #extracting rows from pizzly results that are not in re-quant i.e. deduped.result or cancer genes list i.e. result.cancer_genes
  result.other_genes <- pizzly.fusions[ rownames(pizzly.fusions) %!in% c(rownames(result.cancer_genes), rownames(deduped.result)), ]
  
  ##### Ordering pizzly's other genes results on the basis of read count values
  ##### Skip ordering if no of the fusion genes is a cancer gene
  if ( nrow(result.other_genes) > 0 ) {
    idx3 <- order(result.other_genes$splitcount, result.other_genes$paircount, decreasing = TRUE)
    result.other_genes <- result.other_genes[idx3,]
  }
  
  #combing all the three above sorted dataframes
  pizzly.fusions <- rbind(deduped.result, result.cancer_genes, result.other_genes)
  
  ##### Flag known fusions based on info from Cancer Biomarkers database (CGI) (https://www.cancergenomeinterpreter.org/biomarkers)
  known_translocations.CGI <- caner_genes_annot.list[["cancer_biomarkers_trans"]]
  known_translocations.CGI$cancer_acronym <- gsub(";", ", ", known_translocations.CGI$cancer_acronym)
  known_translocations.CGI$source <- gsub(";", ", ", known_translocations.CGI$source)
  known_translocations.CGI$translocation <- gsub("__", "_", known_translocations.CGI$translocation)
  
  ##### Flag known fusions based on info from FusionGDB (https://ccsm.uth.edu/FusionGDB)
  known_translocations.FusionGDB <- caner_genes_annot.list[["FusionGDB"]]
  
  ##### Merge info from both resources
  known_translocations <- merge(known_translocations.FusionGDB, known_translocations.CGI, by.x = "FGname", by.y = "translocation", all = TRUE, sort=FALSE)
  
  ##### Extract gene pairs involved in reported gene fusions
  trans.pairs <- as.data.frame(cbind( known_translocations$FGname, known_translocations$FGname ))
  names(trans.pairs) <- c("geneA", "geneB")
  trans.pairs$geneA <- sub("_.*", "", trans.pairs$geneA)
  trans.pairs$geneB <- sub(".*_", "", trans.pairs$geneB)
  known_translocations <- cbind(known_translocations, trans.pairs)
  trans.pairs <- apply( trans.pairs , 1 , paste , collapse = "-" )
  
  ##### Add columns for info about reported fusions
  pizzly.fusions <- cbind(pizzly.fusions, data.frame(matrix("", ncol = 5, nrow = nrow(pizzly.fusions)), stringsAsFactors = FALSE))
  colnames(pizzly.fusions)[-c(1:7)] <- c("FGID", "reported_fusion", "reported_fusion_geneA", "reported_fusion_geneB", "effector_gene")
  
  ##### Add annotations about known fusion events
  ##### Loop through all genes involved in deteced gene fusions (pizzly results) and check which are already reported
  for ( i in 1:nrow(pizzly.fusions) ) {
    
    geneA <- as.character(pizzly.fusions$geneA.name[i])
    geneB <- as.character(pizzly.fusions$geneB.name[i])
          
    ##### First check if the exact reported gene pairs were detected by pizzly
    if ( paste(geneA, geneB, sep="-") %in% trans.pairs ) {
      
      ##### provide fusion URL to FusionGDB
      pizzly.fusions$reported_fusion[i] <- "Yes"
      
      ##### provide fusion ID from FusionGDB
      pizzly.fusions$FGID[i] <- known_translocations$FGID[ trans.pairs %in% paste(geneA, geneB, sep="-")  ]
      
      pizzly.fusions$reported_fusion_geneA[i] <- "Yes"
      pizzly.fusions$reported_fusion_geneB[i] <- "Yes"
      
   } else if ( paste(geneB, geneA, sep="-") %in% trans.pairs ) {
      
      ##### provide fusion URL to FusionGDB
      pizzly.fusions$reported_fusion[i] <- "Yes"
      
      ##### provide fusion ID from FusionGDB
      pizzly.fusions$FGID[i] <- known_translocations$FGID[ trans.pairs %in% paste(geneB, geneA, sep="-")  ]
      
      pizzly.fusions$reported_fusion_geneA[i] <- "Yes"
      pizzly.fusions$reported_fusion_geneB[i] <- "Yes"
      
    ##### Now check if any ofthe pizzly detected fusion genes are reported
    } else {
      
      pizzly.fusions$reported_fusion[i] <- "-"
      
      ##### Check the Cancer Genome Interpreter (CGI) database first
      ##### Check pizzly genes A and genes A in reported fusions
      if ( geneA %in% known_translocations$geneA ) {
        
        pizzly.fusions$reported_fusion_geneA[i] <- "Yes"
        
      ##### Check pizzly genes A and genes B in reported fusions
      } else if ( geneA %in% known_translocations$geneB ) {
        
        pizzly.fusions$reported_fusion_geneA[i] <- "Yes"
      }
      
      ##### Check pizzly genes B and genes A in reported fusions
      if ( geneB %in% known_translocations$geneA ) {
        
        pizzly.fusions$reported_fusion_geneB[i] <- "Yes"
        
      ##### Check pizzly genes B and genes B in reported fusions
      } else if ( geneB %in% known_translocations$geneB ) {
        
        pizzly.fusions$reported_fusion_geneB[i] <- "Yes"
      }
      
      ##### Flag if any of the genes are effector gene
      if ( geneA %in% known_translocations$effector_gene  ) {
            
        pizzly.fusions$effector_gene[i] <- geneA
        
      } else if ( geneB == known_translocations$effector_gene  ) {
            
          pizzly.fusions$effector_gene[i] <- geneB
      }
    }
  }
  
  ##### Rearrange the table to move the transcripts list at the end
  pizzly.fusions <- pizzly.fusions %>% dplyr::select(-"transcripts.list","transcripts.list")
  
  ##### Index duplicated rows = these are fusions which involve both highly abundant transcripts and cancer genes and so are duplicated in  pizzly.fusions data frame
  dup.index <- which( duplicated(pizzly.fusions) |  duplicated(pizzly.fusions[nrow(pizzly.fusions):1, ])[nrow(pizzly.fusions):1] )
  
  ##### Add column indicating fusions containing high abundant transcripts and known cancer genes
  fusions_abundant <- c(rep("-", nrow(pizzly.fusions)))
  fusions_abundant[ c(1:nrow(deduped.result)) ] <- "Yes"
  fusions_cancer <- c(rep("-", nrow(pizzly.fusions)))
  
  if ( nrow(result.cancer_genes) > 0 ) {
    fusions_cancer[ c((nrow(deduped.result)+1):(nrow(deduped.result) + nrow(result.cancer_genes))) ] <- "Yes"
  }
  
  pizzly.fusions <- cbind(pizzly.fusions, fusions_abundant, fusions_cancer)
  
  ##### Indicate duplicated rows and flag them as both, those which involve both highly abundant transcripts and cancer genes
  pizzly.fusions$fusions_abundant[ dup.index  ] <- "Yes"
  pizzly.fusions$fusions_cancer[ dup.index ] <- "Yes"
  
  ##### Remove duplicated rows
  if ( any(duplicated(pizzly.fusions)) ) {
    
    pizzly.fusions <- pizzly.fusions[ -c(which( duplicated(pizzly.fusions) )), ]
  }
  
  ##### Re-order fusion genes based on the reported fusions column
  pizzly.fusions <- pizzly.fusions[ order(pizzly.fusions$reported_fusion, pizzly.fusions$fusions_abundant, pizzly.fusions$paircount, pizzly.fusions$splitcount, pizzly.fusions$fusions_cancer, pizzly.fusions$reported_fusion_geneA, pizzly.fusions$reported_fusion_geneB, decreasing = TRUE), ]

} else {
  
  runFusionChunk <- FALSE
}
```

```{r fusions_reads, comment = NA, message=TRUE, warning=FALSE, eval = runFusionChunk}
##### Get the number of reads supporting fusions of interest
fusion_reads <- data.frame()

for (row in 1:nrow(deduped.result)){
  y <- strsplit(as.character(deduped.result[row, "transcripts.list"]), "\\;")
  y <- unname(y)
  for (i in 1:length(y[[1]])){
    if (y[[1]][i] %in% quant.sorted.filtered$target_id){
      #creating a new dataframe for the reads supporting individual transcript ID for each filtered fusion gene pair 
      fusion_reads_inter <- data.frame(deduped.result[ row, names(deduped.result) %!in% "transcripts.list" ])
      fusion_reads_inter$transcriptID = y[[1]][i]
      tpm = quant.sorted.filtered[grep(y[[1]][i], quant.sorted.filtered$target_id), ]$tpm 
      fusion_reads_inter$tpm = tpm
      fusion_reads <- rbind(fusion_reads, fusion_reads_inter)
    }
  }
}

##### Rearrange the table to move the transcripts list at the end
fusion_reads <- fusion_reads %>% dplyr::select(-"transcriptID","transcriptID")
```

```{r fusions_annot, comment = NA, message=TRUE, warning=FALSE, eval = runFusionChunk}
##### Annotate fusion genes
##### Get data to annotate fusion genes
fusion_genes_annot <- ref_datasets.list[[dataset]][["gene_annot_all"]][ , c("ENSEMBL", "SYMBOL", "SEQNAME", "GENESEQSTART", "GENESEQEND") ]

##### Keep only fusions for which both genes have gene symbol (and genomics location) available
pizzly.fusions <- pizzly.fusions[ pizzly.fusions$geneA.id %in% fusion_genes_annot$ENSEMBL, ]
pizzly.fusions <- pizzly.fusions[ pizzly.fusions$geneB.id %in% fusion_genes_annot$ENSEMBL, ]

pizzly.fusions.annot <- pizzly.fusions
pizzly.fusions.annot$order <- 1:nrow(pizzly.fusions.annot)

##### Get genomic info for fusions genes
fusion_annot1 <- merge(fusion_genes_annot, pizzly.fusions.annot[ , c("geneA.id", "order")], by = 1, sort=FALSE)
fusion_annot1 <- fusion_annot1[ order(fusion_annot1$order), ]
fusion_annot2 <- merge(fusion_genes_annot, pizzly.fusions.annot[ , c("geneB.id", "order")], by = 1, sort=FALSE)
fusion_annot2 <- fusion_annot2[ order(fusion_annot2$order), ]

fusion_annot <- cbind(fusion_annot1, fusion_annot2, pizzly.fusions.annot[, c("paircount", "splitcount", "reported_fusion", "fusions_abundant", "fusions_cancer", "reported_fusion_geneA", "reported_fusion_geneB")])

##### Add column to flag fusions supported by WGS data (from MANTA), if available
fusion_annot$geneA_dna_support <- "-"
fusion_annot$geneB_dna_support <- "-"

colnames(fusion_annot) = make.names(colnames(fusion_annot), unique=TRUE)
```

```{r pizzly_data_cleanup, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
##### Clean the pizzly data first
##### Remove some columns and rename column names for better presentation
pizzly.fusions.cut <- pizzly.fusions[ , names(pizzly.fusions) %!in% c("geneA.id", "geneB.id", "transcripts.list") ]

##### Add column to flag fusions supported by WGS data (from MANTA), if available
pizzly.fusions.cut$geneA_dna_support <- "-"
pizzly.fusions.cut$geneB_dna_support <- "-"

pizzly.fusions.cut <- pizzly.fusions.cut[ , c("geneA.name", "geneB.name", "paircount", "splitcount", "geneA_dna_support", "geneB_dna_support", "reported_fusion", "FGID", "fusions_abundant", "fusions_cancer", "reported_fusion_geneA", "reported_fusion_geneB") ]
```

```{r pizzly_and_manta_data_prep, comment = NA, message=FALSE, warning=FALSE, eval = runSVsChunk}
##### Compare PIZZY and MANTA called gene fusion events

##### Deal with MANTA results
##### Add row for gene fusion events so that there is one row per gene
manta_sv <- ref_genes.list[["manta"]]
manta_sv$"Fusion genes" <- manta_sv$Gene

i <- 1
  
while ( i <= nrow(manta_sv) ) {
    
  if ( length(strsplit(manta_sv$Gene[i], split='&', fixed=TRUE)[[1]]) > 1 ) {
      
    ##### Insert new row for events involving two genes
    manta_sv <- tibble::add_row(manta_sv, .after = i)
    manta_sv[i+1, ] <- manta_sv[i, ]
    
    manta_sv$Gene[i] <- strsplit(manta_sv$Gene[i], split='&', fixed=TRUE)[[1]][1]
    manta_sv$Gene[i+1] <- strsplit(manta_sv$Gene[i+1], split='&', fixed=TRUE)[[1]][2]
    
    i <- i + 2
    
  } else {
    manta_sv$"Fusion genes"[i] <- ""
    
    i <- i + 1
  }
}

##### Compare fusion genes called by PIZZLy and MANTA
##### First limit MANTA output to fusions only
if ( runFusionChunk ) {
  
  manta_pizzly.fusions <- unique(manta_sv[ grep("&", manta_sv$"Fusion genes"),  ]$Gene)
  manta_pizzly.fusions <- manta_pizzly.fusions[ manta_pizzly.fusions %in% unique(c(as.vector(pizzly.fusions.cut$geneA.name), as.vector(pizzly.fusions.cut$geneB.name))) ]
    
  ##### Flag PIZZLY fusions that were also reported in MANTA
  if ( length(manta_pizzly.fusions) > 0 ) {
      
    pizzly.fusions.cut$geneA_dna_support[ sort( match( manta_pizzly.fusions , pizzly.fusions.cut$geneA.name ), na.last = NA ) ] <- "Yes"
    pizzly.fusions.cut$geneB_dna_support[ sort( match( manta_pizzly.fusions , pizzly.fusions.cut$geneB.name ), na.last = NA ) ] <- "Yes"
      
    fusion_annot$geneA_dna_support[ sort( match( manta_pizzly.fusions , fusion_annot$SYMBOL ), na.last = NA ) ] <- "Yes"
    fusion_annot$geneB_dna_support[ sort( match( manta_pizzly.fusions , fusion_annot$SYMBOL.1 ), na.last = NA ) ] <- "Yes"
  
    ##### Re-order pizzly dataframe with MANTA supporting fusions on top
    idx <- order(pizzly.fusions.cut$geneA_dna_support, pizzly.fusions.cut$geneB_dna_support, pizzly.fusions.cut$reported_fusion, decreasing = TRUE)
    pizzly.fusions.cut <- pizzly.fusions.cut[ idx, ]
    fusion_annot <- fusion_annot[ idx, ]
    pizzly.fusions <- pizzly.fusions[ idx, ]
  }
}
```

```{r ref_cohorts_summary, comment = NA, message=FALSE, warning=FALSE}
##### Summarise the reference cohorts samples
target <- ref_datasets.list[[dataset]][["sample_annot"]]

ref_normal <- table(target$Target)[names(table(target$Target))==ext_cancer_group]
ref_cancer <- table(target$Target)[names(table(target$Target))==int_cancer_group]
```

***

## Input data

<details>
<summary>Summary</summary>

**Reference patient cohorts**

The following reference patient cohorts were used for the analysis:

* **`r paste(ref_normal, ext_cancer_group, sep=" ")`** samples from [The Cancer Genome Atlas](https://cancergenome.nih.gov/abouttcga){target="_blank"} project ([related publication](https://www.nature.com/articles/ng.2764){target="_blank"})
* **`r paste(ref_cancer, int_cancer_group, sep=" ")`** samples from [University of Melbourne Centre for Cancer Research](https://research.unimelb.edu.au/centre-for-cancer-research/home){target="_blank"} samples collection

**Input genes**

Out of the `r nrow(ref_datasets.list[[dataset]][["combined_data"]])` input genes:

* **`r nrow(data.annot)` genes** have reliably detected expression
* `r if (params$filter) { nrow(ref_datasets.list[[dataset]][["combined_data"]]) - nrow(ref_datasets.list[[dataset]][["batch_effect_corrected"]]) } else { ("0") }` are either not expressed or their expression level is too low to be detected
* `r if (params$filter) { nrow(ref_datasets.list[[dataset]][["batch_effect_corrected"]]) - nrow(data.annot) } else { nrow(ref_datasets.list[[dataset]][["combined_data"]]) - nrow(data.annot) }` genes were ignored due to lack of [HGNC](https://www.genenames.org/){target="_blank"}-approved gene symbol

NOTE: the `r if (params$filter) { nrow(ref_datasets.list[[dataset]][["combined_data"]]) - nrow(ref_datasets.list[[dataset]][["batch_effect_corrected"]]) } else { ("0") }` genes with no/low expression are indicated in <span style="color:#808080">BLANK</span> cells with missing values in *expression summary tables* in [Mutated genes], [Cancer genes], [Structural variants], [CN altered genes] and [Immune markers] sections.

**Data transformation and filtering**

The read count data were converted into **`r params$transform`**s using *[edgeR](https://bioconductor.org/packages/release/bioc/html/edgeR.html){target="_blank"}* functions. `r if ( !params$filter ) { c("The option for filtering out genes with low counts is switched OFF") } else if ( params$filter ) { c("Genes with low counts were filtered out") }`. `r if ( !params$log ) { c("The data were not log-transformed") } else if ( params$log ) { c("The data were log2-transformed") }`. Plot(s) below present `r params$transform` data distribution.

```{r data_transformation_present, fig.width = 12, fig.height = 5, thumb = list(width = 15, height = 15) }
data_transformation_nonfiltered
data_transformation_filtered
```

**Data normalisation**

During the sample preparation or sequencing process, external factors that are not of biological interest can affect the expression of individual samples. For example, samples processed in the first batch of an experiment can have higher expression overall when compared to samples processed in a second batch. It is assumed that all samples should have a similar range and distribution of expression values. Normalisation for sample-specific effects is required to ensure that the expression distributions of each sample are similar across the entire experiment. Normalisation is performed using **`r params$norm`** method.

Box-plots below present `r params$transform` data for individual samples, coloured by sample groups, before and after `r params$norm` normalisation.

```{r data_normalisation_present, fig.width = 12, fig.height = 9, thumb = list(width = 15, height = 15) }
data_nonnormalised
data_normalised
```

**Exploratory data analysis**

Principal component analysis (PCA) was performed to reduce the dimensionality of data to visually assess similarities and differences between samples. This exploratory analysis facilitates identification of the key factors affecting the variability in the expression data.

* **PCA plot**

Scatter plot of the first 2 principal components (PCs) constituting the primary source of variation in the data.

* Before batch-effects correction

```{r pca_combined_data_present, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 8 }
ref_datasets.list[[dataset]][["pca_combined_data_processed"]][[2]]
```

* After batch-effects correction

```{r pca_batch_effect_corrected_present, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 8 }
ref_datasets.list[[dataset]][["pca_batch_effect_corrected"]][[2]]
```

* **Scree plot**

Scree plot presenting the fraction of total variance (y-axis) attributed to each PC (x-axis). The PCs are ordered by decreasing order of contribution to total variance. 

* Before batch-effects correction

```{r scree_combined_data_present, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 5 }
ref_datasets.list[[dataset]][["pca_combined_data_processed"]][[3]]
```

* After batch-effects correction

```{r scree_batch_effect_corrected_present, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 5 }
ref_datasets.list[[dataset]][["pca_batch_effect_corrected"]][[3]]
```

</details>

***

## Clinical information

<details>
<summary>Treatment timeline</summary>

Treatment regimen information for this patient is **`r if ( runClinicalChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**.

NOTE: for confidentiality reasons, the timeline (*x-axis*) projecting patient's treatment regimens (*y-axis*) is set to start from 1st January 2000, but the treatments lengths are preserved.

```{r treatment_timeline_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 5, thumb = list(width = 15, height = 15), eval = runClinicalChunk }
##### Present the treatment timeline plot
treatment_timeline
```

</details>

***

## Mutated genes

mRNA expression levels of genes containing single nucleotide variants (SNVs) or insertions/deletions (indels), obtained from the [PCGR](https://github.com/sigven/pcgr){target="_blank"} report, in patient's sample and their average mRNA expression in samples from cancer cohorts. NOTE, only PCGR [tier](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg){target="_blank"} 1-`r params$pcgr_tier` variants are reported.

Mutation data for this sample is **`r if ( runPcgrChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**. 

### - Summary table {.tabset}

Out of the `r length(unique(ref_genes.list[["pcgr"]]$SYMBOL))` mutated genes `r length(unique(ref_genes.list[["pcgr"]][ ref_genes.list[["pcgr"]]$TIER %in% c(1:params$pcgr_tier), ]$SYMBOL))` include [tier](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg){target="_blank"} 1-`r params$pcgr_tier` variants. Of these, the expression of **`r length(which(unique(ref_genes.list[["pcgr"]][ ref_genes.list[["pcgr"]]$TIER %in% c(1:params$pcgr_tier), ]$SYMBOL) %in% rownames(ref_datasets.list[[dataset]][["batch_effect_corrected"]])))`** was reliably measured in patient's sample. The remaining `r length(which((unique(ref_genes.list[["pcgr"]][ ref_genes.list[["pcgr"]]$TIER %in% c(1:params$pcgr_tier), ]$SYMBOL)) %!in% rownames(ref_datasets.list[[dataset]][["batch_effect_corrected"]])))` genes are either not expressed or their expression level is too low to be detected (indicated in <span style="color:#808080">BLANK</span> cells with missing values).

#### Z-scores

```{r mut_genes_table, comment = NA, message=FALSE, warning=FALSE, eval = runPcgrChunk}
##### Generate expression summary table for mutated genes (based on PCGR report)
targets <- ref_datasets.list[[dataset]][["sample_annot"]]
data <- ref_datasets.list[[dataset]][["batch_effect_corrected"]]

##### Consider only genes with mutations calssified within user-defined tiers
genes <- unique(ref_genes.list[["pcgr"]][ ref_genes.list[["pcgr"]]$TIER %in% c(1:params$pcgr_tier), ]$SYMBOL)

##### Deal with no genes
if ( length(genes) == 0 ) {
  
  genes <- NULL
}

mut_genes.expr.z <- exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], mut_annot = ref_genes.list[["pcgr"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "z", scaling = scaling)

##### Present the expression summary table
mut_genes.expr.z[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=mut_genes.expr.z[[1]], file=paste(exprTableDir, "mut_genes.expr.z.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each mutated gene. Variants' tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided based on information from [PCGR](https://github.com/sigven/pcgr){target="_blank"} report. In case of multiple varaints detected in single gene the variant with the lowest tier is reported and other potential consequences are listed in column *CONSEQUENCE_OTHER*. Genes are ordered by **increasing variants TIER** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. SD - standard deviation across groups

</font>
</details>

***

#### Percentiles

```{r mut_genes_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runPcgrChunk}
mut_genes.expr.perc <- exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], mut_annot = ref_genes.list[["pcgr"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "perc", scaling = scaling)

##### Present the expression summary table
mut_genes.expr.perc[[1]]

##### Save the expression table as html file
##### Create directory for tables
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=mut_genes.expr.perc[[1]], file=paste(exprTableDir, "mut_genes.expr.perc.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each mutated gene. Variants' tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided based on information from [PCGR](https://github.com/sigven/pcgr){target="_blank"} report. In case of multiple varaints detected in single gene the variant with the lowest tier is reported and other potential consequences are listed in column *CONSEQUENCE_OTHER*. Genes are ordered by **increasing variants TIER** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. SD - standard deviation across groups

</font>
</details>

***

### - Expression gene profiles {.tabset}

Expression profiles for 10 mutated genes with variants annotated with the lowest [tier](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg){target="_blank"} and demonstrating the greatest difference in standarised (Z-score) mRNA expression values between patient's sample and the average mRNA expression in samples from cancer patients.

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[1]) ) { mut_genes.expr.z[[2]]$SYMBOL[1] }`

```{r cdf_plot_mut_genes_1, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[1]

if ( !is.na(gene) && gene %in% rownames(data) ) {
  ##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste0("There are ", length(mut_genes.expr.z[[2]]$SYMBOL), " mutated genes that include tier 1-", params$pcgr_tier, " variants!"))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[2]) ) { mut_genes.expr.z[[2]]$SYMBOL[2] }`

```{r cdf_plot_mut_genes_2, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[2]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste0("There are ", length(mut_genes.expr.z[[2]]$SYMBOL), " mutated genes that include tier 1-", params$pcgr_tier, " variants!"))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[3]) ) { mut_genes.expr.z[[2]]$SYMBOL[3] }`

```{r cdf_plot_mut_genes_3, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[3]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste0("There are ", length(mut_genes.expr.z[[2]]$SYMBOL), " mutated genes that include tier 1-", params$pcgr_tier, " variants!"))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[4]) ) { mut_genes.expr.z[[2]]$SYMBOL[4] }`

```{r cdf_plot_mut_genes_4, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[4]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste0("There are ", length(mut_genes.expr.z[[2]]$SYMBOL), " mutated genes that include tier 1-", params$pcgr_tier, " variants!"))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[5]) ) { mut_genes.expr.z[[2]]$SYMBOL[5] }`

```{r cdf_plot_mut_genes_5, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[5]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste0("There are ", length(mut_genes.expr.z[[2]]$SYMBOL), " mutated genes that include tier 1-", params$pcgr_tier, " variants!"))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[6]) ) { mut_genes.expr.z[[2]]$SYMBOL[6] }`

```{r cdf_plot_mut_genes_6, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[6]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste0("There are ", length(mut_genes.expr.z[[2]]$SYMBOL), " mutated genes that include tier 1-", params$pcgr_tier, " variants!"))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[7]) ) { mut_genes.expr.z[[2]]$SYMBOL[7] }`

```{r cdf_plot_mut_genes_7, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[7]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste0("There are ", length(mut_genes.expr.z[[2]]$SYMBOL), " mutated genes that include tier 1-", params$pcgr_tier, " variants!"))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[8]) ) { mut_genes.expr.z[[2]]$SYMBOL[8] }`

```{r cdf_plot_mut_genes_8, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[8]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste0("There are ", length(mut_genes.expr.z[[2]]$SYMBOL), " mutated genes that include tier 1-", params$pcgr_tier, " variants!"))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[9]) ) { mut_genes.expr.z[[2]]$SYMBOL[9] }`

```{r cdf_plot_mut_genes_9, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[9]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste0("There are ", length(mut_genes.expr.z[[2]]$SYMBOL), " mutated genes that include tier 1-", params$pcgr_tier, " variants!"))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[10]) ) { mut_genes.expr.z[[2]]$SYMBOL[10] }`

```{r cdf_plot_mut_genes_10, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[10]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste0("There are ", length(mut_genes.expr.z[[2]]$SYMBOL), " mutated genes that include tier 1-", params$pcgr_tier, " variants!"))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

## Cancer genes

mRNA expression levels of cancer genes in patient's sample and their average mRNA expression in samples from cancer cohorts. These include genes reported in the following gene panels/resources *UMCCR cancer genes*, *[OncoKB](http://oncokb.org/#/about){target="_blank"}* (cancer genes listed [here](http://oncokb.org/#/cancerGenes){target="_blank"} and available [here](https://github.com/oncokb/oncokb-public/tree/master/data){target="_blank"}), *[MSK-IMPACT](https://www.mskcc.org/msk-impact){target="_blank"}*, *[MSK-HEME](http://www.islh.org/Presentation_Upload/presentation_uploads/12_52_0900-Zehir.pdf){target="_blank"}*, *[Foundation One](https://www.foundationmedicine.com/genomic-testing/foundation-one-cdx){target="_blank"}*, *[Foundation One Heme](https://www.foundationmedicine.com/genomic-testing/foundation-one-heme){target="_blank"}*, *[Vogelstein](http://science.sciencemag.org/content/339/6127/1546.full){target="_blank"}* and *[Sanger Cancer Gene Census](https://www.sanger.ac.uk/science/data/cancer-gene-census){target="_blank"}* (CGC).

### - Summary table {.tabset}

Out of the `r nrow(ref_genes.list[["genes_cancer"]])` cancer genes the expression of **`r length(which(rownames(ref_genes.list[["genes_cancer"]]) %in% rownames(ref_datasets.list[[dataset]][["batch_effect_corrected"]])))`** was reliably measured in patient's sample. The remaining `r length(which(rownames(ref_genes.list[["genes_cancer"]]) %!in% rownames(ref_datasets.list[[dataset]][["batch_effect_corrected"]])))` genes are either not expressed or their expression level is too low to be detected (indicated in <span style="color:#808080">BLANK</span> cells with missing values).

#### Z-scores

```{r cancer_genes_table, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for cancer genes from OncoKB and PMCC
targets <- ref_datasets.list[[dataset]][["sample_annot"]]
data <- ref_datasets.list[[dataset]][["batch_effect_corrected"]]

cancer_genes.expr.z <- exprTable( genes = rownames(ref_genes.list[["genes_cancer"]]), data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]], ext_links = TRUE, type = "z", scaling = scaling)

##### Present the expression summary table
cancer_genes.expr.z[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=cancer_genes.expr.z[[1]], file=paste(exprTableDir, "cancer_genes.expr.z.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each cancer gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, and inclusion in various sequencing panels are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

</font>
</details>

***

#### Percentiles

```{r cancer_genes_table_perc, comment = NA, message=FALSE, warning=FALSE}
cancer_genes.expr.perc <- exprTable( genes = rownames(ref_genes.list[["genes_cancer"]]), data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]], ext_links = TRUE, type = "perc", scaling = scaling)

##### Present the expression summary table
cancer_genes.expr.perc[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=cancer_genes.expr.perc[[1]], file=paste(exprTableDir, "cancer_genes.expr.perc.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each cancer gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, and inclusion in various sequencing panels are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

</font>
</details>

***

### - Expression gene profiles {.tabset}

Expression profiles for 10 altered cancer genes with the greatest difference in standarised (Z-score) mRNA expression values between patient's sample and the average mRNA expression in samples from cancer patients.

#### `r cancer_genes.expr.z[[2]]$SYMBOL[1]`

```{r cdf_plot_cancer_genes_1, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[1]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[2]`

```{r cdf_plot_cancer_genes_2, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[2]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[3]`

```{r cdf_plot_cancer_genes_3, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[3]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[4]`

```{r cdf_plot_cancer_genes_4, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[4]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[5]`

```{r cdf_plot_cancer_genes_5, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[5]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[6]`

```{r cdf_plot_cancer_genes_6, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[6]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[7]`

```{r cdf_plot_cancer_genes_7, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[7]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[8]`

```{r cdf_plot_cancer_genes_8, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[8]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[9]`

```{r cdf_plot_cancer_genes_9, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[9]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[10]`

```{r cdf_plot_cancer_genes_10, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[10]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

## Fusion genes

<details>
<summary>Fusion genes prioritisation</summary>

Fusion genes detected in transcriptome data are prioritised based on criteria ranked in the following order:

1. Involvement of fusion gene(s) **detected in genomic data** (if [Structural variants] results are available)

2. Listed as **reported** fusion event according to [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"} database

3. Involvement of highly **abundant transcript(s)**  (see abundant transcripts definition below)

4. The number of **split counts**

5. The number of **pair counts**

6. Involvement of **cancer gene(s)** (see [Cancer genes] section)

</details>

<details>
<summary>Abundant transcripts definition</summary>

The following steps were performed to define **abundant transcripts** involved in detected fusion events:

1. Run [kallisto](https://github.com/pachterlab/kallisto){target="_blank"} to quantify the fusion transcripts reported by [pizzly](https://github.com/pmelsted/pizzly){target="_blank"} and select those which are supported by decent number of [Transcripts Per Kilobase Million](http://www.arrayserver.com/wiki/index.php?title=TPM){target="_blank"} (TPM) 
2. Create a new index based on the transcriptome and the fusion transcripts identified by [pizzly](https://github.com/pmelsted/pizzly){target="_blank"}
3. Run [kallisto](https://github.com/pachterlab/kallisto){target="_blank"} in normal quantification mode on the expanded index to quantify both normal transcripts and fusions
4. Select fusion genes involving transcripts with [TPM](http://www.arrayserver.com/wiki/index.php?title=TPM){target="_blank"} values above 90th percentile of all [TPM](http://www.arrayserver.com/wiki/index.php?title=TPM){target="_blank"} values (as reported by previous step)

</details>

Fusion genes information for this sample is **`r if ( runKallistoChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**. 

***

### - Summary

Out of the `r if ( runFusionChunk ) { nrow(pizzly.fusions.cut) } else { c("0") }` fusion event(s) <span style="color:#ff0000">**`r if ( runFusionChunk ) { nrow(pizzly.fusions.cut[ pizzly.fusions.cut$geneA_dna_support == "Yes" | pizzly.fusions.cut$geneB_dna_support == "Yes" , ]) } else { c("0") }`**</span> involve **DNA-supported** fusion genes (see [Structural variants] section), <span style="color:#02d653">**`r if ( runFusionChunk ) { nrow(pizzly.fusions.cut[ pizzly.fusions.cut$reported_fusion == "Yes" , ]) } else { c("0") }`**</span> are **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}**, <span style="color:#0000ff">**`r if ( runFusionChunk ) { nrow(pizzly.fusions.cut[ pizzly.fusions.cut$fusions_abundant == "Yes" , ]) } else { c("0") }`**</span> contain **highly abundant** fusion transcript(s) and <span style="color:#767689">**`r if ( runFusionChunk ) { nrow(pizzly.fusions.cut[ pizzly.fusions.cut$fusions_cancer == "Yes" , ]) } else { c("0") }`**</span> involve **[Cancer genes]**.

NOTE: Only fusion events including genes with available genomics coordinates in [Ensembl database version](https://ensembl.org/info/website/archives/index.html){target="_blank"} `r params$ensembl_version` are reported.

**`r if ( !runFusionChunk ) { c("No fusion genes were detected!") }`**

```{r fusions_summary_table, comment = NA, message=FALSE, warning=FALSE}
##### Create a nice table output (with dataTable)
if ( runFusionChunk ) {
  pizzly.fusions.table <- pizzly.fusions.cut
  pizzly.fusions.table$geneA.name <- as.vector(pizzly.fusions.table$geneA.name)
  pizzly.fusions.table$geneB.name <- as.vector(pizzly.fusions.table$geneB.name)
  
  ##### Provide link to FusionGDB
  for ( i in 1:nrow(pizzly.fusions.table) ) {
    
      if ( pizzly.fusions.table$reported_fusion[i] == "Yes" ) {
          
        pizzly.fusions.table$geneA.name[i] <- paste0("<a href='https://ccsm.uth.edu/FusionGDB/gene_search_result.cgi?page=page&type=quick_search&quick_search=", pizzly.fusions.table$FGID[i], "' target='_blank'>", pizzly.fusions.table$geneA.name[i], "</a>")
  
        pizzly.fusions.table$geneB.name[i] <- paste0("<a href='https://ccsm.uth.edu/FusionGDB/gene_search_result.cgi?page=page&type=quick_search&quick_search=", pizzly.fusions.table$FGID[i], "' target='_blank'>", pizzly.fusions.table$geneB.name[i], "</a>")
      }
  }
  
  pizzly.fusions.table <- pizzly.fusions.table[ , names(pizzly.fusions.table) %!in% "FGID" ]
  
  names(pizzly.fusions.table) <- c("Gene A", "Gene B", "Pair count", "Split count", "DNA support (gene A)", "DNA support (gene B)", "Reported fusion", "Abundant transcript(s)", "Cancer gene(s)", "Fusion gene (A)", "Fusion gene (B)")
  
  ##### Present gene fusion events in a table
  pizzly.fusions.summary <- DT::datatable( data = pizzly.fusions.table, filter = "none", rownames = FALSE, extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left; color:grey; font-size:100% ;'), escape = FALSE) %>%
      DT::formatStyle( columns = names(pizzly.fusions.table), `font-size` = '12px', 'text-align' = 'center' ) %>%
    
      ##### Highlight rows with fusions involving hihgly abundant transcripts (red), cancer genes (blue) or DNA support (from MANTA)
      DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "Abundant transcript(s)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'lightblue')) ) %>%
      DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "Cancer gene(s)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'lightgrey')) ) %>%
      DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "DNA support (gene A)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'coral')) ) %>%
      DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "DNA support (gene B)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'coral')) ) %>%
      DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "Reported fusion", backgroundColor = DT::styleEqual( c("-", "Yes"), c('transparent', 'lightgreen')) )
  
  pizzly.fusions.summary
  
} else {
  
  ##### Create empty table
  pizzly.fusions.table <- data.frame(matrix(ncol = 11, nrow = 0))
  colnames(pizzly.fusions.table) <- c("Gene A", "Gene B", "Pair count", "Split count", "DNA support (gene A)", "DNA support (gene B)", "Reported fusion", "Abundant transcript(s)", "Cancer gene(s)", "Fusion gene (A)", "Fusion gene (B)")
    
  ##### Present gene fusion events in a table
  pizzly.fusions.summary <- DT::datatable( data = pizzly.fusions.table, filter = "none", rownames = FALSE, extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left; color:grey; font-size:100% ;'), escape = FALSE) %>%
      DT::formatStyle( columns = names(pizzly.fusions.table), `font-size` = '12px', 'text-align' = 'center' ) %>%
    
      ##### Highlight rows with fusions involving hihgly abundant transcripts (red), cancer genes (blue) or DNA support (from MANTA)
      DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "Abundant transcript(s)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'lightblue')) ) %>%
      DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "Cancer gene(s)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'lightgrey')) ) %>%
      DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "DNA support (gene A)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'coral')) ) %>%
      DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "DNA support (gene B)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'coral')) ) %>%
      DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "Reported fusion", backgroundColor = DT::styleEqual( c("-", "Yes"), c('transparent', 'lightgreen')) )
  
  pizzly.fusions.summary
}

##### Save the table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  
  ##### Create directory for tables
  fusionsTableDir <- paste(params$report_dir, "fusionsTables", sep = "/")
  
  if ( !file.exists(fusionsTableDir) ) {
  
          dir.create(fusionsTableDir, recursive=TRUE)
  }

  DT::saveWidget(widget=pizzly.fusions.summary, file=paste(fusionsTableDir, "pizzly.fusions.summary.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

Cells in <span style="color:#ff0000">RED</span> indicate **DNA-supported** fusion genes (see [Structural variants] section), cells in <span style="color:#02d653">GREEN</span> indicate fusion events **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}**, cells in <span style="color:#0000ff">BLUE</span> indicate **highly abundant** fusion transcript(s), and those hihglighted in <span style="color:#767689">GREY</span> indicate fusions containing **[Cancer genes]**. Gene fusions reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"} are hyperlinked. Genes known to be involved in gene fusions are flagged based on information provided in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"} and [Cancer Genome Interpreter](https://www.cancergenomeinterpreter.org/biomarkers){target="_blank"} (CGI) databases. Fusion events are ordered by the following columns:

**DNA support (gene A/B)**: DNA-supported fusion gene(s) (see [Structural variants] section)

**Reported fusion**: fusion event reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}

**Abundant transcript(s)**: gene fusion events involving highly abundant transcript(s)

**Cancer gene(s)**: gene fusion events involving [Cancer genes]

**Fusion gene (A/B)**: gene(s) known to be involved in tumorigenesis across cancer types based on [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"} and [CGI](https://www.cancergenomeinterpreter.org/biomarkers){target="_blank"} databases

</font>
</details>

***

### - Genomic view

<span style="color:#ff0000">**`r if ( runFusionChunk ) { nrow(pizzly.fusions.cut[ pizzly.fusions.cut$geneA_dna_support == "Yes" | pizzly.fusions.cut$geneB_dna_support == "Yes" , ]) } else { c("0") }`**</span> involving **DNA-supported** fusion genes (see [Structural variants] section) and <span style="color:#02d653">**`r if ( runFusionChunk ) { nrow(pizzly.fusions.cut[ pizzly.fusions.cut$reported_fusion == "Yes" , ]) } else { c("0") }`**</span> gene fusions **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}** are presented in the genomic context. The table at the bottom contains genomic coordingates of individual fusion genes sorted based on their genomic location.

SVs information for this sample is **`r if ( runSVsChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**. 

**`r if ( !runFusionChunk ) { c("No fusion genes were detected!") }`**

```{r genomic_view_plot_fusions, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runFusionChunk}
##### Keep only fusions with abundant transcript(s) or cancer gene(s) involved
if ( runSVsChunk ) {
  
  fusion_annot_top <- fusion_annot[ fusion_annot$reported_fusion == "Yes" | fusion_annot$geneA_dna_support == "Yes" | fusion_annot$geneB_dna_support == "Yes" , ]
  
  ##### Generate bezier curves-like plot representing gene fusion events. NOTE. Only fusions involving fusion genes supported by MANTA are presented
  if ( nrow(fusion_annot_top) > 0 ) {
    
    BezierPlot <- fusionsBezierPlot(fusion_annot = fusion_annot_top, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]])
    BezierPlot
    
  } else {
    
    cat("None of the transcriptome-based fusion events have supporting evidence from DNA data.")
  }
}
```

```{r genomic_view_plot_fusions_save, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runFusionChunk}
##### Save the BezierPlot as png
if ( runSVsChunk ) {
  
  if ( nrow(fusion_annot_top) > 0 ) {
    
    fusionsPlotDir <- paste(params$report_dir, "fusionsPlot", sep = "/")
    
    if ( !file.exists(fusionsPlotDir) ) {
    
          dir.create(fusionsPlotDir, recursive=TRUE)
    }
    
    png( filename = paste(fusionsPlotDir, "bezierPlot.png", sep="/"), width = 800, height = 300, units = "px" )
    BezierPlot
  }
}
```

```{r genomic_view_table_fusions, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
if ( runSVsChunk && nrow(fusion_annot_top) > 0 ) {
  
  ##### Clean the table for better presentation
  fusion_annot_top.clean <- fusion_annot_top[, c("SYMBOL", "SEQNAME", "GENESEQSTART", "GENESEQEND", "SYMBOL.1", "SEQNAME.1", "GENESEQSTART.1", "GENESEQEND.1", "paircount", "splitcount", "geneA_dna_support", "geneB_dna_support", "reported_fusion", "fusions_abundant", "fusions_cancer") ]
  
  ##### Order fusions based on the genomic location (chrom and start positions)
  chrOrder <-c((1:22),"X","Y","M")
  
  fusion_annot_top.clean$SEQNAME <- factor(fusion_annot_top.clean$SEQNAME, chrOrder, ordered=TRUE)
  fusion_annot_top.clean$SEQNAME.1 <- factor(fusion_annot_top.clean$SEQNAME.1, chrOrder, ordered=TRUE)
  fusion_annot_top.clean <- fusion_annot_top.clean[do.call(order, fusion_annot_top.clean[, c("SEQNAME", "SEQNAME.1", "GENESEQSTART", "GENESEQSTART.1")]), ]
  
  names(fusion_annot_top.clean) <- c("Gene A", "Chrom (A)", "Start (A)", "End (A)", "Gene B", "Chrom (B)", "Start (B)", "End (B)", "Pair count", "Split count", "DNA support (gene A)", "DNA support (gene B)", "Reported fusion", "Abundant transcript(s)", "Cancer gene(s)")
  
  pizzly.fusions.genomicView <- DT::datatable( data = fusion_annot_top.clean, filter="none", rownames = FALSE, extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE) %>%
      DT::formatStyle( columns = names(fusion_annot_top.clean), `font-size` = '12px', 'text-align' = 'center' ) %>%
    
      ##### Highlight rows with fusions involving hihgly abundant transcripts (red) or cancer genes (blue)
      DT::formatStyle( columns = colnames(fusion_annot_top.clean) %in% "Abundant transcript(s)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'lightblue')) ) %>%
      DT::formatStyle( columns = colnames(fusion_annot_top.clean) %in% "Cancer gene(s)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'lightgrey')) ) %>%
      DT::formatStyle( columns = colnames(fusion_annot_top.clean) %in% "DNA support (gene A)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'coral')) ) %>%
      DT::formatStyle( columns = colnames(fusion_annot_top.clean) %in% "DNA support (gene B)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'coral')) ) %>%
    DT::formatStyle( columns = colnames(fusion_annot_top.clean) %in% "Reported fusion", backgroundColor = DT::styleEqual( c("-", "Yes"), c('transparent', 'lightgreen')) )

pizzly.fusions.genomicView
}
```

```{r genomic_view_table_fusions_save, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
##### Save the table as html file
if ( runSVsChunk && nrow(fusion_annot_top) > 0 && (params$plots_mode == "interactive" || params$plots_mode == "semi-interactive") ) {
  DT::saveWidget(widget=pizzly.fusions.genomicView, file=paste(fusionsTableDir, "pizzly.fusions.genomicView.html", sep = "/"), selfcontained=TRUE)  
}
```

<details>
<summary>Table legend</summary>
<font size="2">

Cells in <span style="color:#ff0000">RED</span> indicate **DNA-supported** fusion genes (see [Structural variants] section), cells in <span style="color:#02d653">GREEN</span> indicate gene fusions **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}**, cells in <span style="color:#0000ff">BLUE</span> indicate **highly abundant** fusion transcript(s), and those hihglighted in <span style="color:#767689">GREY</span> indicate fusions containing **[Cancer genes]**. Genes known to be involved in gene fusions are flagged based on information provided in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"} and [Cancer Genome Interpreter](https://www.cancergenomeinterpreter.org/biomarkers){target="_blank"} (CGI) databases. Fusion events are ordered by **genomic coordinates** of **Gene A** and then **Gene B**.

**DNA support (gene A/B)**: DNA-supported fusion gene(s) (see) [Structural variants] section)

**Reported fusion**: fusion event reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}

**Abundant transcript(s)**: gene fusion events involving highly abundant transcript(s)

**Cancer gene(s)**: gene fusion events involving [Cancer genes]

</font>
</details>

***

### - Top hits {.tabset}

Expression profiles for 5 gene fusion events involving **DNA-supported fusion** genes (see [Structural variants] section), gene fusions **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}**, **abundant transcripts** or **[Cancer genes]**, indicated in <span style="color:#02d653">green</span>, <span style="color:#ff0000">red</span>, <span style="color:#0000ff">blue</span> and <span style="color:#767689">grey</span> columns in the [Fusion genes] table, respectively, and with the highest *Split count* and *Pair count* values. 

<span style="color:#ff0000">NOTE</span>: the *Fusion genes visualisation* is not available for gene pairs for which no junctions were found by [clinker](https://github.com/Oshlack/Clinker){target="_blank"}.

**`r if ( !runFusionChunk ) { c("No fusion genes were detected!") }`**

#### `r if ( runFusionChunk ) { if ( !is.na(pizzly.fusions$geneA.name[1]) ) { paste(pizzly.fusions$geneA.name[1], pizzly.fusions$geneB.name[1], sep="-") }}`

```{r fusion_1_process, comment = NA, message=TRUE, warning=FALSE, eval = runKallistoChunk}
##### Convert the fusion image from pdf to png and present it in the report
targets <- ref_datasets.list[[dataset]][["sample_annot"]]
data <- ref_datasets.list[[dataset]][["batch_effect_corrected"]]

geneA <- as.vector(pizzly.fusions$geneA.name[1])
geneB <- as.vector(pizzly.fusions$geneB.name[1])

if ( !is.na(geneA) && !is.na(geneB) && geneA %in% rownames(data) && geneB %in% rownames(data) ) {
  
  runFusionChunk <- TRUE
} else {
  
  cat("Expression data is not available for one of the genes.")
  runFusionChunk <- FALSE
}

##### Check if clinker fusion plot exists. Skip this section if it doesn't
if ( file.exists(paste0(dataDir, "/clinker/", geneA, "_", geneB, ".pdf")) ) {
  
  runClinkerChunk <- TRUE
} else {
  runClinkerChunk <- FALSE
}

##### Create file listing fusion events for which Clinker plot is available
clinker_fusions <- ""
```

##### `r if ( runClinkerChunk ) { c("Fusion genes visualisation") } else { c("") }` 

```{r fusion_1_plot, comment = NA, message=TRUE, warning=FALSE, eval=runClinkerChunk}
##### Check if clinker fusion plot exists. Skip this section if it doesn't
fusion_png(geneA, geneB, paste(dataDir, "clinker", sep="/") )
clinker_fusions <- c(clinker_fusions, paste0(geneA, "-", geneB))
```

```{r fusion_tables_1, comment = NA, message=TRUE, warning=FALSE, eval=FALSE}
##### Present a table with number of reads supporting this fusion
##### Check if the fusion has abundant transcript(s)
fusion_reads.top <- fusion_reads[ fusion_reads$geneA.name == geneA & fusion_reads$geneB.name == geneB, ]

if( nrow(fusion_reads.top) !=0 ) {
    kable(fusion_reads.top, row.names = FALSE, caption = paste0("Number of reads supporting ", paste(geneA, geneB, sep="-"), " fusion")) %>%
    kable_styling(font_size = 12, "striped", "bordered") %>%
    scroll_box(width = "100%")
}
```

***

##### Fusion genes expression {.tabset}

mRNA expression levels of fusion genes detected in patient's sample and their average mRNA expression (Z-score) in samples from cancer cohorts.

```{r fusion_1_cdf_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 2.5, eval = runFusionChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
cdfPlot(gene = geneA, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode, scaling = scaling)
cdfPlot(gene = geneB, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode, scaling = scaling)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

###### Z-scores

```{r fusion_1_gene_table, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
fusion.df <- ref_datasets.list[[dataset]][["gene_annot"]]
fusion.df <- rbind(fusion.df[fusion.df$SYMBOL==geneA, ], fusion.df[fusion.df$SYMBOL==geneB, ])
genes = fusion.df$SYMBOL
  
exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "z", scaling = scaling)[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

</font>
</details>

***

###### Percentiles

```{r fusion_1_gene_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "perc", scaling = scaling)[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

</font>
</details>

***

#### `r if ( runFusionChunk ) { if ( !is.na(pizzly.fusions$geneA.name[2]) ) { paste(pizzly.fusions$geneA.name[2], pizzly.fusions$geneB.name[2], sep="-") }}`

```{r fusion_2_process, comment = NA, message=TRUE, warning=FALSE, eval = runKallistoChunk}
##### Convert the fusion image from pdf to png and present it in the report
geneA <- as.vector(pizzly.fusions$geneA.name[2])
geneB <- as.vector(pizzly.fusions$geneB.name[2])

if ( !is.na(geneA) && !is.na(geneB) && geneA %in% rownames(data) && geneB %in% rownames(data) ) {
  
  runFusionChunk <- TRUE
} else {
  
  cat("Expression data is not available for one of the genes.")
  runFusionChunk <- FALSE
}

##### Check if clinker fusion plot exists. Skip this section if it doesn't
if ( file.exists(paste0(dataDir, "/clinker/", geneA, "_", geneB, ".pdf")) ) {
  
  runClinkerChunk <- TRUE
} else {
  runClinkerChunk <- FALSE
}
```

##### `r if ( runClinkerChunk ) { c("Fusion genes visualisation") } else { c("") }` 

```{r fusion_2_plot, comment = NA, message=TRUE, warning=FALSE, eval=runClinkerChunk}
##### Check if clinker fusion plot exists. Skip this section if it doesn't
fusion_png(geneA, geneB, paste(dataDir, "clinker", sep="/") )
clinker_fusions <- c(clinker_fusions, paste0(geneA, "-", geneB))
```

```{r fusion_tables_2, comment = NA, message=TRUE, warning=FALSE, eval=FALSE}
##### Present a table with number of reads supporting this fusion
##### Check if the fusion has abundant transcript(s)
fusion_reads.top <- fusion_reads[ fusion_reads$geneA.name == geneA & fusion_reads$geneB.name == geneB, ]

if( nrow(fusion_reads.top) !=0 ) {
    kable(fusion_reads.top, row.names = FALSE, caption = paste0("Number of reads supporting ", paste(geneA, geneB, sep="-"), " fusion")) %>%
    kable_styling(font_size = 12, "striped", "bordered") %>%
    scroll_box(width = "100%")
}
```

***

##### Fusion genes expression {.tabset}

mRNA expression levels of fusion genes detected in patient's sample and their average mRNA expression (Z-score) in samples from cancer cohorts.

```{r fusion_2_cdf_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 2.5, eval = runFusionChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
cdfPlot(gene = geneA, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode, scaling = scaling)
cdfPlot(gene = geneB, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode, scaling = scaling)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

###### Z-scores

```{r fusion_2_gene_table, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
fusion.df <- ref_datasets.list[[dataset]][["gene_annot"]]
fusion.df <- rbind(fusion.df[fusion.df$SYMBOL==geneA, ], fusion.df[fusion.df$SYMBOL==geneB, ])
genes = fusion.df$SYMBOL
  
exprTable( genes = genes, data = data, targets = targets, sampleName  = params$sample_name, ext_cancer  = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes  = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "z", scaling = scaling)[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

</font>
</details>

***

###### Percentiles

```{r fusion_2_gene_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
exprTable( genes = genes, data = data, targets = targets, sampleName  = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes  = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "perc", scaling = scaling)[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

</font>
</details>

***

#### `r if ( runFusionChunk ) { if ( !is.na(pizzly.fusions$geneA.name[3]) ) { paste(pizzly.fusions$geneA.name[3], pizzly.fusions$geneB.name[3], sep="-") }}`

```{r fusion_3_process, comment = NA, message=TRUE, warning=FALSE, eval = runKallistoChunk}
##### Convert the fusion image from pdf to png and present it in the report
geneA <- as.vector(pizzly.fusions$geneA.name[3])
geneB <- as.vector(pizzly.fusions$geneB.name[3])

if ( !is.na(geneA) && !is.na(geneB) && geneA %in% rownames(data) && geneB %in% rownames(data) ) {
  
  runFusionChunk <- TRUE
} else {
  
  cat("Expression data is not available for one of the genes.")
  runFusionChunk <- FALSE
}

##### Check if clinker fusion plot exists. Skip this section if it doesn't
if ( file.exists(paste0(dataDir, "/clinker/", geneA, "_", geneB, ".pdf")) ) {
  
  runClinkerChunk <- TRUE
} else {
  runClinkerChunk <- FALSE
}
```

##### `r if ( runClinkerChunk ) { c("Fusion genes visualisation") } else { c("") }` 

```{r fusion_3_plot, comment = NA, message=TRUE, warning=FALSE, eval=runClinkerChunk}
##### Check if clinker fusion plot exists. Skip this section if it doesn't
fusion_png(geneA, geneB, paste(dataDir, "clinker", sep="/") )
clinker_fusions <- c(clinker_fusions, paste0(geneA, "-", geneB))
```

```{r fusion_3_table, comment = NA, message=TRUE, warning=FALSE, eval=FALSE}
##### Present a table with number of reads supporting this fusion
##### Check if the fusion has abundant transcript(s)
fusion_reads.top <- fusion_reads[ fusion_reads$geneA.name == geneA & fusion_reads$geneB.name == geneB, ]

if( nrow(fusion_reads.top) !=0 ) {
    kable(fusion_reads.top, row.names = FALSE, caption = paste0("Number of reads supporting ", paste(geneA, geneB, sep="-"), " fusion")) %>%
    kable_styling(font_size = 12, "striped", "bordered") %>%
    scroll_box(width = "100%")
}
```

***

##### Fusion genes expression {.tabset}

mRNA expression levels of fusion genes detected in patient's sample and their average mRNA expression (Z-score) in samples from cancer cohorts.

```{r fusion_3_cdf_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 2.5, eval = runFusionChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
cdfPlot(gene = geneA, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode, scaling = scaling)
cdfPlot(gene = geneB, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode, scaling = scaling)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

###### Z-scores

```{r fusion_3_gene_table, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
fusion.df <- ref_datasets.list[[dataset]][["gene_annot"]]
fusion.df <- rbind(fusion.df[fusion.df$SYMBOL==geneA, ], fusion.df[fusion.df$SYMBOL==geneB, ])
genes = fusion.df$SYMBOL
  
exprTable( genes = genes, data = data, targets = targets, sampleName  = params$sample_name, ext_cancer  = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes  = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "z", scaling = scaling)[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

</font>
</details>

***

###### Percentiles

```{r fusions_3_gene_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
exprTable( genes = genes, data = data, targets = targets, sampleName  = params$sample_name, ext_cancer  = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes  = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "perc", scaling = scaling)[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

</font>
</details>

***

#### `r if ( runFusionChunk ) { if ( !is.na(pizzly.fusions$geneA.name[4]) ) { paste(pizzly.fusions$geneA.name[4], pizzly.fusions$geneB.name[4], sep="-") }}`

```{r fusions_4_process, comment = NA, message=TRUE, warning=FALSE, eval = runKallistoChunk}
##### Convert the fusion image from pdf to png and present it in the report
geneA <- as.vector(pizzly.fusions$geneA.name[4])
geneB <- as.vector(pizzly.fusions$geneB.name[4])

if ( !is.na(geneA) && !is.na(geneB) && geneA %in% rownames(data) && geneB %in% rownames(data) ) {
  
  runFusionChunk <- TRUE
} else {
  
  cat("Expression data is not available for one of the genes.")
  runFusionChunk <- FALSE
}

##### Check if clinker fusion plot exists. Skip this section if it doesn't
if ( file.exists(paste0(dataDir, "/clinker/", geneA, "_", geneB, ".pdf")) ) {
  
  runClinkerChunk <- TRUE
} else {
  runClinkerChunk <- FALSE
}
```

##### `r if ( runClinkerChunk ) { c("Fusion genes visualisation") } else { c("") }`  

```{r fusion_4_plot, comment = NA, message=TRUE, warning=FALSE, eval=runClinkerChunk}
##### Check if clinker fusion plot exists. Skip this section if it doesn't
fusion_png(geneA, geneB, paste(dataDir, "clinker", sep="/") )
clinker_fusions <- c(clinker_fusions, paste0(geneA, "-", geneB))
```

```{r fusion_4_table, comment = NA, message=TRUE, warning=FALSE, eval=FALSE}
##### Present a table with number of reads supporting this fusion
##### Check if the fusion has abundant transcript(s)
fusion_reads.top <- fusion_reads[ fusion_reads$geneA.name == geneA & fusion_reads$geneB.name == geneB, ]

if( nrow(fusion_reads.top) !=0 ) {
    kable(fusion_reads.top, row.names = FALSE, caption = paste0("Number of reads supporting ", paste(geneA, geneB, sep="-"), " fusion")) %>%
    kable_styling(font_size = 12, "striped", "bordered") %>%
    scroll_box(width = "100%")
}
```

***

##### Fusion genes expression {.tabset}

mRNA expression levels of fusion genes detected in patient's sample and their average mRNA expression (Z-score) in samples from cancer cohorts.

```{r fusion_4_cdf_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 2.5, eval = runFusionChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
cdfPlot(gene = geneA, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode, scaling = scaling)
cdfPlot(gene = geneB, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode, scaling = scaling)
##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

###### Z-scores

```{r fusion_4_gene_table, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
fusion.df <- ref_datasets.list[[dataset]][["gene_annot"]]
fusion.df <- rbind(fusion.df[fusion.df$SYMBOL==geneA, ], fusion.df[fusion.df$SYMBOL==geneB, ])
genes = fusion.df$SYMBOL
  
exprTable( genes = genes, data = data, targets = targets, sampleName  = params$sample_name, ext_cancer  = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes  = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "z", scaling = scaling)[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

</font>
</details>

***

###### Percentiles

```{r fusion_4_gene_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
exprTable( genes = genes, data = data, targets = targets, sampleName  = params$sample_name, ext_cancer  = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes  = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "perc", scaling = scaling)[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentile in patient sample and reference cancer cohort for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

</font>
</details>

***

#### `r if ( runFusionChunk ) { if ( !is.na(pizzly.fusions$geneA.name[5]) ) { paste(pizzly.fusions$geneA.name[5], pizzly.fusions$geneB.name[5], sep="-") }}`

```{r fusion_5_process, comment = NA, message=TRUE, warning=FALSE, eval = runKallistoChunk}
##### Convert the fusion image from pdf to png and present it in the report
geneA <- as.vector(pizzly.fusions$geneA.name[5])
geneB <- as.vector(pizzly.fusions$geneB.name[5])

if ( !is.na(geneA) && !is.na(geneB) && geneA %in% rownames(data) && geneB %in% rownames(data) ) {
  
  runFusionChunk <- TRUE
} else {
  
  cat("Expression data is not available for one of the genes.")
  runFusionChunk <- FALSE
}

##### Check if clinker fusion plot exists. Skip this section if it doesn't
if ( file.exists(paste0(dataDir, "/clinker/", geneA, "_", geneB, ".pdf")) ) {
  
  runClinkerChunk <- TRUE
} else {
  runClinkerChunk <- FALSE
}

##### Write list of fusion events for which Clinker plot is available into a file
write.table(prepare2write(clinker_fusions), file = paste0(params$report_dir, "/", params$sample_name, ".", params$dataset, ".clinker_fusions.txt"), sep="\t", quote=FALSE, row.names=FALSE, col.names=TRUE, append = FALSE )
```

##### `r if ( runClinkerChunk ) { c("Fusion genes visualisation") } else { c("") }` 

```{r fusion_5_plot, comment = NA, message=TRUE, warning=FALSE, eval=runClinkerChunk}
##### Check if clinker fusion plot exists. Skip this section if it doesn't
fusion_png(geneA, geneB, paste(dataDir, "clinker", sep="/") )
clinker_fusions <- c(clinker_fusions, paste0(geneA, "-", geneB))
```

```{r fusion_5_table, comment = NA, message=TRUE, warning=FALSE, eval=FALSE}
##### Present a table with number of reads supporting this fusion
##### Check if the fusion has abundant transcript(s)
fusion_reads.top <- fusion_reads[ fusion_reads$geneA.name == geneA & fusion_reads$geneB.name == geneB, ]

if( nrow(fusion_reads.top) !=0 ) {
    kable(fusion_reads.top, row.names = FALSE, caption = paste0("Number of reads supporting ", paste(geneA, geneB, sep="-"), " fusion")) %>%
    kable_styling(font_size = 12, "striped", "bordered") %>%
    scroll_box(width = "100%")
}
```

***

##### Fusion genes expression {.tabset}

mRNA expression levels of fusion genes detected in patient's sample and their average mRNA expression (Z-score) in samples from cancer cohorts.

```{r fusion_5_cdf_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 2.5, eval = runFusionChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
cdfPlot(gene = geneA, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode, scaling = scaling)
cdfPlot(gene = geneB, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode, scaling = scaling)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

###### Z-scores

```{r fusion_5_gene_table, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
fusion.df <- ref_datasets.list[[dataset]][["gene_annot"]]
fusion.df <- rbind(fusion.df[fusion.df$SYMBOL==geneA, ], fusion.df[fusion.df$SYMBOL==geneB, ])
genes = fusion.df$SYMBOL
  
  
exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "z", scaling = scaling)[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

</font>
</details>

***

###### Percentiles

```{r fusion_5_gene_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "perc", scaling = scaling)[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

</font>
</details>

***

## Structural variants

mRNA expression levels of genes located within detected structural variants (SVs), obtained from [Manta](https://github.com/Illumina/manta){target="_blank"} structural variant caller, in patient's sample and their average mRNA expression in samples from cancer cohorts.

SVs information for this sample is **`r if ( runSVsChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**. 

### - Summary table {.tabset}

Out of the `r if ( runSVsChunk ) { length(unique(manta_sv$Gene)) } ` genes affected by `r if ( runSVsChunk ) { nrow(manta_sv) }` SVs, the expression of **`r if ( runSVsChunk ) { length(which(unique(manta_sv$Gene) %in% rownames(ref_datasets.list[[dataset]][["batch_effect_corrected"]]))) }`** was reliably measured in patient's sample. The remaining `r if ( runSVsChunk ) { length(which(unique(manta_sv$Gene) %!in% rownames(ref_datasets.list[[dataset]][["batch_effect_corrected"]]))) }` genes are either not expressed or their expression level is too low to be detected (indicated in <span style="color:#808080">BLANK</span> cells with missing values).

#### Z-scores

```{r sv_genes_table, comment = NA, message=FALSE, warning=FALSE, eval = runSVsChunk}
##### Generate expression summary table for cancer genes from OncoKB and PMCC
targets <- ref_datasets.list[[dataset]][["sample_annot"]]
data <- ref_datasets.list[[dataset]][["batch_effect_corrected"]]

##### Consider only genes with mutations calssified within user-defined tiers
genes <- unique(manta_sv$Gene)

##### Consider only genes in MANTA output for which the expression levels were measured
genes <- unique(manta_sv$Gene)
genes <- genes[ genes %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ]

##### Deal with no genes
if ( length(genes) == 0 ) {
  
  genes <- NULL
}

sv_genes.expr.z <- exprTable( genes = genes, data = data, sv_data = manta_sv, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "z", scaling = scaling)

##### Present the expression summary table
sv_genes.expr.z[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=sv_genes.expr.z[[1]], file=paste(exprTableDir, "sv_genes.expr.z.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **increasing SV score** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

**Score**: SV priority score based on AstraZeneca [simple_sv_annotation.py](https://github.com/AstraZeneca-NGS/simple_sv_annotation/blob/master/simple_sv_annotation.py#L21-L36){target="_blank"} script; **1 = high** and **3 = low priority**

</font>
</details>

***

#### Percentiles

```{r sv_genes_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runSVsChunk}
##### Generate expression summary table for cancer genes from OncoKB and PMCC
sv_genes.expr.perc <- exprTable( genes = genes, data = data, sv_data = manta_sv, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "perc", scaling = scaling)

##### Present the expression summary table
sv_genes.expr.perc[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=sv_genes.expr.perc[[1]], file=paste(exprTableDir, "sv_genes.expr.perc.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **increasing SV score** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) columns. TSG - tumour suppressor gene; SD - standard deviation across groups

**Score**: SV priority score based on AstraZeneca [simple_sv_annotation.py](https://github.com/AstraZeneca-NGS/simple_sv_annotation/blob/master/simple_sv_annotation.py#L21-L36) script; *1 = high* and *3 = low priority*

</font>
</details>

***

### - Expression gene profiles {.tabset}

Expression profiles for 10 SVs-affected genes with the highest priority (low [tier](https://github.com/AstraZeneca-NGS/simple_sv_annotation/blob/master/simple_sv_annotation.py#L21-L36){target="_blank"}) and demonstrating the greatest difference in standarised (Z-score) mRNA expression values between patient's sample and the average mRNA expression in samples from cancer patients.

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[1]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[1] }`

```{r cdf_plot_sv_genes_1, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[1]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[2]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[2] }`

```{r cdf_plot_sv_genes_2, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[2]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[3]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[3] }`

```{r cdf_plot_sv_genes_3, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[3]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}
##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[4]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[4] }`

```{r cdf_plot_sv_genes_4, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[4]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[5]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[5] }`

```{r cdf_plot_sv_genes_5, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[5]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[6]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[6] }`

```{r cdf_plot_sv_genes_6, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[6]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[7]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[7] }`

```{r cdf_plot_sv_genes_7, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[7]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[8]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[8] }`

```{r cdf_plot_sv_genes_8, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[8]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[9]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[9] }`

```{r cdf_plot_sv_genes_9, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[9]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[10]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[10] }`

```{r cdf_plot_sv_genes_10, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[10]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

## CN altered genes

Section overlaying the mRNA expression data with per-gene somatic copy-number (CN) data (from [PURPLE](https://anaconda.org/bioconda/hmftools-purple){target="_blank"}) and mutation status, if available.

CN information for this sample is **`r if ( runPurpleChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**.

### - Expression vs CN

Scatterplot comparing the per-gene difference in **mRNA expression** (Z-scores) between patient's sample and cancer individuals (*y-axis*), **CN values** (*x-axis*, from [PURPLE](https://anaconda.org/bioconda/hmftools-purple){target="_blank"}). If the mutation status information is available then the genes's colours correspond to the variant(s) consequence (from [PCGR](https://github.com/sigven/pcgr){target="_blank"}). Genes with CN values > 3 or < 0.5 are annotated. NOTE: only [Cancer genes], [Mutated genes] with [tier](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg){target="_blank"} 1-`r params$pcgr_tier` variants (if mutation information is available), genes involved in [Fusion genes] and [Structural variants] (if SV information is available) are presented.

```{r mut_cn_expr_data_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
##### Generate scatterplot with per-gene expression values (y-axis), CN values (x-axis) and mutation status info (colours)
suppressMessages(library(plotly))

data <- ref_datasets.list[[dataset]][["expr_mut_cn_data"]]

##### Limit the data to include only cancer genes
cn_genes <- as.vector(data$Gene[ data$Gene %in% rownames(ref_genes.list[["genes_cancer"]]) ])

##### Add fusion genes
if ( runFusionChunk ) {
  
  cn_genes <- c( unique(cn_genes, pizzly.fusions.cut$geneA.name) )
  cn_genes <- c( unique(cn_genes, pizzly.fusions.cut$geneB.name) )
}
            
##### Add genes involved in SVs (if data available)
if ( runSVsChunk ) {
  cn_genes <- c( unique(cn_genes, unique(manta_sv$Gene)) )
}

if ( runPcgrChunk && length(cn_genes) > 0 ) {
  
  ##### Add mutated genes with vatiants within user-defined tiers
  cn_genes <- c( unique(cn_genes, ref_genes.list[["pcgr"]][ ref_genes.list[["pcgr"]]$TIER %in% c(1:params$pcgr_tier), ]$SYMBOL) )
  data <- data[ data$Gene %in% cn_genes, ]
 
  mutCNexprPlot(data = data, mut_data = TRUE, cn_bottom = 0.5, cn_top = 3, comp_cancer = comp_cancer_group, plot_mode = params$plots_mode)
  
} else if ( length(cn_genes) > 0) {
  
  data <- data[ data$Gene %in% cn_genes, ]
  mutCNexprPlot(data = data, mut_data = FALSE, cn_bottom = 0.5, cn_top = 3, comp_cancer = comp_cancer_group, plot_mode = params$plots_mode)
  
} else {
  
  cn_genes <- NULL
  cat("None of the genes of interest are affected by changes in CN.")
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

<details>
<summary>CN data distribution</summary>

`r if ( runPurpleChunk ) { c(" ") } else { c("CN information for this sample is NOT AVAILABLE.") }`


```{r cn_data_distribution_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 9, eval = runPurpleChunk }
##### Generate a histogram illustrating CN data distribution
suppressMessages(library(plotly))

if ( params$plots_mode == "static" ) {

  PlotsDir <- paste(params$report_dir, "CNdataPlots", sep = "/")
  if ( !file.exists(PlotsDir) ) {
      
    dir.create(PlotsDir, recursive=TRUE)
  }
        
  ##### Add access token, required by orca function, to the shell environment
  Sys.setenv('MAPBOX_TOKEN' = 'secret token')
  
  ##### Change directory to folder with CDF plots
  setwd(PlotsDir)
 
  ##### Save the static image into a file
  orca(cn_dist_plot, format = "png", file = "cn_data_dist_plot.png", width = 1200, height = 600)
  
  ##### Present the static plot in the report
  include_graphics(paste(PlotsDir, "cn_data_dist_plot.png", sep = "/"), dpi = 144)
    
} else if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {

  cn_dist_plot
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

</details>

***

### - Summary table {.tabset}

Out of the `r length(ref_datasets.list[[dataset]][["expr_mut_cn_data"]][,1])` genes within gained (CN values > `r params$cn_gain`) or lossed (CN values < `r params$cn_loss`) regions `r if (runPurpleChunk) { length(cn_genes) } else { length(NULL) }` are either [Cancer genes], [Mutated genes] with [tier](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg){target="_blank"} 1-`r params$pcgr_tier` variants (if mutation information is available) or are involved in [Fusion genes] or [Structural variants] (if SV information is available). The expression of **`r if (runPurpleChunk) { length(which(cn_genes %in% rownames(ref_datasets.list[[dataset]][["batch_effect_corrected"]]))) } else { length(NULL) }`** of these genes was reliably measured in patient's sample. The remaining `r if (runPurpleChunk) { length(which(cn_genes %!in% rownames(ref_datasets.list[[dataset]][["batch_effect_corrected"]]))) } else { length(NULL) }` genes are either not expressed or their expression level is too low to be detected (indicated in <span style="color:#808080">BLANK</span> cells with missing values).

#### Gains {.tabset}

Table summarising the **mRNA expression** values in cancer and patient samples for genes with **CN** values > `r params$cn_gain` (**gains**), based on patient's genomic data (from [PURPLE](https://anaconda.org/bioconda/hmftools-purple){target="_blank"}), and mutation status if available (from [PCGR](https://github.com/sigven/pcgr){target="_blank"}).

##### Z-scores

```{r mut_cn_expr_data_table_gains, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
##### Generate expression summary table for per-gene expression values CN values and mutation status info (colours)
##### Keep only genes within CN gains
cn_data <- ref_datasets.list[[dataset]][["expr_mut_cn_data"]]
cn_data <- cn_data[ cn_data$CN > params$cn_gain, ]
cn_data <- cn_data[, "CN", drop=FALSE]
genes = cn_genes[ cn_genes %in% rownames(cn_data) ]

##### Get expression data
data <- ref_datasets.list[[dataset]][["batch_effect_corrected"]]

if ( runPcgrChunk && runPurpleChunk ) {
    
  mut_cn_expr_genes.expr.gains.z <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = TRUE, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], mut_annot = ref_genes.list[["pcgr"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "z", scaling = scaling)
  
##### Generate expression summary table for per-gene expression values and CN values
} else if ( runPurpleChunk ) {
    
  mut_cn_expr_genes.expr.gains.z <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = TRUE, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "z", scaling = scaling)
}
  
##### Present the expression, CN and mutation data summary table
mut_cn_expr_genes.expr.gains.z[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=mut_cn_expr_genes.expr.gains.z[[1]], file=paste(exprTableDir, "mut_cn_expr_genes.expr.gains.z.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each gene. The **CN values** based on patient's genomic data are presented in *Patient (CN)* column with a horizontal blue bar indicating the CN value of each gene in the context of other genes. If mutation data is availbale, then the variants’ tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided on right-hand side based on information from [PCGR](https://github.com/sigven/pcgr){target="_blank"} report (similar to [Mutated genes] section). Genes are ordered by **Patient (CN)** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) columns. SD - standard deviation across groups; CN - copy-number

</font>
</details>

***

##### Percentiles

```{r mut_cn_expr_data_table_gains_perc, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate expression summary table for per-gene expression values CN values and mutation status info (colours)
if ( runPcgrChunk && runPurpleChunk ) {
    
  mut_cn_expr_genes.expr.gains.perc <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = TRUE, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], mut_annot = ref_genes.list[["pcgr"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "perc", scaling = scaling)
  
##### Generate expression summary table for per-gene expression values and CN values
} else if ( runPurpleChunk ) {
  
  mut_cn_expr_genes.expr.gains.perc <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = TRUE, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "perc", scaling = scaling)
}
  
##### Present the expression, CN and mutation data summary table
mut_cn_expr_genes.expr.gains.perc[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=mut_cn_expr_genes.expr.gains.perc[[1]], file=paste(exprTableDir, "mut_cn_expr_genes.expr.gains.perc.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each gene. The **CN values** based on patient's genomic data are presented in *Patient (CN)* column with a horizontal blue bar indicating the CN value of each gene in the context of other genes. If mutation data is availbale, then the variants’ tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided on right-hand side based on information from [PCGR](https://github.com/sigven/pcgr){target="_blank"} report (similar to [Mutated genes] section). Genes are ordered by **Patient (CN)** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) columns. SD - standard deviation across groups; CN - copy-number

</font>
</details>

***

#### Losses {.tabset}

Table summarising the **mRNA expression** values in cancer and patient samples for genes with **CN** values < `r params$cn_loss` (**losses**), based on patient's genomic data (from [PURPLE](https://anaconda.org/bioconda/hmftools-purple){target="_blank"}), and mutation status if available (from [PCGR](https://github.com/sigven/pcgr){target="_blank"}).

##### Z-scores

```{r mut_cn_expr_data_table_losses, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate expression summary table for per-gene expression values CN values and mutation status info (colours)
##### Keep only genes within CN losses
cn_data <- ref_datasets.list[[dataset]][["expr_mut_cn_data"]]
cn_data <- cn_data[ cn_data$CN < params$cn_loss, ]
cn_data <- cn_data[, "CN", drop=FALSE]
genes = cn_genes[ cn_genes %in% rownames(cn_data) ]

##### Get expression data
data <- ref_datasets.list[[dataset]][["batch_effect_corrected"]]
    
if ( runPcgrChunk && runPurpleChunk ) {
    
  mut_cn_expr_genes.expr.losses.z <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = FALSE, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], mut_annot = ref_genes.list[["pcgr"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "z", scaling = scaling)
  
##### Generate expression summary table for per-gene expression values and CN values
} else if ( runPurpleChunk ) {
    
  mut_cn_expr_genes.expr.losses.z <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = FALSE, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "z", scaling = scaling)
}
  
##### Present the expression, CN and mutation data summary table
mut_cn_expr_genes.expr.losses.z[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=mut_cn_expr_genes.expr.losses.z[[1]], file=paste(exprTableDir, "mut_cn_expr_genes.expr.losses.z.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each gene. The **CN values** based on patient's genomic data are presented in *Patient (CN)* column with a horizontal blue bar indicating the CN value of each gene in the context of other genes. If mutation data is availbale, then the variants’ tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided on right-hand side based on information from [PCGR](https://github.com/sigven/pcgr){target="_blank"} report (similar to [Mutated genes] section). Genes are ordered by **Patient (CN)** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) columns. SD - standard deviation across groups; CN - copy-number

</font>
</details>

***

##### Percentiles

```{r mut_cn_expr_data_table_losses_perc, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate expression summary table for per-gene expression values CN values and mutation status info (colours)
if ( runPcgrChunk && runPurpleChunk ) {
    
  mut_cn_expr_genes.expr.losses.perc <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = FALSE, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], mut_annot = ref_genes.list[["pcgr"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "perc", scaling = scaling)
  
##### Generate expression summary table for per-gene expression values and CN values
} else if ( runPurpleChunk ) {
  
  mut_cn_expr_genes.expr.losses.perc <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = FALSE, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "perc", scaling = scaling)
}
  
##### Present the expression, CN and mutation data summary table
mut_cn_expr_genes.expr.losses.perc[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=mut_cn_expr_genes.expr.losses.perc[[1]], file=paste(exprTableDir, "mut_cn_expr_genes.expr.losses.perc.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each gene. The **CN values** based on patient's genomic data are presented in *Patient (CN)* column with a horizontal blue bar indicating the CN value of each gene in the context of other genes. If mutation data is availbale, then the variants’ tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided on right-hand side based on information from [PCGR](https://github.com/sigven/pcgr){target="_blank"} report (similar to [Mutated genes] section). Genes are ordered by **Patient (CN)** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) columns. SD - standard deviation across groups; CN - copy-number

</font>
</details>

***

### - Expression gene profiles {.tabset}

Expression profiles for 5 genes with the highest (**gains**) and 5 genes with the lowest (**losses**) CN values and the greatest difference in standarised (Z-score) mRNA expression values between patient's sample and the average mRNA expression in samples from cancer patients.

#### Gains {.tabset}

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL)[1]) ) { mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[1] }`

```{r cdf_plot_mut_cn_expr_gains_genes_1, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[1]
  
##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL), "genes mapped to detected gained regions!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL)[2]) ) { mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[2] }`

```{r cdf_plot_mut_cn_expr_gains_genes_2, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[2]
  
##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL), "genes mapped to detected gained regions!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL)[3]) ) { mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[3] }`

```{r cdf_plot_mut_cn_expr_gains_genes_3, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[3]
  
##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL), "genes mapped to detected gained regions!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL)[4]) ) { mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[4] }`

```{r cdf_plot_mut_cn_expr_gains_genes_4, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[4]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL), "genes mapped to detected gained regions!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL)[5]) ) { mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[5] }`

```{r cdf_plot_mut_cn_expr_gains_genes_5, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[5]
  
##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL), "genes mapped to detected gained regions!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### Losses {.tabset}

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL)[1]) ) { mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[1] }`

```{r cdf_plot_mut_cn_expr_losses_genes_1, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[1]
  
##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL), "genes mapped to detected lossed regions!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL)[2]) ) { mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[2] }`

```{r cdf_plot_mut_cn_expr_losses_genes_2, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[2]
  
##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL), "genes mapped to detected lossed regions!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL)[3]) ) { mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[3] }`

```{r cdf_plot_mut_cn_expr_losses_genes_3, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[3]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL), "genes mapped to detected lossed regions!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL)[4]) ) { mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[4] }`

```{r cdf_plot_mut_cn_expr_losses_genes_4, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[4]
  
##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL), "genes mapped to detected lossed regions!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL)[5]) ) { mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[5] }`

```{r cdf_plot_mut_cn_expr_losses_genes_5, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[5]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode, scaling = scaling)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL), "genes mapped to detected lossed regions!", sep=" "))
  } else if ( gene %in% ref_datasets.list[[dataset]][["gene_annot_all"]]$SYMBOL ) {
    cat(paste(gene, "is not expressed!", sep=" "))
  } else {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

## Immune markers

Section presenting expression levels of immune markers to assess pre-existing anti-cancer immunity and likelihood of response to immunotherapy. Their mRNA expression levels are presented in patient's sample along their average mRNA expression in samples from cancer cohorts.

Out of the `r length(unique(unlist(ref_genes.list[["genes_immune"]]$SYMBOL)))` immune markers the expression of **`r length(which(unique(unlist(ref_genes.list[["genes_immune"]]$SYMBOL)) %in% rownames(ref_datasets.list[[dataset]][["batch_effect_corrected"]])))`** was reliably measured in patient's sample. The remaining `r length(which(unique(unlist(ref_genes.list[["genes_immune"]]$SYMBOL)) %!in% rownames(ref_datasets.list[[dataset]][["batch_effect_corrected"]])))` genes are either not expressed or their expression level is too low to be detected (indicated in <span style="color:#808080">BLANK</span> cells with missing values).

### - Summary table {.tabset}

#### Z-scores

```{r immune_genes_table, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for cancer genes from OncoKB and PMCC
targets <- ref_datasets.list[[dataset]][["sample_annot"]]
data <- ref_datasets.list[[dataset]][["batch_effect_corrected"]]
genes <- unique(unlist(ref_genes.list[["genes_immune"]]$SYMBOL))

##### Deal with no genes
if ( length(genes) == 0 ) {
  
  genes <- NULL
}

immune_genes.expr.z <- exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL", "Immune_Cycle_Role")], ext_links = TRUE, type = "z", scaling = scaling)

##### Present the expression summary table
immune_genes.expr.z[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=immune_genes.expr.z[[1]], file=paste(exprTableDir, "immune_genes.expr.z.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each immune marker. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. SD - standard deviation across groups

</font>
</details>

***

#### Percentiles

```{r immune_genes_table_perc, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for cancer genes from OncoKB and PMCC
immune_genes.expr.perc <- exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL", "Immune_Cycle_Role")], ext_links = TRUE, type = "perc", scaling = scaling)

##### Present the expression summary table
immune_genes.expr.perc[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=immune_genes.expr.perc[[1]], file=paste(exprTableDir, "immune_genes.expr.perc.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each immune marker. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

</font>
</details>

***

### - Expression overview

Overview of immune markers expression profiles in patient's sample and in samples from cancer patients.

```{r glance_expr_plot_immune_genes, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))

##### Generate overview boxplot
if ( !is.null(genes) ) {
  glanceExprPlot(genes = genes, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, plot_mode = params$plots_mode, hexcode = "immune_genes", scaling = scaling)

} else {
  cat("No expression data is available for immune markers!")
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

<details>
<summary>Plot legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> and <span style="color:#0000ff">BLUE</span> boxes represent the `r int_cancer_group` and `r ext_cancer_group` reference cancer cohorts, respectively, and the **BLACK** dots indicate expression (Z-score) values for each gene in the patient sample. Genes are ordered by **increasing** median expression (Z-score) values in the **`r comp_cancer_group`** cohort.

</font>
</details>

***

## HRD genes

Section presenting expression levels of homologous recombination deficiency (HRD) genes to assess how many of these demonstrate low expression, which may indicate potential promoter methylation events. Their mRNA expression levels are presented in patient's sample along their average mRNA expression in samples from cancer cohorts.

Out of the `r length(unique(unlist(ref_genes.list[["genes_hrd"]]$SYMBOL)))` hrd genes the expression of **`r length(which(unique(unlist(ref_genes.list[["genes_hrd"]]$SYMBOL)) %in% rownames(ref_datasets.list[[dataset]][["batch_effect_corrected"]])))`** was reliably measured in patient's sample. The remaining `r length(which(unique(unlist(ref_genes.list[["genes_hrd"]]$SYMBOL)) %!in% rownames(ref_datasets.list[[dataset]][["batch_effect_corrected"]])))` genes are either not expressed or their expression level is too low to be detected (indicated in <span style="color:#808080">BLANK</span> cells with missing values).

### - Summary table {.tabset}

#### Z-scores

```{r hrd_genes_table, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for hrd genes from Richqrd
targets <- ref_datasets.list[[dataset]][["sample_annot"]]
data <- ref_datasets.list[[dataset]][["batch_effect_corrected"]]
genes <- unique(unlist(ref_genes.list[["genes_hrd"]]$SYMBOL))

##### Deal with no genes
if ( length(genes) == 0 ) {
  
  genes <- NULL
}

hrd_genes.expr.z <- exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], ext_links = TRUE, type = "z", scaling = scaling)

##### Present the expression summary table
hrd_genes.expr.z[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=hrd_genes.expr.z[[1]], file=paste(exprTableDir, "hrd_genes.expr.z.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each HRD gene. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. SD - standard deviation across groups

</font>
</details>

***

#### Percentiles

```{r hrd_genes_table_perc, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for hrd genes from Richard
hrd_genes.expr.perc <- exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, genes_annot = ref_datasets.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], ext_links = TRUE, type = "perc", scaling = scaling)

##### Present the expression summary table
hrd_genes.expr.perc[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=hrd_genes.expr.perc[[1]], file=paste(exprTableDir, "hrd_genes.expr.perc.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each HRD gene. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. TSG - tumour suppressor gene; SD - standard deviation across groups

</font>
</details>

***

### - Expression overview

Overview of HRD genes expression profiles in patient's sample and in samples from cancer patients.

```{r glance_expr_plot_hrd_genes, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))

##### Generate overview boxplot
if ( !is.null(genes) ) {
  glanceExprPlot(genes = genes, data = data, targets = targets, sampleName = params$sample_name, ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, comp_cancer = comp_cancer_group, plot_mode = params$plots_mode, hexcode = "hrd_genes", scaling = scaling)

} else {
  cat("No expression data is available for HRD genes!")
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

<details>
<summary>Plot legend</summary>
<font size="2">

The <span style="color:#ff0000">RED</span> and <span style="color:#0000ff">BLUE</span> boxes represent the `r int_cancer_group` and `r ext_cancer_group` reference cancer cohorts, respectively, and the **BLACK** dots indicate expression (Z-score) values for each gene in the patient sample. Genes are ordered by **increasing** median expression (Z-score) values in the **`r comp_cancer_group`** cohort.

</font>
</details>

***

## Drug matching

List of drugs targeting variants in detected [Mutated genes], dysregulated [Cancer genes], [Fusion genes], [Structural variants]-affected genes and [CN altered genes], which can be considered in the treatment decision making process. The clinically actionable aberrations are matched based on information provided by *[clinical interpretations of variants in Cancer](https://civicdb.org/home){target="_blank"}* (CIViC) ([Griffith et al. (2017)](https://www.ncbi.nlm.nih.gov/pubmed/28138153){target="_blank"}). The evidence pertaining to variants effect on therapeutic response is also provided.

### - Mutated genes

Mutation data for this sample is **`r if ( runPcgrChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**.

**`r length(unique(ref_genes.list[["pcgr"]][ ref_genes.list[["pcgr"]]$TIER %in% c(1:params$pcgr_tier), ]$SYMBOL))`** genes with PCGR [tier](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg){target="_blank"} 1-`r params$pcgr_tier` variants were screened for suitable drugs (see [Mutated genes] section).

```{r drugs_predictive_mut_genes, comment = NA, message=FALSE, warning=FALSE, eval = runPcgrChunk}
##### Generate table with drugs targeting mutated cancer genes
genes <- mut_genes.expr.z[[2]]$SYMBOL

drugsTable.mut_genes <- civicDrugTable(genes, civic_var_summaries = caner_genes_annot.list[["civic_var_summaries"]], civic_clin_evid = caner_genes_annot.list[["civic_clin_evid"]],  evid_type = "Predictive", var_type = "mutation")

drugsTable.mut_genes[[1]]

##### Create directory for tables
drugsTableDir <- paste(params$report_dir, "drugsTables", sep = "/")

if ( !file.exists(drugsTableDir) ) {

        dir.create(drugsTableDir, recursive=TRUE)
}

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=drugsTable.mut_genes[[1]], file=paste(drugsTableDir, "drugsTable.mut_genes.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

**[Evidence Level](https://civicdb.org/help/evidence/evidence-levels){target="_blank"}**

* **A - Validated association**: Proven/consensus association in human medicine
* **B - Clinical evidence**: Clinical trial or other primary patient data supports association
* **C - Case study**: Individual case reports from clinical journals
* **D - Preclinical evidence**: *In vivo* or *in vitro* models support association
* **E - Inferential association**: Indirect evidence

**[Trust Rating](https://civicdb.org/help/evidence/trust-ratings){target="_blank"}**

* **5**: Strong, well supported evidence from a lab or journal with respected academic standing. Experiments are well controlled, and results are clean and reproducible across multiple replicates. Evidence confirmed using independent methods. The study is statistically well powered
* **4**: Strong, well supported evidence. Experiments are well controlled, and results are convincing. Any discrepancies from expected results are well-explained and not concerning
* **3**: Evidence is convincing, but not supported by a breadth of experiments. May be smaller scale projects, or novel results without many follow-up experiments. Discrepancies from expected results are explained and not concerning
* **2**: Evidence is not well supported by experimental data, and little follow-up data is available. Publication is from a journal with low academic impact. Experiments may lack proper controls, have small sample size, or are not statistically convincing
* **1**: Claim is not supported well by experimental evidence. Results are not reproducible, or have very small sample size. No follow-up is done to validate novel claims

**[Actionability Score ](https://civicdb.org/help/variants/actionability-score){target="_blank"}**

* [CIViC Actionability Score](https://civicdb.org/help/variants/actionability-score){target="_blank"} allows to assess the accumulation of evidence for each variant. It is calculated by adding all Evidence Item Scores for each variant. The Evidence Item Score is calculated by multiplying the evidence level (A=10 points, B=5 points, C=3 points, D=1 point, E=0.25 points) by the trust rating (each Star = 1 point).

</font> 
</details>

***

### - Cancer genes

**50** cancer genes with the greatest difference in standarised (Z-score) mRNA expression values between patient's sample and the average mRNA expression in samples from cancer patients were screened for suitable drugs (see [Cancer genes] section).

```{r drugs_predictive_cancer_genes, comment = NA, message=FALSE, warning=FALSE}
##### Generate table with drugs targeting dysregulated cancer genes
data <- ref_datasets.list[[dataset]][["batch_effect_corrected"]]
genes <- cancer_genes.expr.z[[2]]$SYMBOL[1:50]

drugsTable.cancer_genes <- civicDrugTable(genes, civic_var_summaries  = caner_genes_annot.list[["civic_var_summaries"]], civic_clin_evid  = caner_genes_annot.list[["civic_clin_evid"]],  evid_type = "Predictive", var_type = "expression")

drugsTable.cancer_genes[[1]]

##### Create directory for tables
drugsTableDir <- paste(params$report_dir, "drugsTables", sep = "/")

if ( !file.exists(drugsTableDir) ) {

        dir.create(drugsTableDir, recursive=TRUE)
}

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=drugsTable.cancer_genes[[1]], file=paste(drugsTableDir, "drugsTable.cancer_genes.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

**[Evidence Level](https://civicdb.org/help/evidence/evidence-levels){target="_blank"}**

* **A - Validated association**: Proven/consensus association in human medicine
* **B - Clinical evidence**: Clinical trial or other primary patient data supports association
* **C - Case study**: Individual case reports from clinical journals
* **D - Preclinical evidence**: *In vivo* or *in vitro* models support association
* **E - Inferential association**: Indirect evidence

**[Trust Rating](https://civicdb.org/help/evidence/trust-ratings){target="_blank"}**

* **5**: Strong, well supported evidence from a lab or journal with respected academic standing. Experiments are well controlled, and results are clean and reproducible across multiple replicates. Evidence confirmed using independent methods. The study is statistically well powered
* **4**: Strong, well supported evidence. Experiments are well controlled, and results are convincing. Any discrepancies from expected results are well-explained and not concerning
* **3**: Evidence is convincing, but not supported by a breadth of experiments. May be smaller scale projects, or novel results without many follow-up experiments. Discrepancies from expected results are explained and not concerning
* **2**: Evidence is not well supported by experimental data, and little follow-up data is available. Publication is from a journal with low academic impact. Experiments may lack proper controls, have small sample size, or are not statistically convincing
* **1**: Claim is not supported well by experimental evidence. Results are not reproducible, or have very small sample size. No follow-up is done to validate novel claims

**[Actionability Score ](https://civicdb.org/help/variants/actionability-score){target="_blank"}**

* [CIViC Actionability Score](https://civicdb.org/help/variants/actionability-score){target="_blank"} allows to assess the accumulation of evidence for each variant. It is calculated by adding all Evidence Item Scores for each variant. The Evidence Item Score is calculated by multiplying the evidence level (A=10 points, B=5 points, C=3 points, D=1 point, E=0.25 points) by the trust rating (each Star = 1 point).

</font> 
</details>

***

### - Fusion genes {.tabset}

Fusion genes information for this sample is **`r if ( runFusionChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**. 

<span style="color:#ff0000">**`r if ( runFusionChunk ) { nrow(pizzly.fusions.cut[ pizzly.fusions.cut$geneA_dna_support == "Yes" | pizzly.fusions.cut$geneB_dna_support == "Yes" , ]) } else { c("0") }`**</span> involving **DNA-supported** fusion genes (see [Structural variants] section) and <span style="color:#02d653">**`r if ( runFusionChunk ) { nrow(pizzly.fusions.cut[ pizzly.fusions.cut$reported_fusion == "Yes" , ]) } else { c("0") }`**</span> gene fusions **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}** were screened for suitable drugs.

**`r if ( !runFusionChunk ) { c("No fusion genes were detected!") }`**

```{r drugs_predictive_fusion_genes, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
##### Generate table with drugs targeting fusion genes
data <- ref_datasets.list[[dataset]][["batch_effect_corrected"]]
genesA <- as.vector(pizzly.fusions[ fusion_annot$reported_fusion == "Yes" | fusion_annot$geneA_dna_support == "Yes" | fusion_annot$geneB_dna_support == "Yes", ]$geneA.name)
genesB <- as.vector(pizzly.fusions[ fusion_annot$reported_fusion == "Yes" | fusion_annot$geneA_dna_support == "Yes" | fusion_annot$geneB_dna_support == "Yes", ]$geneB.name)

drugsTable.fusion_genes <- civicDrugTable(genes = unique(c(genesA, genesB)), civic_var_summaries  = caner_genes_annot.list[["civic_var_summaries"]], civic_clin_evid  = caner_genes_annot.list[["civic_clin_evid"]],  evid_type = "Predictive", var_type = "fusion")

drugsTable.fusion_genes[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=drugsTable.fusion_genes[[1]], file=paste(drugsTableDir, "drugsTable.fusion_genes.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

**[Evidence Level](https://civicdb.org/help/evidence/evidence-levels){target="_blank"}**

* **A - Validated association**: Proven/consensus association in human medicine
* **B - Clinical evidence**: Clinical trial or other primary patient data supports association
* **C - Case study**: Individual case reports from clinical journals
* **D - Preclinical evidence**: *In vivo* or *in vitro* models support association
* **E - Inferential association**: Indirect evidence

**[Trust Rating](https://civicdb.org/help/evidence/trust-ratings){target="_blank"}**

* **5**: Strong, well supported evidence from a lab or journal with respected academic standing. Experiments are well controlled, and results are clean and reproducible across multiple replicates. Evidence confirmed using independent methods. The study is statistically well powered
* **4**: Strong, well supported evidence. Experiments are well controlled, and results are convincing. Any discrepancies from expected results are well-explained and not concerning
* **3**: Evidence is convincing, but not supported by a breadth of experiments. May be smaller scale projects, or novel results without many follow-up experiments. Discrepancies from expected results are explained and not concerning
* **2**: Evidence is not well supported by experimental data, and little follow-up data is available. Publication is from a journal with low academic impact. Experiments may lack proper controls, have small sample size, or are not statistically convincing
* **1**: Claim is not supported well by experimental evidence. Results are not reproducible, or have very small sample size. No follow-up is done to validate novel claims

**[Actionability Score ](https://civicdb.org/help/variants/actionability-score){target="_blank"}**

* [CIViC Actionability Score](https://civicdb.org/help/variants/actionability-score){target="_blank"} allows to assess the accumulation of evidence for each variant. It is calculated by adding all Evidence Item Scores for each variant. The Evidence Item Score is calculated by multiplying the evidence level (A=10 points, B=5 points, C=3 points, D=1 point, E=0.25 points) by the trust rating (each Star = 1 point).

</font> 
</details>

***

### - Structural variants

SVs information for this sample is **`r if ( runSVsChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**. 

**`r if ( runSVsChunk ) { length(unique(manta_sv$Gene)) } else { length(NULL) }`** genes affected by structural variants (SVs) were screened for suitable drugs (see [Structural variants] section).

```{r drugs_predictive_sv_genes, comment = NA, message=FALSE, warning=FALSE, eval = runSVsChunk}
##### Generate table with drugs targeting dysregulated cancer genes
data <- ref_datasets.list[[dataset]][["batch_effect_corrected"]]
genes <- unique(manta_sv$Gene)

drugsTable.sv_genes <- civicDrugTable(genes, civic_var_summaries  = caner_genes_annot.list[["civic_var_summaries"]], civic_clin_evid  = caner_genes_annot.list[["civic_clin_evid"]],  evid_type = "Predictive", var_type = NULL)

drugsTable.sv_genes[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=drugsTable.sv_genes[[1]], file=paste(drugsTableDir, "drugsTable.sv_genes.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

**[Evidence Level](https://civicdb.org/help/evidence/evidence-levels){target="_blank"}**

* **A - Validated association**: Proven/consensus association in human medicine
* **B - Clinical evidence**: Clinical trial or other primary patient data supports association
* **C - Case study**: Individual case reports from clinical journals
* **D - Preclinical evidence**: *In vivo* or *in vitro* models support association
* **E - Inferential association**: Indirect evidence

**[Trust Rating](https://civicdb.org/help/evidence/trust-ratings){target="_blank"}**

* **5**: Strong, well supported evidence from a lab or journal with respected academic standing. Experiments are well controlled, and results are clean and reproducible across multiple replicates. Evidence confirmed using independent methods. The study is statistically well powered
* **4**: Strong, well supported evidence. Experiments are well controlled, and results are convincing. Any discrepancies from expected results are well-explained and not concerning
* **3**: Evidence is convincing, but not supported by a breadth of experiments. May be smaller scale projects, or novel results without many follow-up experiments. Discrepancies from expected results are explained and not concerning
* **2**: Evidence is not well supported by experimental data, and little follow-up data is available. Publication is from a journal with low academic impact. Experiments may lack proper controls, have small sample size, or are not statistically convincing
* **1**: Claim is not supported well by experimental evidence. Results are not reproducible, or have very small sample size. No follow-up is done to validate novel claims

**[Actionability Score ](https://civicdb.org/help/variants/actionability-score){target="_blank"}**

* [CIViC Actionability Score](https://civicdb.org/help/variants/actionability-score){target="_blank"} allows to assess the accumulation of evidence for each variant. It is calculated by adding all Evidence Item Scores for each variant. The Evidence Item Score is calculated by multiplying the evidence level (A=10 points, B=5 points, C=3 points, D=1 point, E=0.25 points) by the trust rating (each Star = 1 point).

</font> 
</details>

***

### - CN altered genes {.tabset}

CN information for this sample is **`r if ( runPurpleChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**.

**`r if ( runPurpleChunk ) { length(cn_genes) } else { length(NULL) }`** genes with CN values > `r params$cn_gain` (**gains**) or < `r params$cn_loss` (**losses**, see [CN altered genes] section), and reported as either [Cancer genes], [Mutated genes] with [tier](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg){target="_blank"} 1-`r params$pcgr_tier` variants (if mutation information is available) or involved in [Fusion genes] or [Structural variants] (if SV information is available) were screened for suitable drugs.

#### Gains

```{r drugs_predictive_CN_altered_genes_gains, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate table with drugs targeting CN altered genes
genes <- mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL

drugsTable.CN_altered_genes_gains <- civicDrugTable(genes, civic_var_summaries  = caner_genes_annot.list[["civic_var_summaries"]], civic_clin_evid  = caner_genes_annot.list[["civic_clin_evid"]],  evid_type = "Predictive", var_type = "copy_gain")

drugsTable.CN_altered_genes_gains[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=drugsTable.CN_altered_genes_gains[[1]], file=paste(drugsTableDir, "drugsTable.CN_altered_genes_gains.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

**[Evidence Level](https://civicdb.org/help/evidence/evidence-levels){target="_blank"}**

* **A - Validated association**: Proven/consensus association in human medicine
* **B - Clinical evidence**: Clinical trial or other primary patient data supports association
* **C - Case study**: Individual case reports from clinical journals
* **D - Preclinical evidence**: *In vivo* or *in vitro* models support association
* **E - Inferential association**: Indirect evidence

**[Trust Rating](https://civicdb.org/help/evidence/trust-ratings){target="_blank"}**

* **5**: Strong, well supported evidence from a lab or journal with respected academic standing. Experiments are well controlled, and results are clean and reproducible across multiple replicates. Evidence confirmed using independent methods. The study is statistically well powered
* **4**: Strong, well supported evidence. Experiments are well controlled, and results are convincing. Any discrepancies from expected results are well-explained and not concerning
* **3**: Evidence is convincing, but not supported by a breadth of experiments. May be smaller scale projects, or novel results without many follow-up experiments. Discrepancies from expected results are explained and not concerning
* **2**: Evidence is not well supported by experimental data, and little follow-up data is available. Publication is from a journal with low academic impact. Experiments may lack proper controls, have small sample size, or are not statistically convincing
* **1**: Claim is not supported well by experimental evidence. Results are not reproducible, or have very small sample size. No follow-up is done to validate novel claims

**[Actionability Score ](https://civicdb.org/help/variants/actionability-score){target="_blank"}**

* [CIViC Actionability Score](https://civicdb.org/help/variants/actionability-score){target="_blank"} allows to assess the accumulation of evidence for each variant. It is calculated by adding all Evidence Item Scores for each variant. The Evidence Item Score is calculated by multiplying the evidence level (A=10 points, B=5 points, C=3 points, D=1 point, E=0.25 points) by the trust rating (each Star = 1 point).

</font> 
</details>

***

#### Losses

```{r drugs_predictive_CN_altered_genes_losses, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate table with drugs targeting CN altered genes
genes <- mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL

drugsTable.CN_altered_genes_losses <- civicDrugTable(genes, civic_var_summaries  = caner_genes_annot.list[["civic_var_summaries"]], civic_clin_evid  = caner_genes_annot.list[["civic_clin_evid"]],  evid_type = "Predictive", var_type = "copy_loss")

drugsTable.CN_altered_genes_losses[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" || params$plots_mode == "semi-interactive" ) {
  DT::saveWidget(widget=drugsTable.CN_altered_genes_losses[[1]], file=paste(drugsTableDir, "drugsTable.CN_altered_genes_losses.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">

**[Evidence Level](https://civicdb.org/help/evidence/evidence-levels){target="_blank"}**

* **A - Validated association**: Proven/consensus association in human medicine
* **B - Clinical evidence**: Clinical trial or other primary patient data supports association
* **C - Case study**: Individual case reports from clinical journals
* **D - Preclinical evidence**: *In vivo* or *in vitro* models support association
* **E - Inferential association**: Indirect evidence

**[Trust Rating](https://civicdb.org/help/evidence/trust-ratings){target="_blank"}**

* **5**: Strong, well supported evidence from a lab or journal with respected academic standing. Experiments are well controlled, and results are clean and reproducible across multiple replicates. Evidence confirmed using independent methods. The study is statistically well powered
* **4**: Strong, well supported evidence. Experiments are well controlled, and results are convincing. Any discrepancies from expected results are well-explained and not concerning
* **3**: Evidence is convincing, but not supported by a breadth of experiments. May be smaller scale projects, or novel results without many follow-up experiments. Discrepancies from expected results are explained and not concerning
* **2**: Evidence is not well supported by experimental data, and little follow-up data is available. Publication is from a journal with low academic impact. Experiments may lack proper controls, have small sample size, or are not statistically convincing
* **1**: Claim is not supported well by experimental evidence. Results are not reproducible, or have very small sample size. No follow-up is done to validate novel claims

**[Actionability Score ](https://civicdb.org/help/variants/actionability-score){target="_blank"}**

* [CIViC Actionability Score](https://civicdb.org/help/variants/actionability-score){target="_blank"} allows to assess the accumulation of evidence for each variant. It is calculated by adding all Evidence Item Scores for each variant. The Evidence Item Score is calculated by multiplying the evidence level (A=10 points, B=5 points, C=3 points, D=1 point, E=0.25 points) by the trust rating (each Star = 1 point).

</font> 
</details>

***

## Addendum

<details>
<summary>Parameters</summary>
<font size="2">

```{r params_info, comment = NA}
for ( i in 1:length(params) ) {

  cat(paste("Parameter: ", names(params)[i], "\nValue: ", paste(unlist(params[i]), collapse = ","), "\n\n", sep=""))
}
```

</font>
</details>

<details>
<summary>Session info</summary>
<font size="2">

```{r sessioninfo, comment = NA}
devtools::session_info()
```

</font>
</details>
